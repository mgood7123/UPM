<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Graphite Table Format</title><link rel="stylesheet" type="text/css" href="graphite.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /></head><body><div xml:lang="en" class="article" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="idm139917900838768"></a>Graphite Table Format</h2></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#_introduction">1. Introduction</a></span></dt><dt><span class="section"><a href="#_version">2. Version</a></span></dt><dt><span class="section"><a href="#_tables">3. Tables</a></span></dt><dd><dl><dt><span class="section"><a href="#_glat">3.1. Glat</a></span></dt><dt><span class="section"><a href="#_gloc">3.2. Gloc</a></span></dt><dt><span class="section"><a href="#_feat">3.3. Feat</a></span></dt><dt><span class="section"><a href="#_silf">3.4. Silf</a></span></dt><dt><span class="section"><a href="#_pass">3.5. Pass</a></span></dt><dt><span class="section"><a href="#_sile">3.6. Sile</a></span></dt><dt><span class="section"><a href="#_sill">3.7. Sill</a></span></dt><dt><span class="section"><a href="#_sild">3.8. Sild</a></span></dt></dl></dd><dt><span class="section"><a href="#_multiple_descriptions">4. Multiple Descriptions</a></span></dt><dt><span class="section"><a href="#_stack_machine_commands">5. Stack Machine Commands</a></span></dt><dd><dl><dt><span class="section"><a href="#_general_arithmetic_operations">5.1. General arithmetic operations</a></span></dt><dt><span class="section"><a href="#_rule_processing_and_constraints">5.2. Rule processing and constraints</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_introduction"></a>1. Introduction</h2></div></div></div><p>The Graphite font table format is structured in order that a Graphite
binary description may be incorporated into a TrueType font. Thus the
binary format uses the TrueType table structure, identically to how it
is used in a TrueType font. The only difference between using an
external file containing Graphite binary information in tables, and
inserting the binary information into tables in the font is that tables
are considered local to their file and are considered to override those
found in the font file. This allows there to be multiple, independent
descriptions held in separate files. Those independent descriptions
would have to be merged, in a way described in this document, if they
were to be held together in the same font file or binary file.</p><p>The description consists of a set of table descriptions. The format of a
file follows that of a TrueType font containing only those tables
pertinent to the description (i.e. for a separate binary description,
those tables listed here).</p><p>As is standard for all TrueType tables, the data is in big-endian format
(most significant byte first).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_version"></a>2. Version</h2></div></div></div><p>This file describes version 4.0 of the Graphite font table
specification. Modifications from previous versions are indicated in the
“Version notes” column of the various tables.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_tables"></a>3. Tables</h2></div></div></div><p>This document describes several additional TrueType table types. The
“Silf” and “Sile” tables are unique to the needs of Graphite, whilst
“Gloc” and “Glat” provide an extended glyph attribute mechanism. The
“Feat” table is based very closely on the GX “feat” table. (If necessary
the tables could be restructured to be stored inside the single “Silf”
table.) In addition, use is made of the “name” table type.</p><p>This version of the Graphite format includes the ability to compress
“Glat” and “Silf” tables, the extensions to those table provide a
compression scheme field permitting up to 32 compression schemes.
Currently only 2 schemes are defined: 0 – no compression, and 1 – an LZ4 block
decompressor. This is not the LZ4 framing format just the inner block level
format without any checksum.</p><p>All compressed tables have the same form the original table’s 32bit
version number followed by a 32 bit compression header. This consists of
the top 5 bits for the scheme and 27 remaining bits for the uncompressed
table size. This is then followed by the compression scheme’s data.</p><div class="table"><a id="comp_table"></a><p class="title"><strong>Table 1. Compressed table</strong></p><div class="table-contents"><table class="table" summary="Compressed table" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type     </th><th style="" align="left" valign="top">Name            </th><th style="" align="left" valign="top">Description                       </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>version</p></td><td style="" align="left" valign="top"><p>Uncompressed Table version number</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG:5</p></td><td style="" align="left" valign="top"><p>scheme</p></td><td style="" align="left" valign="top"><p>Compression scheme must not be 0</p></td><td style="" align="left" valign="top"><p>5.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG:27</p></td><td style="" align="left" valign="top"><p>full_size</p></td><td style="" align="left" valign="top"><p>Size of uncompressed table</p></td><td style="" align="left" valign="top"><p>5.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE[]</p></td><td style="" align="left" valign="top"><p>compressed_data</p></td><td style="" align="left" valign="top"><p>Compression scheme data</p></td><td style="" align="left" valign="top"><p>5.0 – added</p></td></tr></tbody></table></div></div><br class="table-break" /><p>The uncompressed form is the complete table including the version number but
with the scheme always set to 0. The remaining 27 bits are available to the
uncompressed table.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_glat"></a>3.1. Glat</h3></div></div></div><p>The Glat table type is used for storing glyph attributes. Each glyph may
be considered to have a sparse array of, at the most, 65536 16-bit
signed attributes. The Glat table is the mechanism by which they are
stored.</p><p>The Glat table consists of a table header and an array of Glat_entry
items. Two formats for the Glat table are typically used. Most fonts will
use a version 2 table without Octabox metrics. Those few fonts that
have collision avoidance support, will use a version 3 table.</p><div class="table"><a id="idm139917900933872"></a><p class="title"><strong>Table 2. Glat version 2</strong></p><div class="table-contents"><table class="table" summary="Glat version 2" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type         </th><th style="" align="left" valign="top">Name       </th><th style="" align="left" valign="top">Description             </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>version</p></td><td style="" align="left" valign="top"><p>Table version: 00030000</p></td><td style="" align="left" valign="top"><p>4.0 – 00020000</p></td></tr><tr><td style="" align="left" valign="top"><p>Glat_entry[]</p></td><td style="" align="left" valign="top"><p>entries</p></td><td style="" align="left" valign="top"><p>Glyph attribute entries</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idm139917895096704"></a><p class="title"><strong>Table 3. Glat version 3</strong></p><div class="table-contents"><table class="table" summary="Glat version 3" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type            </th><th style="" align="left" valign="top">Name      </th><th style="" align="left" valign="top">Description                  </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>version</p></td><td style="" align="left" valign="top"><p>Table version: 00030000</p></td><td style="" align="left" valign="top"><p>5.0 – 00030000</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG:5</p></td><td style="" align="left" valign="top"><p>scheme</p></td><td style="" align="left" valign="top"><p>Compression scheme must be 0</p></td><td style="" align="left" valign="top"><p>5.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG:28</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>5.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG:1</p></td><td style="" align="left" valign="top"><p>octaboxes</p></td><td style="" align="left" valign="top"><p>Octaboxes are present flag</p></td><td style="" align="left" valign="top"><p>5.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>Glyph_attrs[]</p></td><td style="" align="left" valign="top"><p>entries</p></td><td style="" align="left" valign="top"><p>Glyph attribute entries</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>For the compressed layout see <a class="xref" href="#comp_table" title="Table 1. Compressed table">Table 1, “Compressed table”</a>.</p><div class="table"><a id="idm139917895051328"></a><p class="title"><strong>Table 4. Glyph_attrs</strong></p><div class="table-contents"><table class="table" summary="Glyph_attrs" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type            </th><th style="" align="left" valign="top">Name      </th><th style="" align="left" valign="top">Description                   </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>Octabox_metrics</p></td><td style="" align="left" valign="top"><p>octabox</p></td><td style="" align="left" valign="top"><p>Octabox metrics, only present
                              if the Glat header indicates</p></td><td style="" align="left" valign="top"><p>5.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>Glat_entry[]</p></td><td style="" align="left" valign="top"><p>entries</p></td><td style="" align="left" valign="top"><p>Glyph attribute entries</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>If the octaboxes flag is set in the Glat header then for each per glyph block
of data specified by the Gloc table, first set of data includes metrics that
approximate the glyph’s curves. The approximation uses “octoboxes”—rectangles
with corners that may be cut out at an angle of 45 degrees. Each octobox
requires 8 values to define. There are metrics for the entire glyph and for a
4x4 approximation grid, resulting in up to 16 sub-boxes. For some glyphs, no
sub-box data will be present, in which case the bitmap will be zero.
Note that the rectangle for the full glyph is not included here, as the
bounding box rectangle is stored elsewhere in the font.</p><div class="table"><a id="idm139917895030256"></a><p class="title"><strong>Table 5. Octabox_metrics</strong></p><div class="table-contents"><table class="table" summary="Octabox_metrics" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type           </th><th style="" align="left" valign="top">Name          </th><th style="" align="left" valign="top">Description                        </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>subbox_bitmap</p></td><td style="" align="left" valign="top"><p>Which subboxes exist on 4x4 grid;
                                bit-index = (y-index*4) + x-index</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>diag_neg_min</p></td><td style="" align="left" valign="top"><p>Defines minimum negatively-sloped diagonal</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>diag_neg_max</p></td><td style="" align="left" valign="top"><p>Defines maximum negatively-sloped diagonal</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>diag_pos_min</p></td><td style="" align="left" valign="top"><p>Defines minimum positively-sloped diagonal</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>diag_pos_max</p></td><td style="" align="left" valign="top"><p>Defines maximum positively-sloped diagonal</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>Subbox_entry[]</p></td><td style="" align="left" valign="top"><p>subboxes</p></td><td style="" align="left" valign="top"><p>One entry per bit in subbox_bitmap</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>Note that in the subbox bitmap, bit 3 indicates the presence of the
lower right cell, and bit 12 the upper left cell as per this diagram.</p><div class="table"><a id="idm139917894993296"></a><p class="title"><strong>Table 6. subbox_bitmap</strong></p><div class="table-contents"><table class="table" summary="subbox_bitmap" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; " width="20%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>12</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>13</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>14</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>15</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>8</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>9</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>10</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>11</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>4</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>5</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>6</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>7</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>0</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>1</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>2</p></td><td style="" align="left" valign="top"><p>3</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idm139917894969680"></a><p class="title"><strong>Table 7. Subbox_entry</strong></p><div class="table-contents"><table class="table" summary="Subbox_entry" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name         </th><th style="" align="left" valign="top">Description                                  </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>left</p></td><td style="" align="left" valign="top"><p>Left of subbox</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>right</p></td><td style="" align="left" valign="top"><p>Right of subbox</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>bottom</p></td><td style="" align="left" valign="top"><p>Bottom of subbox</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>top</p></td><td style="" align="left" valign="top"><p>Top of subbox</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>diag_pos_min</p></td><td style="" align="left" valign="top"><p>Defines minimum positively-sloped diagonal</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>diag_pos_max</p></td><td style="" align="left" valign="top"><p>Defines maximum positively-sloped diagonal</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>diag_neg_min</p></td><td style="" align="left" valign="top"><p>Defines minimum  negatively-sloped diagonal</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>diag_neg_max</p></td><td style="" align="left" valign="top"><p>Defines maximum  negatively -sloped diagonal</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>Following the glyph curve approximation data, the glyph attributes
appear. The glyph attributes associated with a particular glyph are
identified by number and value. To conserve space, this storage is
run-length encoded. Thus a glyph will have a series of Glat_entrys
corresponding to each non-contiguous set of attributes. The structure of
a Glat_entry is:</p><div class="table"><a id="idm139917894923888"></a><p class="title"><strong>Table 8. Glat_entry, version 2 &amp; 3</strong></p><div class="table-contents"><table class="table" summary="Glat_entry, version 2 &amp; 3" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type  </th><th style="" align="left" valign="top">Name         </th><th style="" align="left" valign="top">Description                         </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>SHORT</p></td><td style="" align="left" valign="top"><p>attNum</p></td><td style="" align="left" valign="top"><p>Attribute number of first attribute</p></td><td style="" align="left" valign="top"><p>4.0 – BYTE to SHORT</p></td></tr><tr><td style="" align="left" valign="top"><p>SHORT</p></td><td style="" align="left" valign="top"><p>num</p></td><td style="" align="left" valign="top"><p>Number of attributes in this run</p></td><td style="" align="left" valign="top"><p>4.0 – BYTE to SHORT</p></td></tr><tr><td style="" align="left" valign="top"><p>SHORT</p></td><td style="" align="left" valign="top"><p>attributes[]</p></td><td style="" align="left" valign="top"><p>Array of num attributes</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>Notice that all glyph attributes are 16-bit signed values. If a 32-bit
value is required, then two attributes should be assigned and joined
together by the application.</p><p>Attribute numbers are application specific.</p><p>Note that if the font does not require more than 256 glyph attributes,
version 1 of the Glat table will be generated, which is defined as
follows.</p><div class="table"><a id="idm139917894898544"></a><p class="title"><strong>Table 9. Glat version 1</strong></p><div class="table-contents"><table class="table" summary="Glat version 1" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>version</p></td><td style="" align="left" valign="top"><p>Table version: 00010000</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>Glat_entry[]</p></td><td style="" align="left" valign="top"><p>entries</p></td><td style="" align="left" valign="top"><p>Glyph attribute entries</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idm139917894879408"></a><p class="title"><strong>Table 10. Glat_entry, version 1</strong></p><div class="table-contents"><table class="table" summary="Glat_entry, version 1" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attNum</p></td><td style="" align="left" valign="top"><p>Attribute number of first attribute</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>num</p></td><td style="" align="left" valign="top"><p>Number of attributes in this run</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>SHORT</p></td><td style="" align="left" valign="top"><p>attributes[ ]</p></td><td style="" align="left" valign="top"><p>Array of num attributes</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_gloc"></a>3.2. Gloc</h3></div></div></div><p>The Gloc table is used to index the Glat table. It is structured
identically to the loca table type, except that it has a header.</p><p>TODO: add a field indicating the number of glyphs in the table (the
current dependence on the Silf table is not architecturally clean).</p><div class="table"><a id="idm139917894853712"></a><p class="title"><strong>Table 11. Gloc</strong></p><div class="table-contents"><table class="table" summary="Gloc" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>version</p></td><td style="" align="left" valign="top"><p>Table version: 00010000</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>flags</p></td><td style="" align="left" valign="top"><p>bit 0 = 1 for Long format, = 0 for short formatbit 1 = 1
for attribute names, = 0 for stripped</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numAttribs</p></td><td style="" align="left" valign="top"><p>Number of attributes</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT/ULONG</p></td><td style="" align="left" valign="top"><p>locations[ ]</p></td><td style="" align="left" valign="top"><p>Offsets into Glat table for each glyph;
(number of  glyph IDs + 1) of these</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>attribIds[ ]</p></td><td style="" align="left" valign="top"><p>Debug id for each attribute</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>The flags entry contains a bit to indicate whether the locations array
is of type USHORT or ULONG. The locations array is identically
structured to that of the loca table. There is one entry per glyph and
an extra entry to identify the length of the final glyph’s attribute
entries. Offsets are given to a Glat_entry in the Glat table. The second
bit indicates whether there is an attribIds array at the end of this
table. If there is, then it contains name IDs for each attribute. If
this bit is not set, then there is no array and the table ends after the
locations array.</p><p>As of version 2 of the Silf table, the values of the breakweight
attribute are interpreted as follows:</p><pre class="literallayout">BREAK_WHITESPACE = 10
BREAK_WORD = 15
BREAK_INTRA = 20
BREAK_LETTER = 30
BREAK_CLIP = 40</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_feat"></a>3.3. Feat</h3></div></div></div><p>Graphite stores features in a table whose format is very similar to the
GX feat table. This makes reference to the name table which is use for
storing feature names and feature value names.</p><div class="table"><a id="idm139917894816688"></a><p class="title"><strong>Table 12. Feat</strong></p><div class="table-contents"><table class="table" summary="Feat" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>version</p></td><td style="" align="left" valign="top"><p>Table version: 00020000</p></td><td style="" align="left" valign="top"><p>3.0 – changed from 00010000 to
00020000</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numFeat</p></td><td style="" align="left" valign="top"><p>Number of features</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>FeatureDefn</p></td><td style="" align="left" valign="top"><p>features[ ]</p></td><td style="" align="left" valign="top"><p>Array of numFeat features</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>Feature­SettingDefn</p></td><td style="" align="left" valign="top"><p>featSettings[ ]</p></td><td style="" align="left" valign="top"><p>Array of feature setting values,
indexed by offset</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idm139917894780672"></a><p class="title"><strong>Table 13. FeatureDefn</strong></p><div class="table-contents"><table class="table" summary="FeatureDefn" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>id</p></td><td style="" align="left" valign="top"><p>Feature ID number</p></td><td style="" align="left" valign="top"><p>3.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numSettings</p></td><td style="" align="left" valign="top"><p>Number of settings</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>3.0 – inserted</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>offset</p></td><td style="" align="left" valign="top"><p>Offset into featSettings list</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>flags</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>label</p></td><td style="" align="left" valign="top"><p>Index into name table for UI label</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idm139917894744640"></a><p class="title"><strong>Table 14. FeatureSettingDefn</strong></p><div class="table-contents"><table class="table" summary="FeatureSettingDefn" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>SHORT</p></td><td style="" align="left" valign="top"><p>value</p></td><td style="" align="left" valign="top"><p>Feature setting value</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>label</p></td><td style="" align="left" valign="top"><p>Index into name table for UI label</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_silf"></a>3.4. Silf</h3></div></div></div><p>The “Silf” table will be used for storing rules and actions for the
various types of tables in a rendering description. The structure of the
Silf table is:</p><div class="table"><a id="idm139917894723776"></a><p class="title"><strong>Table 15. Silf</strong></p><div class="table-contents"><table class="table" summary="Silf" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type     </th><th style="" align="left" valign="top">Name            </th><th style="" align="left" valign="top">Description                  </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>version</p></td><td style="" align="left" valign="top"><p>Table version: 00050000</p></td><td style="" align="left" valign="top"><p>2.0 – changed to 00020000</p></td></tr><tr><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>3.0 – changed to 00030000</p></td></tr><tr><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>5.0 – changed to 00050000</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG:5</p></td><td style="" align="left" valign="top"><p>scheme</p></td><td style="" align="left" valign="top"><p>Compression scheme must be 0</p></td><td style="" align="left" valign="top"><p>5.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>FIXED:27</p></td><td style="" align="left" valign="top"><p>compilerVersion</p></td><td style="" align="left" valign="top"><p>Compiler version that
                            generated this font</p></td><td style="" align="left" valign="top"><p>3.0 – added
                                                          5.0 – changed to 27 bits</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numSub</p></td><td style="" align="left" valign="top"><p>Number of SIL subtables</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>offset[]</p></td><td style="" align="left" valign="top"><p>Array of numSub offsets to the subtables
                            relative to the start of this table</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>SIL_Sub</p></td><td style="" align="left" valign="top"><p>tables[]</p></td><td style="" align="left" valign="top"><p>Array of independent rendering description
                            subtables</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>For the compressed layout see <a class="xref" href="#comp_table" title="Table 1. Compressed table">Table 1, “Compressed table”</a>.
Since one TrueType file may hold multiple independent rendering
descriptions, each rendering description is described in a subtable. The
subtable contains all that is necessary to describe the rendering of one
set of writing systems.</p><div class="table"><a id="idm139917894673008"></a><p class="title"><strong>Table 16. SIL_Sub</strong></p><div class="table-contents"><table class="table" summary="SIL_Sub" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>ruleVersion</p></td><td style="" align="left" valign="top"><p>Version of  stack-machine language used in rules</p></td><td style="" align="left" valign="top"><p>3.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>passOffset</p></td><td style="" align="left" valign="top"><p>offset of oPasses[0] relative to start of sub-table</p></td><td style="" align="left" valign="top"><p>3.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>pseudosOffset</p></td><td style="" align="left" valign="top"><p>offset of pMaps[0] relative to start of
sub-table</p></td><td style="" align="left" valign="top"><p>3.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>maxGlyphID</p></td><td style="" align="left" valign="top"><p>Maximum valid glyph ID (including line-break &amp;
pseudo-glyphs)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>SHORT</p></td><td style="" align="left" valign="top"><p>extraAscent</p></td><td style="" align="left" valign="top"><p>Em-units to be added to the font’s ascent</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>SHORT</p></td><td style="" align="left" valign="top"><p>extraDescent</p></td><td style="" align="left" valign="top"><p>Em-units to be added to the font’s descent</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>numPasses</p></td><td style="" align="left" valign="top"><p>Number of rendering description passes</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>iSubst</p></td><td style="" align="left" valign="top"><p>Index of first substitution pass</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>iPos</p></td><td style="" align="left" valign="top"><p>Index of first Positioning pass</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>iJust</p></td><td style="" align="left" valign="top"><p>Index of first Justification pass</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>iBidi</p></td><td style="" align="left" valign="top"><p>Index of first pass after the bidi pass(must be ⇐ iPos);
0xFF implies no bidi pass</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>flags</p></td><td style="" align="left" valign="top"><p>0 - has line end contextuals, 1 - contextuals,
2-4 - space contextuals, 5 - has collision pass</p></td><td style="" align="left" valign="top"><p>4.0 – added Bit 1</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>maxPreContext</p></td><td style="" align="left" valign="top"><p>Max range for preceding cross-line-boundary
contextualization</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>maxPostContext</p></td><td style="" align="left" valign="top"><p>Max range for following cross-line-boundary
contextualization</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attrPsuedo</p></td><td style="" align="left" valign="top"><p>Glyph attribute number that is used for actual glyph
ID for a pseudo glyph</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attrBreakWeight</p></td><td style="" align="left" valign="top"><p>Glyph attribute number of breakweight attribute</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attrDirectionality</p></td><td style="" align="left" valign="top"><p>Glyph attribute number for directionality
attribute</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attrMirroring</p></td><td style="" align="left" valign="top"><p>Glyph attribute number for mirror.glyph
(mirror.isEncoded directly after)</p></td><td style="" align="left" valign="top"><p>2.0 – added;4.0 – used</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attrSkipPasses</p></td><td style="" align="left" valign="top"><p>Glyph attribute of bitmap indicating key glyphs
for pass optimization</p></td><td style="" align="left" valign="top"><p>2.0 – added;4.0 – used</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>numJLevels</p></td><td style="" align="left" valign="top"><p>Number of justification levels; 0 if no justification</p></td><td style="" align="left" valign="top"><p>2.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>Justification-Level</p></td><td style="" align="left" valign="top"><p>jLevels[ ]</p></td><td style="" align="left" valign="top"><p>Justification information for each
level.</p></td><td style="" align="left" valign="top"><p>2.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numLigComp</p></td><td style="" align="left" valign="top"><p>Number of initial glyph attributes that represent
ligature components</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>numUserDefn</p></td><td style="" align="left" valign="top"><p>Number of user-defined slot attributes</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>maxCompPerLig</p></td><td style="" align="left" valign="top"><p>Maximum number of components per ligature</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>direction</p></td><td style="" align="left" valign="top"><p>Supported direction(s)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attCollisions</p></td><td style="" align="left" valign="top"><p>First of a set of attributes that hold collision flags and constraint box</p></td><td style="" align="left" valign="top"><p>5.0 - used</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>2.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>numCritFeatures</p></td><td style="" align="left" valign="top"><p>Number of critical features</p></td><td style="" align="left" valign="top"><p>2.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>critFeatures[ ]</p></td><td style="" align="left" valign="top"><p>Array of critical features</p></td><td style="" align="left" valign="top"><p>2.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>2.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>numScriptTag</p></td><td style="" align="left" valign="top"><p>Number of scripts this subtable supports</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>scriptTag[ ]</p></td><td style="" align="left" valign="top"><p>Array of numScriptTag script tags</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>lbGID</p></td><td style="" align="left" valign="top"><p>Glyph ID for line-break psuedo-glyph</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>oPasses[ ]</p></td><td style="" align="left" valign="top"><p>Offets to passes relative to the start of this
subtable; numPasses + 1 of these</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numPseudo</p></td><td style="" align="left" valign="top"><p>Number of Unicode → pseudo-glyph mappings</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>searchPseudo</p></td><td style="" align="left" valign="top"><p>(max power of 2 ⇐ numPseudo) * sizeof(PseudoMap)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>pseudoSelector</p></td><td style="" align="left" valign="top"><p>log2(max power of 2⇐ numPseudo)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>pseudoShift</p></td><td style="" align="left" valign="top"><p>numPseudo - searchPseudo</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>PseudoMap</p></td><td style="" align="left" valign="top"><p>pMaps[ ]</p></td><td style="" align="left" valign="top"><p>Mappings between Unicode and pseudo-glyphs in
order of Unicode</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>ClassMap</p></td><td style="" align="left" valign="top"><p>classes</p></td><td style="" align="left" valign="top"><p>Classes object storing replacement classes used in
actions</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>SIL_Pass</p></td><td style="" align="left" valign="top"><p>passes[ ]</p></td><td style="" align="left" valign="top"><p>Array of passes</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>Each justification level has several glyph attributes associated with
it.</p><p>This structure was new as of version 2.0.</p><div class="table"><a id="idm139917894477216"></a><p class="title"><strong>Table 17. JustificationLevel</strong></p><div class="table-contents"><table class="table" summary="JustificationLevel" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attrStretch</p></td><td style="" align="left" valign="top"><p>Glyph attribute number for justify.X.stretch</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attrShrink</p></td><td style="" align="left" valign="top"><p>Glyph attribute number for justify.X.shrink</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attrStep</p></td><td style="" align="left" valign="top"><p>Glyph attribute number for justify.X.step</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>attrWeight</p></td><td style="" align="left" valign="top"><p>Glyph attribute number for justify.X.weight</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>runto</p></td><td style="" align="left" valign="top"><p>Which level starts the next stage</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>A pseudo-glyph is a glyph which contains no font metrics (it has a GID
greater than the numGlyphs entry in the maxp table) but is used in the
rendering process. Each pseudo-glyph has an attribute which is the glyph
ID of a real glyph which will be used to actually render the glyph. The
pseudo-glyph map contains a mapping between Unicode and pseudo-glyph
number:</p><div class="table"><a id="idm139917894432016"></a><p class="title"><strong>Table 18. PseudoMap</strong></p><div class="table-contents"><table class="table" summary="PseudoMap" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>unicode</p></td><td style="" align="left" valign="top"><p>Unicode codepoint</p></td><td style="" align="left" valign="top"><p>2.0 – changed from USHORT to ULONG</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>nPseudo</p></td><td style="" align="left" valign="top"><p>Glyph ID of pseudo-glyph</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>The ClassMap stores the replacement class information for the passes in
this description. Replacement classes are used during substitution where
a glyph id is looked up in one class and the glyph ID at the
corresponding index in another class is substituted. The difficulty with
the storage of such classes is in looking up a glyph ID in an
arbitrarily ordered list. One approach is to use a linear search; this
is very slow, but is stored very simply. Another approach is to order
the glyphs in the class and to store the index against the glyph. Both
approaches are supported in the ClassMap table structure:</p><div class="table"><a id="idm139917894411552"></a><p class="title"><strong>Table 19. ClassMap</strong></p><div class="table-contents"><table class="table" summary="ClassMap" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numClass</p></td><td style="" align="left" valign="top"><p>Number of replacement classes</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numLinear</p></td><td style="" align="left" valign="top"><p>Number of linearly stored replacement classes</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>oClass[ ]</p></td><td style="" align="left" valign="top"><p>Array of numClass + 1 offsets to class arrays from
the beginning of the class map</p></td><td style="" align="left" valign="top"><p>4.0 changed from USHORT</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>glyphs[ ]</p></td><td style="" align="left" valign="top"><p>Glyphs for linear classes</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>LookupClass</p></td><td style="" align="left" valign="top"><p>lookups[ ]</p></td><td style="" align="left" valign="top"><p>An array of numClass – numLinear lookups</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>The LookupClass stores a fast lookup association between glyph ID and
index. Each lookup consists of an ordered list of glyph IDs with the
corresponding index for that glyph. The number of elements in the lookup
is specified by numIds along with a search Range and shift to initialize
a fast binary search engine:</p><div class="table"><a id="idm139917894378240"></a><p class="title"><strong>Table 20. LookupClass</strong></p><div class="table-contents"><table class="table" summary="LookupClass" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numIDs</p></td><td style="" align="left" valign="top"><p>Number of elements in the lookup</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>searchRange</p></td><td style="" align="left" valign="top"><p>(max power of 2⇐ numIDs)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>entrySelector</p></td><td style="" align="left" valign="top"><p>log2(max power of 2⇐ numIDs)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>rangeShift</p></td><td style="" align="left" valign="top"><p>numIds – searchRange</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>LookupPair</p></td><td style="" align="left" valign="top"><p>lookups[ ]</p></td><td style="" align="left" valign="top"><p>lookups; there are numIDs of these</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>Each element in the lookup consists of a glyphId and the corresponding
index in the original ordered list.</p><div class="table"><a id="idm139917894345824"></a><p class="title"><strong>Table 21. LookupPair</strong></p><div class="table-contents"><table class="table" summary="LookupPair" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>glyphId</p></td><td style="" align="left" valign="top"><p>glyph id to be compared</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>index</p></td><td style="" align="left" valign="top"><p>index corresponding to this glyph id in ordered list</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_pass"></a>3.5. Pass</h3></div></div></div><p>Each processing pass consists of a finite state machine description for
rule finding, and the actions that are executed when a rule is matched.</p><div class="table"><a id="idm139917894324992"></a><p class="title"><strong>Table 22. SIL_Pass</strong></p><div class="table-contents"><table class="table" summary="SIL_Pass" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>flags</p></td><td style="" align="left" valign="top"><p>0-2 - number of collision runs; 3-4 - kerning collisions;
5 - reverse direction pass</p></td><td style="" align="left" valign="top"><p>5.0 - added bits 0-5</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>maxRuleLoop</p></td><td style="" align="left" valign="top"><p>MaxRuleLoop for this pass</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>maxRuleContext</p></td><td style="" align="left" valign="top"><p>Number of slots of input needed to run this pass</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>maxBackup</p></td><td style="" align="left" valign="top"><p>Number of slots by which the following pass needs to
trail this pass (ie, the maximum this pass is allowed to back up)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numRules</p></td><td style="" align="left" valign="top"><p>Number of action code blocks</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>fsmOffset</p></td><td style="" align="left" valign="top"><p>offset to numRows relative to the beginning of the
SIL_Pass block</p></td><td style="" align="left" valign="top"><p>2.0 - added; 3.0 - use as fsmOffset</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>pcCode</p></td><td style="" align="left" valign="top"><p>Offset to start of pass constraint code from start of
subtable (<span class="strong"><strong>passConstraints[0]</strong></span>)</p></td><td style="" align="left" valign="top"><p>2.0 - added</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>rcCode</p></td><td style="" align="left" valign="top"><p>Offset to start of rule constraint code from start of
subtable (<span class="strong"><strong>ruleConstraints[0]</strong></span>)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>aCode</p></td><td style="" align="left" valign="top"><p>Offset to start of action code relative to start of
subtable (<span class="strong"><strong>actions[0]</strong></span>)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>oDebug</p></td><td style="" align="left" valign="top"><p>Offset to debug arrays (<span class="strong"><strong>dActions[0]</strong></span>); equals 0 if
debug stripped</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numRows</p></td><td style="" align="left" valign="top"><p>Number of FSM states</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numTransitional</p></td><td style="" align="left" valign="top"><p>Number of transitional states in the FSM
(length of <span class="strong"><strong>states</strong></span> matrix)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numSuccess</p></td><td style="" align="left" valign="top"><p>Number of success states in the FSM (size of
<span class="strong"><strong>oRuleMap</strong></span> array)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numColumns</p></td><td style="" align="left" valign="top"><p>Number of FSM columns</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numRange</p></td><td style="" align="left" valign="top"><p>Number of contiguous glyph ID ranges which map to
columns</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>searchRange</p></td><td style="" align="left" valign="top"><p>(maximum power of 2 ⇐
numRange)*sizeof(Pass_Range)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>entrySelector</p></td><td style="" align="left" valign="top"><p>log2(maximum power of 2 ⇐ numRange)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>rangeShift</p></td><td style="" align="left" valign="top"><p>numRange*sizeof(Pass_Range)-searchRange</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>Pass_Range</p></td><td style="" align="left" valign="top"><p>ranges[ ]</p></td><td style="" align="left" valign="top"><p>Ranges of glyph IDs for this FSM; <span class="strong"><strong>numRange</strong></span> of
these</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>oRuleMap[ ]</p></td><td style="" align="left" valign="top"><p>Maps from success state to offset into ruleMap
array from start of array. First item corresponds to state # (numRows –
numSuccess); ie, non-success states are omitted. [0xFFFF implies rule
number is equal to state number (i.e. no entry in ruleMap) – NOT
IMPLEMENTED]</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>ruleMap[ ]</p></td><td style="" align="left" valign="top"><p>Array of rule numbers corresponding to an success
state number</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>minRulePreContext</p></td><td style="" align="left" valign="top"><p>Minimum number of items in any rule’s context
before the first modified rule item</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>maxRulePreContext</p></td><td style="" align="left" valign="top"><p>Maximum number of items in any rule’s context
before the first modified rule item</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>SHORT</p></td><td style="" align="left" valign="top"><p>startStates[ ]</p></td><td style="" align="left" valign="top"><p>Array of size (maxRulePreContext –
minRulePreContext + 1), indicating the start state in the state machine
based on how many pre-context items a rule has</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>ruleSortKeys[ ]</p></td><td style="" align="left" valign="top"><p>Array of <span class="strong"><strong>numRules</strong></span> sort keys, indicating
precedence of rules</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>rulePreContext[ ]</p></td><td style="" align="left" valign="top"><p>Array of <span class="strong"><strong>numRules</strong></span> items indicating the
number of items in the context before the first modified item, one for
each rule</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>collisionThreshold</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>2.0 - inserted, 5.0 – used</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>pConstraint</p></td><td style="" align="left" valign="top"><p>Length of passConstraint block</p></td><td style="" align="left" valign="top"><p>2.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>oConstraints[ ]</p></td><td style="" align="left" valign="top"><p>numRules + 1 offsets to constraint code blocks
relative to <span class="strong"><strong>rcCode</strong></span> and start of subtable</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>oActions[ ]</p></td><td style="" align="left" valign="top"><p>numRules + 1 offsets to action code blocks
relative to <span class="strong"><strong>aCode</strong></span> and start of subtable</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>stateTrans[ ][ ]</p></td><td style="" align="left" valign="top"><p>Array of <span class="strong"><strong>numTransitional</strong></span> rows of
<span class="strong"><strong>numColumns</strong></span> state transitions.</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>2.0 – inserted</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>passConstraints[ ]</p></td><td style="" align="left" valign="top"><p>Sequences of constraint code for pass-level
constraints</p></td><td style="" align="left" valign="top"><p>2.0 – added</p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>ruleConstraints[ ]</p></td><td style="" align="left" valign="top"><p>Sequences of constraint code for rules</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>actions[ ]</p></td><td style="" align="left" valign="top"><p>Sequences of action code</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p><a href="#ftn.idm139917894154160" class="footnote" id="idm139917894154160"><sup class="footnote">[a]</sup></a>USHORT</p></td><td style="" align="left" valign="top"><p>dActions[ ]</p></td><td style="" align="left" valign="top"><p>Name index for each action for
documentation purposes. 0 = stripped. numRules of these</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>dStates[ ]</p></td><td style="" align="left" valign="top"><p>Name index for each intermediateFSM row/state for
debugging. 0 = stripped.  Corresponds to the last numRows – numRules</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>dCols[ ]</p></td><td style="" align="left" valign="top"><p>Name index for each state (numRows of these)</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="4"><div id="ftn.idm139917894154160" class="footnote"><p><a href="#idm139917894154160" class="simpara"><sup class="simpara">[a] </sup></a> Should debug tables go at the end, and be marked via a flag
as per Gloc?</p></div></td></tr></tbody></table></div></div><br class="table-break" /><p>Notice that the ranges array has fast lookup information on the front to
allow for the quick identification of which range a particular glyph id
is in. Each range consists of the first and last glyph id in the range.</p><div class="table"><a id="idm139917894140320"></a><p class="title"><strong>Table 23. Pass_Range</strong></p><div class="table-contents"><table class="table" summary="Pass_Range" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>firstId</p></td><td style="" align="left" valign="top"><p>First Glyph id in the range</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>lastId</p></td><td style="" align="left" valign="top"><p>Last Glyph id in the range</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>colId</p></td><td style="" align="left" valign="top"><p>Column index for this range</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_pass_contents"></a>Pass Contents</h4></div></div></div><p>A pass contains a Finite State Machine (FSM) which is used to match
input strings to rules. It also contains constraints for further testing
whether a matched string should fire, and it contains the action code to
execute against the matched string.</p><p>The FSM consists of a set of states. A state consists of a row of
transitions between that state and another state dependent upon the next
glyph in the input stream. Each state may be an acceptance state, in
which case it corresponds to a rule match, or a transition state, in
which case the state is on the way to matching a rule, or both.  A null
state transition is one in which the occurrence of this particular class
of the following glyph, will result in no extension of a rule match
anywhere, just fail on all further searching. A final state is one in
which all its transitions are null transitions.</p><p>Note that the stateTrans array only needs to represent transitional
states, not final states. Similarly, the oRuleMap array only needs
entries for acceptance states (whether final or transitional). For this
reason the FSM is set up (conceptually) in the following order:
transitional non-accepting states first, followed by transitional
accepting states, followed by final (accepting) states.</p><p>Note also that because there may be more than one matched rule for a
given state, oRuleMap indicates a list of rule indices in the ruleMap
array; oRuleMap[i+1] – oRuleMap[i] indicates how many there are for
state i.</p><p>Normally the start state for an FSM is zero. But for each pass there is
the idea of a “pre-context,” that is, there are slots that need to be
taken into consideration in the rule-matching process that are before
the current position of the input stream. If we are very near the
beginning of the input, we may need to adjust by skipping some states,
which corresponds to skipping the “pre-context” slots that not present
due to being prior to the beginning of the input.  This is what the
maxRulePreContext, minRulePreContext, and startStates items are used
for. Specifically, we need to skip the number of transitions equal to
the difference between the maxRulePreContext and the current stream
position, if greater than zero. The startStates array indicates what the
adjusted start state should be. If the current input position is less
than minRulePreContext, no rule will match at all.</p><p>Rules are matched in order of length, so that longest rules are given
precedence over shorter rules. However, the length of some rules may
have been adjusted to allow for a consistent “pre-context” for all
rules, so the number of matched states in the FSM may not correspond to
the actual number of matched items in the rule. For this reason, it is
not adequate to simply order rules based on the number of traversed
states in the FSM. Rather, rules are given sort keys indicating their
precedence, which is based primarily on the length of the rule and
secondarily on its original position within the source code.</p><p>The FSM engine keeps track of all the acceptance states it passes
through on its path to a final state. This results in a list of rules
matched by the string sorted by precedence. The engine takes the first
rule index off the list and looks up the offset to some constraint code.
This code is executed and if the constraint passes, then the action code
associated with that offset is executed and the FSM restarts at the
returned slot position. If the constraint fails, then the FSM considers
the next-preferred rule, tests that constraint, and so forth. If no
accepting state is found or all rules fail their constraints, then no
rule applies, in which case a single glyph is put into the output stream
and the current position advances by one slot.</p><p>The action strings are simply byte strings of actions, much like hinting
code, but using a completely different language. (See “Stack Machine
Commands.doc”.)</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_sile"></a>3.6. Sile</h3></div></div></div><p>This table is used in Graphite table files that rely on an external font
for rendering of the glyphs. When this table is present, the Graphite
file is in effect a minimal font that contains information about the
actual font to use in rendering. This information is stored in the Sile
table.</p><p>This table was added as of version 2. It is not currently being used.</p><div class="table"><a id="idm139917901002992"></a><p class="title"><strong>Table 24. Sile</strong></p><div class="table-contents"><table class="table" summary="Sile" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>version</p></td><td style="" align="left" valign="top"><p>Table version: 00010000</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>checksum</p></td><td style="" align="left" valign="top"><p>master checksum (checkSumAdjustment) from the head
table of the base font</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>createTime[2]</p></td><td style="" align="left" valign="top"><p>Create time of the base font (64-bits) from the
head table</p></td></tr><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>modifyTime[2]</p></td><td style="" align="left" valign="top"><p>Modify time of the base font (64-bits) from the
head table</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>fontNameLength</p></td><td style="" align="left" valign="top"><p>Number of characters in fontName</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>fontName[ ]</p></td><td style="" align="left" valign="top"><p>Family name of base font</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>fontFileLength</p></td><td style="" align="left" valign="top"><p>Number of characters in baseFile</p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>baseFile[ ]</p></td><td style="" align="left" valign="top"><p>Original path and name of base font file</p></td></tr></tbody></table></div></div><br class="table-break" /><p>There are four possible situations with regard to the Sile table. The
first two are considered normal and the second two pathological.</p><p>No Sile table is present. In this case, it is assumed that the Graphite
table file is a normal font containing not only the Graphite tables but
also the glyphs and metrics needed for rendering.</p><p>The base font named in the Sile table is present on the system, and its
master checksum and dates match those in the Sile table. In this case,
the Graphite tables are read from the Graphite table file, but the
glyphs, metrics, and cmap from the base font are what are used for
rendering (with the modification performed by the Graphite tables).</p><p>The base font named in the Sile table is present, but its master
checksum and/or dates do not match those in the Sile table. In this case
the base font is used to perform the rendering, but with no Graphite
behaviors.</p><p>The base font named in the Sile table is not present on the system. In
this case the Graphite table file is used for the rendering, with no
Graphite behaviors, resulting in square boxes in place of the expected
glyphs.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_sill"></a>3.7. Sill</h3></div></div></div><p>This table maps ISO-639-3 language codes onto feature values. Each
language code can be a maxmum of 4 ASCII characters (although 2 or 3
characters is what is used by the ISO standard).</p><p>This table was added as of version 3.</p><div class="table"><a id="idm139917894058112"></a><p class="title"><strong>Table 25. Sill</strong></p><div class="table-contents"><table class="table" summary="Sill" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>FIXED</p></td><td style="" align="left" valign="top"><p>version</p></td><td style="" align="left" valign="top"><p>Table version: 00010000</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numLangs</p></td><td style="" align="left" valign="top"><p>Number of languages supported</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>searchRange</p></td><td style="" align="left" valign="top"><p>(maximum power of 2 ⇐ numLangs)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>entrySelector</p></td><td style="" align="left" valign="top"><p>log2(maximum power of 2 ⇐ numLangs)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>rangeShift</p></td><td style="" align="left" valign="top"><p>numLangs  - searchRange</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>LanguageEntry</p></td><td style="" align="left" valign="top"><p>entries[ ]</p></td><td style="" align="left" valign="top"><p>Languages and pointers to feature settings;
there are numLang + 1 of these</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>LangFeatureSetting</p></td><td style="" align="left" valign="top"><p>settings[ ]</p></td><td style="" align="left" valign="top"><p>Feature ID / value pairs</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><p>Each language entry contains a 4-character language code and an offset
to the list of features. There is one bogus entry at the end that
facilitates finding the size of the last entry. The offsets are relative
to the beginning of the Sill table.</p><p>The language code is left-aligned with any unused characters padded with
NULLs. For instance, the code “en” is represented by the four bytes
[101, 110, 0, 0].</p><div class="table"><a id="idm139917894016416"></a><p class="title"><strong>Table 26. LanguageEntry</strong></p><div class="table-contents"><table class="table" summary="LanguageEntry" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>BYTE</p></td><td style="" align="left" valign="top"><p>langcode[4]</p></td><td style="" align="left" valign="top"><p>4-char ISO-639-3 language code</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>numSettings</p></td><td style="" align="left" valign="top"><p>Number of feature settings for this language</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>offset</p></td><td style="" align="left" valign="top"><p>Offset to first feature setting for this language</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idm139917893993056"></a><p class="title"><strong>Table 27. LangFeatureSetting</strong></p><div class="table-contents"><table class="table" summary="LangFeatureSetting" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="90%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Type </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Description </th><th style="" align="left" valign="top">Version notes</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>ULONG</p></td><td style="" align="left" valign="top"><p>featureId</p></td><td style="" align="left" valign="top"><p>Feature identifer number (matches ID in Feat table)</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>SHORT</p></td><td style="" align="left" valign="top"><p>value</p></td><td style="" align="left" valign="top"><p>Default feature value for this language</p></td><td style="" align="left" valign="top"><p></p></td></tr><tr><td style="" align="left" valign="top"><p>USHORT</p></td><td style="" align="left" valign="top"><p>reserved</p></td><td style="" align="left" valign="top"><p>Pad bytes</p></td><td style="" align="left" valign="top"><p></p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_sild"></a>3.8. Sild</h3></div></div></div><p>This table holds the debug strings for debugging purposes. Since the
strings are only used for debugging, they are held somewhat optimised
for space over speed and are not considered to be multilingual. Thus
strings are considered to be 7-bit ASCII, with a possible extension to
UTF-8 at a later stage. The table consists of a sequence of strings each
preceded by a length byte. The first string is id 0 and so on to the end
of the table.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>this table has not been implemented.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_multiple_descriptions"></a>4. Multiple Descriptions</h2></div></div></div><p>In the case where multiple descriptions are to be stored in the same set
of tables, the following unifications need to occur:</p><p>The feature sets must be unified, thus limiting two features with the
same name to having the same settings and corresponding values.</p><p>The glyph attributes must be unified. This can be done by using
different attribute number ranges, or by examining for identical
attribute mappings or for non-intersecting attribute mappings.</p><p>The use of the name table must be unified to ensure that two features or
feature settings do not refer to the same entry in the name table.</p><p>Notice that the requirement that any tables declared in an external
binary description override the corresponding font table in the font,
means that a name table in an external binary description must be
complete, including all the strings from the original font.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_stack_machine_commands"></a>5. Stack Machine Commands</h2></div></div></div><p>This document describes the commands that are defined in Graphite’s stack machine, which are used to run rules and test their constraints.
&lt;offset&gt; is a slot offset relative to the current slot that opcodes act upon.
Any opcode with a value outside the range of opcodes listed here (currently 0x00-0x3E) is considered illegal and will cause the font to fail to load.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_general_arithmetic_operations"></a>5.1. General arithmetic operations</h3></div></div></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="100%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="" align="left" valign="top">Code </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Param </th><th style="" align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>00</p></td><td style="" align="left" valign="top"><p>NOP</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Do nothing.</p></td></tr><tr><td style="" align="left" valign="top"><p>01</p></td><td style="" align="left" valign="top"><p>PushByte</p></td><td style="" align="left" valign="top"><p>&lt;byte&gt;</p></td><td style="" align="left" valign="top"><p>Push the given 8-bit signed number onto the stack.</p></td></tr><tr><td style="" align="left" valign="top"><p>02</p></td><td style="" align="left" valign="top"><p>PushByteU</p></td><td style="" align="left" valign="top"><p>{byte}</p></td><td style="" align="left" valign="top"><p>Push the given 8-bit unsigned number onto the stack.</p></td></tr><tr><td style="" align="left" valign="top"><p>03</p></td><td style="" align="left" valign="top"><p>PushShort</p></td><td style="" align="left" valign="top"><p>&lt;short&gt;</p></td><td style="" align="left" valign="top"><p>Push the 2 byte number onto the stack.</p></td></tr><tr><td style="" align="left" valign="top"><p>04</p></td><td style="" align="left" valign="top"><p>PushShortU</p></td><td style="" align="left" valign="top"><p>{short}</p></td><td style="" align="left" valign="top"><p>Push the 2 byte unsigned number onto the stack.</p></td></tr><tr><td style="" align="left" valign="top"><p>05</p></td><td style="" align="left" valign="top"><p>PushLong</p></td><td style="" align="left" valign="top"><p>&lt;long&gt;</p></td><td style="" align="left" valign="top"><p>Push the 4 byte number onto the stack. There is no sign extension so no need for an unsigned opcode</p></td></tr><tr><td style="" align="left" valign="top"><p>06</p></td><td style="" align="left" valign="top"><p>Add</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack, add them, and push the result.</p></td></tr><tr><td style="" align="left" valign="top"><p>07</p></td><td style="" align="left" valign="top"><p>Sub</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack, subtract the first (top-most) from the second, and push the result.</p></td></tr><tr><td style="" align="left" valign="top"><p>08</p></td><td style="" align="left" valign="top"><p>Mul</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack, multiply them, and push the result.</p></td></tr><tr><td style="" align="left" valign="top"><p>09</p></td><td style="" align="left" valign="top"><p>Div</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack, divide the second by the first (top-most), and push the result.</p></td></tr><tr><td style="" align="left" valign="top"><p>0A</p></td><td style="" align="left" valign="top"><p>Min</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push the minimum.</p></td></tr><tr><td style="" align="left" valign="top"><p>0B</p></td><td style="" align="left" valign="top"><p>Max</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push the maximum.</p></td></tr><tr><td style="" align="left" valign="top"><p>0C</p></td><td style="" align="left" valign="top"><p>Neg</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top item off the stack and push the negation.</p></td></tr><tr><td style="" align="left" valign="top"><p>0D</p></td><td style="" align="left" valign="top"><p>Trunc8</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top item off the stack and push the value truncated to 8 bits.</p></td></tr><tr><td style="" align="left" valign="top"><p>0E</p></td><td style="" align="left" valign="top"><p>Trunc16</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top item off the stack and push the value truncated to 16 bits.</p></td></tr><tr><td style="" align="left" valign="top"><p>0F</p></td><td style="" align="left" valign="top"><p>Cond</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top three items off the stack. If the first == 0 (false), push the third back on, otherwise push the second back on.</p></td></tr><tr><td style="" align="left" valign="top"><p>10</p></td><td style="" align="left" valign="top"><p>And</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push their logical and. Zero is treated as false; all other values are treated as true.</p></td></tr><tr><td style="" align="left" valign="top"><p>11</p></td><td style="" align="left" valign="top"><p>Or</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push their logical or. Zero is treated as false; all other values are treated as true.</p></td></tr><tr><td style="" align="left" valign="top"><p>12</p></td><td style="" align="left" valign="top"><p>Not</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top item off the stack and push its logical negation (1 if it equals zero, 0 otherwise.</p></td></tr><tr><td style="" align="left" valign="top"><p>13</p></td><td style="" align="left" valign="top"><p>Equal</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push 1 if they are equal, 0 if not.</p></td></tr><tr><td style="" align="left" valign="top"><p>14</p></td><td style="" align="left" valign="top"><p>NotEqu</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push 0 if they are equal, 1 if not.</p></td></tr><tr><td style="" align="left" valign="top"><p>15</p></td><td style="" align="left" valign="top"><p>Less</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push 1 if the next-to-the-top is less than the top-most; push 0 othewise.</p></td></tr><tr><td style="" align="left" valign="top"><p>16</p></td><td style="" align="left" valign="top"><p>Gtr</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push 1 if the next-to-the-top is greater than the top-most; push 0 othewise.</p></td></tr><tr><td style="" align="left" valign="top"><p>17</p></td><td style="" align="left" valign="top"><p>LessEq</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push 1 if the next-to-the-top is less than or equal to the top-most; push 0 otherwise.</p></td></tr><tr><td style="" align="left" valign="top"><p>18</p></td><td style="" align="left" valign="top"><p>GtrEq</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack and push 1 if the next-to-the-top is greater than or equal to the top-most; push 0 otherwise</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_rule_processing_and_constraints"></a>5.2. Rule processing and constraints</h3></div></div></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; " width="100%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /><col class="col_5" /><col class="col_6" /></colgroup><thead><tr><th style="" align="left" valign="top">Code </th><th style="" align="left" valign="top">Name </th><th style="" align="left" valign="top">Param </th><th style="" align="left" valign="top">Param </th><th style="" align="left" valign="top">Param </th><th style="" align="left" valign="top">Description</th></tr></thead><tbody><tr><td style="" align="left" valign="top"><p>19</p></td><td style="" align="left" valign="top"><p>Next</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Move the current slot pointer forward one slot (used after we have finished processing that slot).</p></td></tr><tr><td style="" align="left" valign="top"><p>1A</p></td><td style="" align="left" valign="top"><p>NextN</p></td><td style="" align="left" valign="top"><p>&lt;count&gt;</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Not Implemented: Move the current slot pointer by the given number of slots (used after we have finished processing the current slot). The count may be positive or negative. Should not be used to copy a range of slots; CopyNext is needed for that.</p></td></tr><tr><td style="" align="left" valign="top"><p>1B</p></td><td style="" align="left" valign="top"><p>CopyNext</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Copy the current slot from the input to the output and move the current slot pointer forward one slot.</p></td></tr><tr><td style="" align="left" valign="top"><p>1C</p></td><td style="" align="left" valign="top"><p>PutGlyph</p></td><td style="" align="left" valign="top"><p>{outclass}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Put the first glyph of the specified class into the output. Normally used when there is only one member of the class, and when inserting.</p></td></tr><tr><td style="" align="left" valign="top"><p>1D</p></td><td style="" align="left" valign="top"><p>PutSubs</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p>{inclass}</p></td><td style="" align="left" valign="top"><p>{outclass}</p></td><td style="" align="left" valign="top"><p>Determine the index of the glyph that was the input in the given slot within the input class, and place the corresponding glyph from the output class in the current slot. The slot number is relative to the current input position.</p></td></tr><tr><td style="" align="left" valign="top"><p>1E</p></td><td style="" align="left" valign="top"><p>PutCopy</p></td><td style="" align="left" valign="top"><p>&lt;offset</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Copy the glyph that was in the input in the given slot into the current output slot. The slot number is relative to the current input position.</p></td></tr><tr><td style="" align="left" valign="top"><p>1F</p></td><td style="" align="left" valign="top"><p>Insert</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Insert a new slot before the current slot and make the new slot the current one.</p></td></tr><tr><td style="" align="left" valign="top"><p>20</p></td><td style="" align="left" valign="top"><p>Delete</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Delete the current item in the input stream.</p></td></tr><tr><td style="" align="left" valign="top"><p>21</p></td><td style="" align="left" valign="top"><p>Assoc</p></td><td style="" align="left" valign="top"><p>{count}</p></td><td style="" align="left" valign="top"><p>&lt;slot-1&gt; …</p></td><td style="" align="left" valign="top"><p>&lt;slot-count&gt;</p></td><td style="" align="left" valign="top"><p>Set the associations for the current slot to be the given slot(s) in the input. The first argument indicates how many slots follow. The slot offsets are relative to the current input slot.</p></td></tr><tr><td style="" align="left" valign="top"><p>22</p></td><td style="" align="left" valign="top"><p>ContextItem</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p>{byte-count}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>If the slot currently being tested is not the slot specified by the &lt;offset&gt; argument (relative to the stream position, the first modified item in the rule), skip the given number of bytes of stack-machine code. These bytes represent a test that is irrelevant for this slot.</p></td></tr><tr><td style="" align="left" valign="top"><p>23</p></td><td style="" align="left" valign="top"><p>AttrSet</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the stack and set the value of the given attribute to the resulting numerical value.</p></td></tr><tr><td style="" align="left" valign="top"><p>24</p></td><td style="" align="left" valign="top"><p>AttrAdd</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the stack and adjust the value of the given attribute by adding the popped value.</p></td></tr><tr><td style="" align="left" valign="top"><p>25</p></td><td style="" align="left" valign="top"><p>AttrSub</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the stack and adjust the value of the given attribute by subtracting the popped value.</p></td></tr><tr><td style="" align="left" valign="top"><p>26</p></td><td style="" align="left" valign="top"><p>AttrSetSlot</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the stack and set the given attribute to the value, which is a reference to another slot, making an adjustment for the stream position. The value is relative to the current stream position. [Note that corresponding add and subtract operations are not needed since it never makes sense to add slot references.]</p></td></tr><tr><td style="" align="left" valign="top"><p>27</p></td><td style="" align="left" valign="top"><p>IAttrSetSlot</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p>{index}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the stack and set the given indexed attribute of the current slot to the value, which is a reference to another slot, making an adjustment for the stream position. The value is relative to the current stream position. [Currently the only indexed slot attributes are component.X.ref.]</p></td></tr><tr><td style="" align="left" valign="top"><p>28</p></td><td style="" align="left" valign="top"><p>PushSlotAttr</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Look up the value of the given slot attribute of the given slot and push the result on the stack. The slot offset is relative to the current input position.</p></td></tr><tr><td style="" align="left" valign="top"><p>29</p></td><td style="" align="left" valign="top"><p>PushGlyph-Attr</p></td><td style="" align="left" valign="top"><p>{glyphattr}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Look up the value of the given glyph attribute of the given slot and push the result on the stack. The slot offset is relative to the current input position.</p></td></tr><tr><td style="" align="left" valign="top"><p>2A</p></td><td style="" align="left" valign="top"><p>PushGlyph-Metric</p></td><td style="" align="left" valign="top"><p>{glyph-metric}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p>&lt;level&gt;</p></td><td style="" align="left" valign="top"><p>Look up the value of the given glyph metric of the given slot and push the result on the stack. The slot offset is relative to the current input position. The level indicates the attachment level for cluster metrics.</p></td></tr><tr><td style="" align="left" valign="top"><p>2B</p></td><td style="" align="left" valign="top"><p>PushFeat</p></td><td style="" align="left" valign="top"><p>{feat}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Push the value of the given feature for the current slot onto the stack.</p></td></tr><tr><td style="" align="left" valign="top"><p>2C</p></td><td style="" align="left" valign="top"><p>PushAttrTo-GlyphAttr</p></td><td style="" align="left" valign="top"><p>{glyphattr}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Look up the value of the given glyph attribute for the slot indicated by the given slot’s attach.to attribute. Push the result on the stack.</p></td></tr><tr><td style="" align="left" valign="top"><p>2D</p></td><td style="" align="left" valign="top"><p>PushAttTo-GlyphMetric</p></td><td style="" align="left" valign="top"><p>{glyph-metric}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p>&lt;level&gt;</p></td><td style="" align="left" valign="top"><p>Look up the value of the given glyph metric for the slot indicated by the given slot’s attach.to attribute. Push the result on the stack.</p></td></tr><tr><td style="" align="left" valign="top"><p>2E</p></td><td style="" align="left" valign="top"><p>PushISlotAttr</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p>&lt;index&gt;</p></td><td style="" align="left" valign="top"><p>Push the value of the indexed slot attribute onto the stack. [The current indexed slot attributes are component.X.ref and userX.]</p></td></tr><tr><td style="" align="left" valign="top"><p>2F</p></td><td style="" align="left" valign="top"><p>PushIGlyph-Attr</p></td><td style="" align="left" valign="top"><p>{glyphattr}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p>&lt;index&gt;</p></td><td style="" align="left" valign="top"><p>Not Implemented: Push the value of the indexed glyph attribute onto the stack. [Examples of indexed glyph attributes are component.X.box.top, component.X.box.bottom, etc.]</p></td></tr><tr><td style="" align="left" valign="top"><p>30</p></td><td style="" align="left" valign="top"><p>PopRet</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>No more processing is needed for this rule. Pop the top of the stack and return that value. For rule action code, the return value is the number of positions to move the stream position forward (or backward, if the number is negative) for the next rule. For constraint code, the return value is a boolean indicating whether the constraint succeeded.</p></td></tr><tr><td style="" align="left" valign="top"><p>31</p></td><td style="" align="left" valign="top"><p>RetZero</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Terminate the processing and return zero.</p></td></tr><tr><td style="" align="left" valign="top"><p>32</p></td><td style="" align="left" valign="top"><p>RetTrue</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Terminate the processing and return true (1).</p></td></tr><tr><td style="" align="left" valign="top"><p>33</p></td><td style="" align="left" valign="top"><p>IAttrSet</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p>{index}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the stack and set the value of the given indexed attribute to the resulting numerical value. Not to be used for attributes whose value is a slot reference. [Currently the only non-slot-reference indexed slot attributes are userX.]
Not supported in version 1.0 of the font tables.</p></td></tr><tr><td style="" align="left" valign="top"><p>34</p></td><td style="" align="left" valign="top"><p>IAttrAdd</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p>{index}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the stack and adjust the value of the given indexed slot attribute by adding the popped value. Not to be used for attributes whose value is a slot reference. [Currently the only non-slot-reference indexed slot attributes are userX.]
Not supported in version 1.0 of the font tables.</p></td></tr><tr><td style="" align="left" valign="top"><p>35</p></td><td style="" align="left" valign="top"><p>IAttrSub</p></td><td style="" align="left" valign="top"><p>{slotattr}</p></td><td style="" align="left" valign="top"><p>{index}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the stack and adjust the value of the given indexed slot attribute by subtracting the popped value. Not to be used for attributes whose value is a slot reference. [Currently the only non-slot-reference indexed slot attributes are userX.]</p></td></tr><tr><td style="" align="left" valign="top"><p>36</p></td><td style="" align="left" valign="top"><p>PushProcState</p></td><td style="" align="left" valign="top"><p>{byte}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Not Implemented: Pushes the processor state value identifier by the argument onto the stack.</p></td></tr><tr><td style="" align="left" valign="top"><p>37</p></td><td style="" align="left" valign="top"><p>PushVersion</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pushes the version of the engine onto the stack as a 32 bit number. The stack holds 32 bit values.</p></td></tr><tr><td style="" align="left" valign="top"><p>38</p></td><td style="" align="left" valign="top"><p>PutSubs</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p>{inclass-short}</p></td><td style="" align="left" valign="top"><p>{outclass-short}</p></td><td style="" align="left" valign="top"><p>Equivalent to PutSubs (0x1D) but with 16-bit class identifiers.</p></td></tr><tr><td style="" align="left" valign="top"><p>39</p></td><td style="" align="left" valign="top"><p>PutSubs2</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Not Implemented</p></td></tr><tr><td style="" align="left" valign="top"><p>3A</p></td><td style="" align="left" valign="top"><p>PutSubs3</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Not Implemented</p></td></tr><tr><td style="" align="left" valign="top"><p>3B</p></td><td style="" align="left" valign="top"><p>PutGlyph</p></td><td style="" align="left" valign="top"><p>{outclass-short}</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Equivalent to PutGlyph (0x1C) but with 16-bit class identifier.</p></td></tr><tr><td style="" align="left" valign="top"><p>3C</p></td><td style="" align="left" valign="top"><p>PushGlyph-Attr</p></td><td style="" align="left" valign="top"><p>{glyphattr-short}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Equivalent to PushGlyphAttr (0x29) but with 16-bit glyph attribute identifier.</p></td></tr><tr><td style="" align="left" valign="top"><p>3D</p></td><td style="" align="left" valign="top"><p>PushAttTo-GlyphAttr</p></td><td style="" align="left" valign="top"><p>{glyphattr-short}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Equivalent to PushAttToGlyphAttr (0x2C) but with 16-bit glyph attribute identifier.</p></td></tr><tr><td style="" align="left" valign="top"><p>3E</p></td><td style="" align="left" valign="top"><p>BitAnd</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack, perform a bitwise AND, and push the result.</p></td></tr><tr><td style="" align="left" valign="top"><p>3F</p></td><td style="" align="left" valign="top"><p>BitOr</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top two items off the stack, perform a bitwise OR, and push the result.</p></td></tr><tr><td style="" align="left" valign="top"><p>40</p></td><td style="" align="left" valign="top"><p>BitNot</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top item off the stack, perform a bitwise NOT, and push the result.</p></td></tr><tr><td style="" align="left" valign="top"><p>41</p></td><td style="" align="left" valign="top"><p>SetBits</p></td><td style="" align="left" valign="top"><p>&lt;mask-short&gt;</p></td><td style="" align="left" valign="top"><p>&lt;value-short&gt;</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop the top item off the stack, clear the mask bits, set the value bits, and push the result.</p></td></tr><tr><td style="" align="left" valign="top"><p>42</p></td><td style="" align="left" valign="top"><p>SetFeat</p></td><td style="" align="left" valign="top"><p>{feat}</p></td><td style="" align="left" valign="top"><p>&lt;offset&gt;</p></td><td style="" align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p>Pop a value off the stack and set the given feature on referenced slot to that value. The value is clipped at the maximum permissible value for that feature.</p></td></tr></tbody></table></div></div></div></div></body></html>