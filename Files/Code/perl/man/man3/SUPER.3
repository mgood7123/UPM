.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SUPER 3"
.TH SUPER 3 "2017-10-02" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SUPER \- control superclass method dispatch
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Find the parent method that would run if this weren't here:
.PP
.Vb 4
\&    sub my_method
\&    {
\&        my $self = shift;
\&        my $super = $self\->super(\*(Aqmy_method\*(Aq); # Who\*(Aqs your daddy?
\&
\&        if ($want_to_deal_with_this)
\&        {
\&            # ...
\&        }
\&        else
\&        {
\&            $super\->($self, @_)
\&        }
\&    }
.Ve
.PP
Or Ruby-style:
.PP
.Vb 3
\&    sub my_method
\&    {
\&        my $self = shift;
\&
\&        if ($want_to_deal_with_this)
\&        {
\&            # ...
\&        }
\&        else
\&        {
\&            super;
\&        }
\&    }
.Ve
.PP
Or call the super method manually, with respect to inheritance, and passing
different arguments:
.PP
.Vb 3
\&    sub my_method
\&    {
\&        my $self = shift;
\&
\&        # parent handles args backwardly
\&        $self\->SUPER( reverse @_ );
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When subclassing a class, you occasionally want to dispatch control to the
superclass \*(-- at least conditionally and temporarily. The Perl syntax for
calling your superclass is ugly and unwieldy:
.PP
.Vb 1
\&    $self\->SUPER::method(@_);
.Ve
.PP
especially when compared to its Ruby equivalent:
.PP
.Vb 1
\&    super;
.Ve
.PP
It's even worse in that the normal Perl redispatch mechanism only dispatches to
the parent of the class containing the method \fIat compile time\fR.  That doesn't work very well for mixins and roles.
.PP
This module provides nicer equivalents, along with the universal method
\&\f(CW\*(C`super\*(C'\fR to determine a class' own superclass. This allows you to do things
such as:
.PP
.Vb 1
\&    goto &{$_[0]\->super(\*(Aqmy_method\*(Aq)};
.Ve
.PP
if you don't like wasting precious stack frames.
.PP
If you are using roles or mixins or otherwise pulling in methods from other
packages that need to dispatch to their super methods, or if you want to pass
different arguments to the super method, use the \f(CW\*(C`SUPER()\*(C'\fR method:
.PP
.Vb 1
\&    $self\->SUPER( qw( other arguments here ) );
.Ve
.SH "FUNCTIONS and METHODS"
.IX Header "FUNCTIONS and METHODS"
This module provides the following functions and methods:
.ie n .IP """super()""" 4
.el .IP "\f(CWsuper()\fR" 4
.IX Item "super()"
This function calls the super method of the currently-executing method, no
matter where the super method is in the hierarchy.
.Sp
This takes no arguments; it passes the same arguments passed to the
currently-executing method.
.Sp
The module exports this function by default.
.Sp
\&\fINote\fR: you \fImust\fR have the appropriate \f(CW\*(C`package\*(C'\fR declaration in place for
this to work.  That is, you must have \fIcompiled\fR the method in which you use
this function in the package from which you want to use it.  Them's the breaks
with Perl 5.
.ie n .IP """find_parent( $class, $method, $prune, $invocant )""" 4
.el .IP "\f(CWfind_parent( $class, $method, $prune, $invocant )\fR" 4
.IX Item "find_parent( $class, $method, $prune, $invocant )"
Attempts to find a parent implementation of \f(CW$method\fR starting with \f(CW$class\fR.
If you pass \f(CW$prune\fR, it will not ignore the method found in that package, if
it exists there.  Pass \f(CW$invocant\fR if the object itself might have a different
idea of its parents.
.Sp
The module does not export this function by default.  Call it directly.
.ie n .IP """get_all_parents( $invocant, $class )""" 4
.el .IP "\f(CWget_all_parents( $invocant, $class )\fR" 4
.IX Item "get_all_parents( $invocant, $class )"
Returns all of the parents for the \f(CW$invocant\fR, if it supports the
\&\f(CW\*(C`_\|_get_parents()\*(C'\fR method or the contents of \f(CW@ISA\fR for \f(CW$class\fR.  You
probably oughtn't call this on your own.
.ie n .IP """SUPER()""" 4
.el .IP "\f(CWSUPER()\fR" 4
.IX Item "SUPER()"
Calls the super method of the currently-executing method.  You \fIcan\fR pass
arguments.  This is a method.
.SH "NOTES"
.IX Header "NOTES"
\&\fIBeware:\fR if you do weird things with code generation, be sure to \fIname\fR your
anonymous subroutines.  See \fIPerl Hacks\fR #57.
.PP
Using \f(CW\*(C`super\*(C'\fR doesn't let you pass alternate arguments to your superclass's
method. If you want to pass different arguments, use \f(CW\*(C`SUPER\*(C'\fR instead.  D'oh.
.PP
This module does a small amount of Deep Magic to find the arguments of method
\&\fIcalling\fR \f(CW\*(C`super()\*(C'\fR itself.  This may confuse tools such as \f(CW\*(C`Devel::Cover\*(C'\fR.
.PP
In your own code, if you do complicated things with proxy objects and the like,
define \f(CW\*(C`_\|_get_parents()\*(C'\fR to return a list of all parents of the object to
which you really want to dispatch.
.SH "AUTHOR"
.IX Header "AUTHOR"
Created by Simon Cozens, \f(CW\*(C`simon@cpan.org\*(C'\fR.  Copyright (c) 2003 Simon Cozens.
.PP
Maintained by chromatic, <chromatic at wgz dot org> after version 1.01.
Copyright (c) 2004\-2014 chromatic.
.PP
Thanks to Joshua ben Jore for bug reports and suggestions.
.SH "LICENSE"
.IX Header "LICENSE"
You may use and distribute this silly little module under the same terms as
Perl itself.
