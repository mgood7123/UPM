.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Net::DNS::Resolver 3"
.TH Net::DNS::Resolver 3 "2017-08-18" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS::Resolver \- DNS resolver class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::DNS;
\&
\&    $resolver = new Net::DNS::Resolver();
\&
\&    # Perform a lookup, using the searchlist if appropriate.
\&    $reply = $resolver\->search( \*(Aqexample.com\*(Aq );
\&
\&    # Perform a lookup, without the searchlist
\&    $reply = $resolver\->query( \*(Aqexample.com\*(Aq, \*(AqMX\*(Aq );
\&
\&    # Perform a lookup, without pre or post\-processing
\&    $reply = $resolver\->send( \*(Aqexample.com\*(Aq, \*(AqMX\*(Aq, \*(AqIN\*(Aq );
\&
\&    # Send a prebuilt query packet
\&    $query = new Net::DNS::Packet( ... );
\&    $reply = $resolver\->send( $packet );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Instances of the Net::DNS::Resolver class represent resolver objects.
A program can have multiple resolver objects, each maintaining its
own state information such as the nameservers to be queried, whether
recursion is desired, etc.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 2
\&    # Use the default configuration
\&    $resolver = new Net::DNS::Resolver();
\&
\&    # Use my own configuration file
\&    $resolver = new Net::DNS::Resolver( config_file => \*(Aq/my/dns.conf\*(Aq );
\&
\&    # Set options in the constructor
\&    $resolver = new Net::DNS::Resolver(
\&        nameservers => [ \*(Aq10.1.1.128\*(Aq, \*(Aq10.1.2.128\*(Aq ],
\&        recurse     => 0,
\&        debug       => 1
\&        );
.Ve
.PP
Returns a resolver object.  If no arguments are supplied, \f(CW\*(C`new()\*(C'\fR
returns an object having the default configuration.
.PP
On Unix and Linux systems,
the default values are read from the following files,
in the order indicated:
.Sp
.RS 4
\&\fI/etc/resolv.conf\fR,
\&\fI\f(CI$HOME\fI/.resolv.conf\fR,
\&\fI./.resolv.conf\fR
.RE
.PP
The following keywords are recognised in resolver configuration files:
.Sp
.RS 4
\&\fBnameserver\fR address
.Sp
\&\s-1IP\s0 address of a name server that the resolver should query.
.Sp
\&\fBdomain\fR localdomain
.Sp
The domain suffix to be appended to a short non-absolute name.
.Sp
\&\fBsearch\fR domain ...
.Sp
A space-separated list of domains in the desired search path.
.Sp
\&\fBoptions\fR option:value ...
.Sp
A space-separated list of key:value items.
.RE
.PP
Except for \fI/etc/resolv.conf\fR, files will only be read if owned by the
effective userid running the program.  In addition, several environment
variables may contain configuration information; see \*(L"\s-1ENVIRONMENT\*(R"\s0.
.PP
Note that the domain and searchlist keywords are mutually exclusive.
If both are present, the resulting behaviour is unspecified.
If neither is present, the domain is determined from the local hostname.
.PP
On Windows systems, an attempt is made to determine the system defaults
using the registry.  Systems with many dynamically configured network
interfaces may confuse Net::DNS.
.PP
.Vb 2
\&    # Use my own configuration file
\&    $resolver = new Net::DNS::Resolver( config_file => \*(Aq/my/dns.conf\*(Aq );
.Ve
.PP
You can include a configuration file of your own when creating a
resolver object.  This is supported on both Unix and Windows.
.PP
If a custom configuration file is specified at first instantiation,
all other configuration files and environment variables are ignored.
.PP
.Vb 5
\&    # Set options in the constructor
\&    $resolver = new Net::DNS::Resolver(
\&        nameservers => [ \*(Aq10.1.1.128\*(Aq, \*(Aq10.1.2.128\*(Aq ],
\&        recurse     => 0
\&        );
.Ve
.PP
Explicit arguments to \f(CW\*(C`new()\*(C'\fR override the corresponding configuration
variables.  The argument list consists of a sequence of (name=>value)
pairs, each interpreted as an invocation of the corresponding method.
.SS "print"
.IX Subsection "print"
.Vb 1
\&    $resolver\->print;
.Ve
.PP
Prints the resolver state on the standard output.
.SS "query"
.IX Subsection "query"
.Vb 5
\&    $packet = $resolver\->query( \*(Aqmailhost\*(Aq );
\&    $packet = $resolver\->query( \*(Aqmailhost.example.com\*(Aq );
\&    $packet = $resolver\->query( \*(Aq192.0.2.1\*(Aq );
\&    $packet = $resolver\->query( \*(Aqexample.com\*(Aq, \*(AqMX\*(Aq );
\&    $packet = $resolver\->query( \*(Aqannotation.example.com\*(Aq, \*(AqTXT\*(Aq, \*(AqIN\*(Aq );
.Ve
.PP
Performs a \s-1DNS\s0 query for the given name; the search list is not applied.
If \f(CW\*(C`defnames\*(C'\fR is true, and the number of dots is less than \f(CW\*(C`ndots\*(C'\fR,
the default domain will be appended unless name is absolute.
.PP
The record type and class can be omitted; they default to A and \s-1IN.\s0
If the name looks like an \s-1IP\s0 address (IPv4 or IPv6),
then a query within in\-addr.arpa or ip6.arpa will be performed.
.PP
Returns a Net::DNS::Packet object, or \f(CW\*(C`undef\*(C'\fR if no answers were found.
The reason for failure may be determined using \f(CW\*(C`errorstring()\*(C'\fR.
.PP
If you need to examine the response packet, whether it contains
any answers or not, use the \f(CW\*(C`send()\*(C'\fR method instead.
.SS "search"
.IX Subsection "search"
.Vb 5
\&    $packet = $resolver\->search( \*(Aqmailhost\*(Aq );
\&    $packet = $resolver\->search( \*(Aqmailhost.example.com\*(Aq );
\&    $packet = $resolver\->search( \*(Aq192.0.2.1\*(Aq );
\&    $packet = $resolver\->search( \*(Aqexample.com\*(Aq, \*(AqMX\*(Aq );
\&    $packet = $resolver\->search( \*(Aqannotation.example.com\*(Aq, \*(AqTXT\*(Aq, \*(AqIN\*(Aq );
.Ve
.PP
Performs a \s-1DNS\s0 query for the given name, applying the searchlist if
appropriate.  The search algorithm is as follows:
.PP
Unless the number of dots is less than \f(CW\*(C`ndots\*(C'\fR,
perform an initial query using the unmodified name.
.PP
If \f(CW\*(C`dnsrch\*(C'\fR is true and the name has no terminal dot,
try appending each suffix in the search list.
.PP
The record type and class can be omitted; they default to A and \s-1IN.\s0
If the name looks like an \s-1IP\s0 address (IPv4 or IPv6),
then a query within in\-addr.arpa or ip6.arpa will be performed.
.PP
Returns a Net::DNS::Packet object, or \f(CW\*(C`undef\*(C'\fR if no answers were found.
The reason for failure may be determined using \f(CW\*(C`errorstring()\*(C'\fR.
.PP
If you need to examine the response packet, whether it contains
any answers or not, use the \f(CW\*(C`send()\*(C'\fR method instead.
.SS "send"
.IX Subsection "send"
.Vb 1
\&    $packet = $resolver\->send( $packet );
\&
\&    $packet = $resolver\->send( \*(Aqmailhost.example.com\*(Aq );
\&    $packet = $resolver\->query( \*(Aq192.0.2.1\*(Aq );
\&    $packet = $resolver\->send( \*(Aqexample.com\*(Aq, \*(AqMX\*(Aq );
\&    $packet = $resolver\->send( \*(Aqannotation.example.com\*(Aq, \*(AqTXT\*(Aq, \*(AqIN\*(Aq );
.Ve
.PP
Performs a \s-1DNS\s0 query for the given name.  Neither the searchlist
nor the default domain will be appended.
.PP
The argument list can be either a Net::DNS::Packet object or a list
of strings.  The record type and class can be omitted; they default to
A and \s-1IN.\s0  If the name looks like an \s-1IP\s0 address (IPv4 or IPv6),
then a query within in\-addr.arpa or ip6.arpa will be performed.
.PP
Returns a Net::DNS::Packet object whether there were any answers or not.
Use \f(CW\*(C`$packet\->header\->ancount\*(C'\fR or \f(CW\*(C`$packet\->answer\*(C'\fR to find out
if there were any records in the answer section.
Returns \f(CW\*(C`undef\*(C'\fR if no response was received.
.SS "axfr"
.IX Subsection "axfr"
.Vb 3
\&    @zone = $resolver\->axfr();
\&    @zone = $resolver\->axfr( \*(Aqexample.com\*(Aq );
\&    @zone = $resolver\->axfr( \*(Aqexample.com\*(Aq, \*(AqIN\*(Aq );
\&
\&    $iterator = $resolver\->axfr();
\&    $iterator = $resolver\->axfr( \*(Aqexample.com\*(Aq );
\&    $iterator = $resolver\->axfr( \*(Aqexample.com\*(Aq, \*(AqIN\*(Aq );
\&
\&    $rr = $iterator\->();
.Ve
.PP
Performs a zone transfer using the resolver nameservers list,
attempted in the order listed.
.PP
If the zone is omitted, it defaults to the first zone listed
in the resolver search list.
.PP
If the class is omitted, it defaults to \s-1IN.\s0
.PP
When called in list context, \f(CW\*(C`axfr()\*(C'\fR returns a list of Net::DNS::RR
objects.  The redundant \s-1SOA\s0 record that terminates the zone transfer
is not returned to the caller.
.PP
In deferrence to \s-1RFC1035\s0(6.3), a complete zone transfer is expected
to return all records in the zone or nothing at all.
When no resource records are returned by \f(CW\*(C`axfr()\*(C'\fR,
the reason for failure may be determined using \f(CW\*(C`errorstring()\*(C'\fR.
.PP
Here is an example that uses a timeout and \s-1TSIG\s0 verification:
.PP
.Vb 3
\&    $resolver\->tcp_timeout( 10 );
\&    $resolver\->tsig( \*(AqKhmac\-sha1.example.+161+24053.private\*(Aq );
\&    @zone = $resolver\->axfr( \*(Aqexample.com\*(Aq );
\&
\&    foreach $rr (@zone) {
\&        $rr\->print;
\&    }
.Ve
.PP
When called in scalar context, \f(CW\*(C`axfr()\*(C'\fR returns an iterator object.
Each invocation of the iterator returns a single Net::DNS::RR
or \f(CW\*(C`undef\*(C'\fR when the zone is exhausted.
.PP
An exception is raised if the zone transfer can not be completed.
.PP
The redundant \s-1SOA\s0 record that terminates the zone transfer is not
returned to the caller.
.PP
Here is the example above, implemented using an iterator:
.PP
.Vb 3
\&    $resolver\->tcp_timeout( 10 );
\&    $resolver\->tsig( \*(AqKhmac\-sha1.example.+161+24053.private\*(Aq );
\&    $iterator = $resolver\->axfr( \*(Aqexample.com\*(Aq );
\&
\&    while ( $rr = $iterator\->() ) {
\&        $rr\->print;
\&    }
.Ve
.SS "bgsend"
.IX Subsection "bgsend"
.Vb 1
\&    $handle = $resolver\->bgsend( $packet ) || die $resolver\->errorstring;
\&
\&    $handle = $resolver\->bgsend( \*(Aqmailhost.example.com\*(Aq );
\&    $handle = $resolver\->bgsend( \*(Aq192.0.2.1\*(Aq );
\&    $handle = $resolver\->bgsend( \*(Aqexample.com\*(Aq, \*(AqMX\*(Aq );
\&    $handle = $resolver\->bgsend( \*(Aqannotation.example.com\*(Aq, \*(AqTXT\*(Aq, \*(AqIN\*(Aq );
.Ve
.PP
Performs a background \s-1DNS\s0 query for the given name and returns immediately
without waiting for the response. The program can then perform other tasks
while awaiting the response from the nameserver.
.PP
The argument list can be either a Net::DNS::Packet object or a list
of strings.  The record type and class can be omitted; they default to
A and \s-1IN.\s0  If the name looks like an \s-1IP\s0 address (IPv4 or IPv6),
then a query within in\-addr.arpa or ip6.arpa will be performed.
.PP
Returns an opaque handle which is passed to subsequent invocations of
the \f(CW\*(C`bgbusy()\*(C'\fR and \f(CW\*(C`bgread()\*(C'\fR methods.
Errors are indicated by returning \f(CW\*(C`undef\*(C'\fR in which case
the reason for failure may be determined using \f(CW\*(C`errorstring()\*(C'\fR.
.PP
The response Net::DNS::Packet object is obtained by calling \f(CW\*(C`bgread()\*(C'\fR.
.PP
\&\fB\s-1BEWARE\s0\fR:
Programs should make no assumptions about the nature of the handles
returned by \f(CW\*(C`bgsend()\*(C'\fR which should be used strictly as described here.
.SS "bgread"
.IX Subsection "bgread"
.Vb 2
\&    $handle = $resolver\->bgsend( \*(Aqwww.example.com\*(Aq );
\&    $packet = $resolver\->bgread($handle);
.Ve
.PP
Reads the answer from a background query.
The argument is the handle returned by \f(CW\*(C`bgsend()\*(C'\fR.
.PP
Returns a Net::DNS::Packet object or \f(CW\*(C`undef\*(C'\fR if no response was
received before the timeout interval expired.
.SS "bgbusy"
.IX Subsection "bgbusy"
.Vb 1
\&    $handle = $resolver\->bgsend( \*(Aqfoo.example.com\*(Aq );
\&
\&    while ($resolver\->bgbusy($handle)) {
\&        ...
\&    }
\&
\&    $packet = $resolver\->bgread($handle);
.Ve
.PP
Returns true while awaiting the response or for the transaction to time out.
The argument is the handle returned by \f(CW\*(C`bgsend()\*(C'\fR.
.PP
Truncated \s-1UDP\s0 packets will be retried over \s-1TCP\s0 transparently while
continuing to assert busy to the caller.
.SS "bgisready"
.IX Subsection "bgisready"
.Vb 3
\&    until ($resolver\->bgisready($handle)) {
\&        ...
\&    }
.Ve
.PP
\&\f(CW\*(C`bgisready()\*(C'\fR is the logical complement of \f(CW\*(C`bgbusy()\*(C'\fR which is retained
for backward compatibility.
.SS "debug"
.IX Subsection "debug"
.Vb 2
\&    print \*(Aqdebug flag: \*(Aq, $resolver\->debug, "\en";
\&    $resolver\->debug(1);
.Ve
.PP
Get or set the debug flag.
If set, calls to \f(CW\*(C`search()\*(C'\fR, \f(CW\*(C`query()\*(C'\fR, and \f(CW\*(C`send()\*(C'\fR will print
debugging information on the standard output.
The default is false.
.SS "defnames"
.IX Subsection "defnames"
.Vb 2
\&    print \*(Aqdefnames flag: \*(Aq, $resolver\->defnames, "\en";
\&    $resolver\->defnames(0);
.Ve
.PP
Get or set the defnames flag.
If true, calls to \f(CW\*(C`query()\*(C'\fR will append the default domain to
resolve names that are not fully qualified.
The default is true.
.SS "dnsrch"
.IX Subsection "dnsrch"
.Vb 2
\&    print \*(Aqdnsrch flag: \*(Aq, $resolver\->dnsrch, "\en";
\&    $resolver\->dnsrch(0);
.Ve
.PP
Get or set the dnsrch flag.
If true, calls to \f(CW\*(C`search()\*(C'\fR will apply the search list to resolve
names that are not fully qualified.
The default is true.
.SS "domain"
.IX Subsection "domain"
.Vb 2
\&    $domain = $resolver\->domain;
\&    $resolver\->domain( \*(Aqdomain.example\*(Aq );
.Ve
.PP
Gets or sets the resolver default domain.
.SS "igntc"
.IX Subsection "igntc"
.Vb 2
\&    print \*(Aqigntc flag: \*(Aq, $resolver\->igntc, "\en";
\&    $resolver\->igntc(1);
.Ve
.PP
Get or set the igntc flag.
If true, truncated packets will be ignored.
If false, the query will be retried using \s-1TCP.\s0
The default is false.
.SS "nameserver, nameservers"
.IX Subsection "nameserver, nameservers"
.Vb 2
\&    @nameservers = $resolver\->nameservers();
\&    $resolver\->nameservers( \*(Aq192.0.2.1\*(Aq, \*(Aq192.0.2.2\*(Aq, \*(Aq2001:DB8::3\*(Aq );
.Ve
.PP
Gets or sets the nameservers to be queried.
.PP
Also see the IPv6 transport notes below
.SS "persistent_tcp"
.IX Subsection "persistent_tcp"
.Vb 2
\&    print \*(AqPersistent TCP flag: \*(Aq, $resolver\->persistent_tcp, "\en";
\&    $resolver\->persistent_tcp(1);
.Ve
.PP
Get or set the persistent \s-1TCP\s0 setting.
If true, Net::DNS will keep a \s-1TCP\s0 socket open for each host:port
to which it connects.
This is useful if you are using \s-1TCP\s0 and need to make a lot of queries
or updates to the same nameserver.
.PP
The default is false unless you are running a SOCKSified Perl,
in which case the default is true.
.SS "persistent_udp"
.IX Subsection "persistent_udp"
.Vb 2
\&    print \*(AqPersistent UDP flag: \*(Aq, $resolver\->persistent_udp, "\en";
\&    $resolver\->persistent_udp(1);
.Ve
.PP
Get or set the persistent \s-1UDP\s0 setting.
If true, a Net::DNS resolver will use the same \s-1UDP\s0 socket
for all queries within each address family.
.PP
This avoids the cost of creating and tearing down \s-1UDP\s0 sockets,
but also defeats source port randomisation.
.SS "port"
.IX Subsection "port"
.Vb 2
\&    print \*(Aqsending queries to port \*(Aq, $resolver\->port, "\en";
\&    $resolver\->port(9732);
.Ve
.PP
Gets or sets the port to which queries are sent.
Convenient for nameserver testing using a non-standard port.
The default is port 53.
.SS "recurse"
.IX Subsection "recurse"
.Vb 2
\&    print \*(Aqrecursion flag: \*(Aq, $resolver\->recurse, "\en";
\&    $resolver\->recurse(0);
.Ve
.PP
Get or set the recursion flag.
If true, this will direct nameservers to perform a recursive query.
The default is true.
.SS "retrans"
.IX Subsection "retrans"
.Vb 2
\&    print \*(Aqretrans interval: \*(Aq, $resolver\->retrans, "\en";
\&    $resolver\->retrans(3);
.Ve
.PP
Get or set the retransmission interval
The default is 5 seconds.
.SS "retry"
.IX Subsection "retry"
.Vb 2
\&    print \*(Aqnumber of tries: \*(Aq, $resolver\->retry, "\en";
\&    $resolver\->retry(2);
.Ve
.PP
Get or set the number of times to try the query.
The default is 4.
.SS "searchlist"
.IX Subsection "searchlist"
.Vb 2
\&    @searchlist = $resolver\->searchlist;
\&    $resolver\->searchlist( \*(Aqa.example\*(Aq, \*(Aqb.example\*(Aq, \*(Aqc.example\*(Aq );
.Ve
.PP
Gets or sets the resolver search list.
.SS "srcaddr"
.IX Subsection "srcaddr"
.Vb 1
\&    $resolver\->srcaddr(\*(Aq192.0.2.1\*(Aq);
.Ve
.PP
Sets the source address from which queries are sent.
Convenient for forcing queries from a specific interface on a
multi-homed host.  The default is to use any local address.
.SS "srcport"
.IX Subsection "srcport"
.Vb 1
\&    $resolver\->srcport(5353);
.Ve
.PP
Sets the port from which queries are sent.
The default is 0, meaning any port.
.SS "tcp_timeout"
.IX Subsection "tcp_timeout"
.Vb 2
\&    print \*(AqTCP timeout: \*(Aq, $resolver\->tcp_timeout, "\en";
\&    $resolver\->tcp_timeout(10);
.Ve
.PP
Get or set the \s-1TCP\s0 timeout in seconds.
The default is 120 seconds (2 minutes).
.SS "udp_timeout"
.IX Subsection "udp_timeout"
.Vb 2
\&    print \*(AqUDP timeout: \*(Aq, $resolver\->udp_timeout, "\en";
\&    $resolver\->udp_timeout(10);
.Ve
.PP
Get or set the \fIbgsend()\fR \s-1UDP\s0 timeout in seconds.
The default is 30 seconds.
.SS "udppacketsize"
.IX Subsection "udppacketsize"
.Vb 2
\&    print "udppacketsize: ", $resolver\->udppacketsize, "\en";
\&    $resolver\->udppacketsize(2048);
.Ve
.PP
Get or set the \s-1UDP\s0 packet size.
If set to a value not less than the default \s-1DNS\s0 packet size,
an \s-1EDNS\s0 extension will be added indicating support for
large \s-1UDP\s0 datagram.
.SS "usevc"
.IX Subsection "usevc"
.Vb 2
\&    print \*(Aqusevc flag: \*(Aq, $resolver\->usevc, "\en";
\&    $resolver\->usevc(1);
.Ve
.PP
Get or set the usevc flag.
If true, queries will be performed using virtual circuits (\s-1TCP\s0)
instead of datagrams (\s-1UDP\s0).
The default is false.
.SS "answerfrom"
.IX Subsection "answerfrom"
.Vb 1
\&    print \*(Aqlast answer was from: \*(Aq, $resolver\->answerfrom, "\en";
.Ve
.PP
Returns the \s-1IP\s0 address from which the most recent packet was
received in response to a query.
.SS "errorstring"
.IX Subsection "errorstring"
.Vb 1
\&    print \*(Aqquery status: \*(Aq, $resolver\->errorstring, "\en";
.Ve
.PP
Returns a string containing error information from the most recent method call.
\&\f(CW\*(C`errorstring()\*(C'\fR is meaningful only when interrogated immediately after an error.
.SS "dnssec"
.IX Subsection "dnssec"
.Vb 2
\&    print "dnssec flag: ", $resolver\->dnssec, "\en";
\&    $resolver\->dnssec(0);
.Ve
.PP
The dnssec flag causes the resolver to transmit \s-1DNSSEC\s0 queries
and to add a \s-1EDNS0\s0 record as required by \s-1RFC2671\s0 and \s-1RFC3225.\s0
The actions of, and response from, the remote nameserver is
determined by the settings of the \s-1AD\s0 and \s-1CD\s0 flags.
.PP
Calling the \f(CW\*(C`dnssec()\*(C'\fR method with a non-zero value will also set the
\&\s-1UDP\s0 packet size to the default value of 2048. If that is too small or
too big for your environment, you should call the \f(CW\*(C`udppacketsize()\*(C'\fR
method immediately after.
.PP
.Vb 2
\&   $resolver\->dnssec(1);                # DNSSEC using default packetsize
\&   $resolver\->udppacketsize(1250);      # lower the UDP packet size
.Ve
.PP
A fatal exception will be raised if the \f(CW\*(C`dnssec()\*(C'\fR method is called
but the Net::DNS::SEC library has not been installed.
.SS "adflag"
.IX Subsection "adflag"
.Vb 3
\&    $resolver\->dnssec(1);
\&    $resolver\->adflag(1);
\&    print "authentication desired flag: ", $resolver\->adflag, "\en";
.Ve
.PP
Gets or sets the \s-1AD\s0 bit for dnssec queries.  This bit indicates that
the caller is interested in the returned \s-1AD\s0 (authentic data) bit but
does not require any dnssec RRs to be included in the response.
The default value is false.
.SS "cdflag"
.IX Subsection "cdflag"
.Vb 3
\&    $resolver\->dnssec(1);
\&    $resolver\->cdflag(1);
\&    print "checking disabled flag: ", $resolver\->cdflag, "\en";
.Ve
.PP
Gets or sets the \s-1CD\s0 bit for dnssec queries.  This bit indicates that
authentication by upstream nameservers should be suppressed.
Any dnssec RRs required to execute the authentication procedure
should be included in the response.
The default value is false.
.SS "tsig"
.IX Subsection "tsig"
.Vb 1
\&    $resolver\->tsig( $tsig );
\&
\&    $resolver\->tsig( \*(AqKhmac\-sha1.example.+161+24053.private\*(Aq );
\&
\&    $resolver\->tsig( \*(AqKhmac\-sha1.example.+161+24053.key\*(Aq );
\&
\&    $resolver\->tsig( \*(AqKhmac\-sha1.example.+161+24053.key\*(Aq,
\&                fudge => 60
\&                );
\&
\&    $resolver\->tsig( $key_name, $key );
\&
\&    $resolver\->tsig( undef );
.Ve
.PP
Set the \s-1TSIG\s0 record used to automatically sign outgoing queries, zone
transfers and updates. Automatic signing is disabled if called with
undefined arguments.
.PP
The default resolver behaviour is not to sign any packets.  You must
call this method to set the key if you would like the resolver to
sign and verify packets automatically.
.PP
Packets can also be signed manually; see the Net::DNS::Packet
and Net::DNS::Update manual pages for examples.  \s-1TSIG\s0 records
in manually-signed packets take precedence over those that the
resolver would add automatically.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The following environment variables can also be used to configure
the resolver:
.SS "\s-1RES_NAMESERVERS\s0"
.IX Subsection "RES_NAMESERVERS"
.Vb 3
\&    # Bourne Shell
\&    RES_NAMESERVERS="192.0.2.1 192.0.2.2 2001:DB8::3"
\&    export RES_NAMESERVERS
\&
\&    # C Shell
\&    setenv RES_NAMESERVERS "192.0.2.1 192.0.2.2 2001:DB8::3"
.Ve
.PP
A space-separated list of nameservers to query.
.SS "\s-1RES_SEARCHLIST\s0"
.IX Subsection "RES_SEARCHLIST"
.Vb 3
\&    # Bourne Shell
\&    RES_SEARCHLIST="a.example.com b.example.com c.example.com"
\&    export RES_SEARCHLIST
\&
\&    # C Shell
\&    setenv RES_SEARCHLIST "a.example.com b.example.com c.example.com"
.Ve
.PP
A space-separated list of domains to put in the search list.
.SS "\s-1LOCALDOMAIN\s0"
.IX Subsection "LOCALDOMAIN"
.Vb 3
\&    # Bourne Shell
\&    LOCALDOMAIN=example.com
\&    export LOCALDOMAIN
\&
\&    # C Shell
\&    setenv LOCALDOMAIN example.com
.Ve
.PP
The default domain.
.SS "\s-1RES_OPTIONS\s0"
.IX Subsection "RES_OPTIONS"
.Vb 3
\&    # Bourne Shell
\&    RES_OPTIONS="retrans:3 retry:2 inet6"
\&    export RES_OPTIONS
\&
\&    # C Shell
\&    setenv RES_OPTIONS "retrans:3 retry:2 inet6"
.Ve
.PP
A space-separated list of resolver options to set.  Options that
take values are specified as \f(CW\*(C`option:value\*(C'\fR.
.SH "IPv6 TRANSPORT"
.IX Header "IPv6 TRANSPORT"
The Net::DNS::Resolver library will enable IPv6 transport if the
appropriate library (IO::Socket::IP or IO::Socket::INET6) is
available and the destination nameserver has an IPv6 address.
.PP
The \f(CW\*(C`force_v4()\*(C'\fR, \f(CW\*(C`force_v6()\*(C'\fR, \f(CW\*(C`prefer_v4()\*(C'\fR, and \f(CW\*(C`prefer_v6()\*(C'\fR methods
with non-zero argument may be used to configure transport selection.
.PP
The behaviour of the \f(CW\*(C`nameserver()\*(C'\fR method illustrates the transport
selection mechanism.  If, for example, IPv6 is not available or IPv4
transport has been forced, the \f(CW\*(C`nameserver()\*(C'\fR method will only return
IPv4 addresses:
.PP
.Vb 3
\&    $resolver\->nameservers( \*(Aq192.0.2.1\*(Aq, \*(Aq192.0.2.2\*(Aq, \*(Aq2001:DB8::3\*(Aq );
\&    $resolver\->force_v4(1);
\&    print join \*(Aq \*(Aq, $resolver\->nameservers();
.Ve
.PP
will print
.PP
.Vb 1
\&    192.0.2.1 192.0.2.2
.Ve
.SH "CUSTOMISED RESOLVERS"
.IX Header "CUSTOMISED RESOLVERS"
Net::DNS::Resolver is actually an empty subclass.  At compile time a
super class is chosen based on the current platform.  A side benefit of
this allows for easy modification of the methods in Net::DNS::Resolver.
You can simply add a method to the namespace!
.PP
For example, if we wanted to cache lookups:
.PP
.Vb 1
\&    package Net::DNS::Resolver;
\&
\&    my %cache;
\&
\&    sub search {
\&        $self = shift;
\&
\&        $cache{"@_"} ||= $self\->SUPER::search(@_);
\&    }
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c)1997\-2000 Michael Fuhr.
.PP
Portions Copyright (c)2002\-2004 Chris Reinhardt.
.PP
Portions Copyright (c)2005 Olaf M. Kolkman, NLnet Labs.
.PP
Portions Copyright (c)2014,2015 Dick Franks.
.PP
All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation, and that the name of the author not be used in advertising
or publicity pertaining to distribution of the software without specific
prior written permission.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::DNS, Net::DNS::Packet, Net::DNS::Update,
Net::DNS::Header, Net::DNS::Question, Net::DNS::RR,
\&\fIresolver\fR\|(5), \s-1RFC 1034, RFC 1035\s0
