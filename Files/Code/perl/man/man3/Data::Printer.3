.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Data::Printer 3"
.TH Data::Printer 3 "2017-08-02" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Printer \- colored pretty\-print of Perl data structures and objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Want to see what's inside a variable in a complete, colored
and human-friendly way?
.PP
.Vb 1
\&  use Data::Printer;   # or just "use DDP" for short
\&
\&  p @array;            # no need to pass references
.Ve
.PP
Code above might output something like this (with colors!):
.PP
.Vb 6
\&   [
\&       [0] "a",
\&       [1] "b",
\&       [2] undef,
\&       [3] "c",
\&   ]
.Ve
.PP
You can also inspect objects:
.PP
.Vb 1
\&    my $obj = SomeClass\->new;
\&
\&    p($obj);
.Ve
.PP
Which might give you something like:
.PP
.Vb 9
\&  \e SomeClass  {
\&      Parents       Moose::Object
\&      Linear @ISA   SomeClass, Moose::Object
\&      public methods (3) : bar, foo, meta
\&      private methods (0)
\&      internals: {
\&         _something => 42,
\&      }
\&  }
.Ve
.PP
Data::Printer is fully customizable. If you want to change how things
are displayed, or even its standard behavior. Take a look at the
available customizations. Once you figure out
your own preferences, create a
configuration file for
yourself and Data::Printer will automatically use it!
.PP
\&\fBThat's about it! Feel free to stop reading now and start dumping
your data structures! For more information, including feature set,
how to create filters, and general tips, just keep reading :)\fR
.PP
Oh, if you are just experimenting and/or don't want to use a
configuration file, you can set all options during initialization,
including coloring, indentation and filters!
.PP
.Vb 10
\&  use Data::Printer {
\&      color => {
\&         \*(Aqregex\*(Aq => \*(Aqblue\*(Aq,
\&         \*(Aqhash\*(Aq  => \*(Aqyellow\*(Aq,
\&      },
\&      filters => {
\&         \*(AqDateTime\*(Aq => sub { $_[0]\->ymd },
\&         \*(AqSCALAR\*(Aq   => sub { "oh noes, I found a scalar! $_[0]" },
\&      },
\&  };
.Ve
.PP
The first \f(CW\*(C`{}\*(C'\fR block is just syntax sugar, you can safely omit it
if it makes things easier to read:
.PP
.Vb 1
\&  use DDP colored => 1;
\&
\&  use Data::Printer  deparse => 1, sort_keys => 0;
.Ve
.SH "FEATURES"
.IX Header "FEATURES"
Here's what Data::Printer has to offer to Perl developers, out of the box:
.IP "\(bu" 4
Very sane defaults (I hope!)
.IP "\(bu" 4
Highly customizable (in case you disagree with me :)
.IP "\(bu" 4
Colored output by default
.IP "\(bu" 4
Human-friendly output, with array index and custom separators
.IP "\(bu" 4
Full object dumps including methods, inheritance and internals
.IP "\(bu" 4
Exposes extra information such as tainted data and weak references
.IP "\(bu" 4
Ability to easily create filters for objects and regular structures
.IP "\(bu" 4
Ability to load settings from a \f(CW\*(C`.dataprinter\*(C'\fR file so you don't have to write anything other than \*(L"use \s-1DDP\s0;\*(R" in your code!
.SH "RATIONALE"
.IX Header "RATIONALE"
Data::Dumper is a fantastic tool, meant to stringify data structures
in a way they are suitable for being \f(CW\*(C`eval\*(C'\fR'ed back in.
.PP
The thing is, a lot of people keep using it (and similar ones,
like Data::Dump) to print data structures and objects on screen
for inspection and debugging, and while you \fBcan\fR use those
modules for that, it doesn't mean you \fBshould\fR.
.PP
This is where Data::Printer comes in. It is meant to do one thing
and one thing only:
.PP
\&\fIdisplay Perl variables and objects on screen, properly
formatted\fR (to be inspected by a human)
.PP
If you want to serialize/store/restore Perl data structures,
this module will \s-1NOT\s0 help you. Try Storable, Data::Dumper,
\&\s-1JSON\s0, or whatever. \s-1CPAN\s0 is full of such solutions!
.SH "THE p() FUNCTION"
.IX Header "THE p() FUNCTION"
Once you load Data::Printer, the \f(CW\*(C`p()\*(C'\fR function will be imported
into your namespace and available to you. It will pretty-print
into \s-1STDERR\s0 (or any other output target) whatever variable you pass to it.
.SS "Changing output targets"
.IX Subsection "Changing output targets"
By default, \f(CW\*(C`p()\*(C'\fR will be set to use \s-1STDERR.\s0 As of version 0.27, you
can set up the 'output' property so Data::Printer outputs to
several different places:
.IP "\(bu" 4
\&\f(CW\*(C`output => \*(Aqstderr\*(Aq\*(C'\fR \- Standard error. Same as *STDERR
.IP "\(bu" 4
\&\f(CW\*(C`output => \*(Aqstdout\*(Aq\*(C'\fR \- Standard output. Same as *STDOUT
.IP "\(bu" 4
\&\f(CW\*(C`output => $filename\*(C'\fR \- Appends to filename.
.IP "\(bu" 4
\&\f(CW\*(C`output => $file_handle\*(C'\fR \- Appends to opened handle
.IP "\(bu" 4
\&\f(CW\*(C`output => \e$scalar\*(C'\fR \- Appends to that variable's content
.SS "Return Value"
.IX Subsection "Return Value"
As of version 0.36, Data::Printer's return value defaults to \*(L"pass-through\*(R",
meaning it will dump the variable to \s-1STDERR\s0 (or wherever you set the output
to) and will return the variable itself.
.PP
If for whatever reason you want to mangle with the output string
instead of printing it, you can either use the (also exported) \f(CW\*(C`np()\*(C'\fR
function which always returns the string to be printed:
.PP
.Vb 1
\&    use DDP;
\&
\&    # move to a string
\&    my $string = np @some_array;
\&
\&    # send as a warning
\&    warn np($some_string);
\&
\&    # output to STDOUT instead of STDERR
\&    print np(%some_hash);
.Ve
.PP
or change the return value to 'dump' and ask for p()'s return value instead:
value:
.PP
.Vb 1
\&  use DDP return_value => \*(Aqdump\*(Aq;
\&
\&  # move to a string
\&  my $string = p @some_array;
\&
\&  # output to STDOUT instead of STDERR;
\&  print p(%some_hash);
.Ve
.PP
Note that, in this case, Data::Printer will not colorize the
returned string unless you explicitly set the \f(CW\*(C`colored\*(C'\fR option to 1:
.PP
.Vb 1
\&  print p(%some_hash, colored => 1); # now with colors!
.Ve
.PP
You can \- and should \- of course, set this during you "\f(CW\*(C`use\*(C'\fR" call:
.PP
.Vb 2
\&  use Data::Printer colored => 1;
\&  print p( %some_hash );  # will be colored
.Ve
.PP
Or by adding the setting to your \f(CW\*(C`.dataprinter\*(C'\fR file.
.PP
As most of Data::Printer, the return value is also configurable. You
do this by setting the \f(CW\*(C`return_value\*(C'\fR option. There are three options
available:
.IP "\(bu" 4
\&\f(CW\*(Aqdump\*(Aq\fR
.Sp
.Vb 2
\&    p %var;               # prints the dump to STDERR (void context)
\&    my $string = p %var;  # returns the dump *without* printing
.Ve
.IP "\(bu" 4
\&\f(CW\*(Aqvoid\*(Aq\fR:
.Sp
.Vb 2
\&    p %var;               # prints the dump to STDERR, never returns.
\&    my $string = p %var;  # $string is undef. Data still printed in STDERR
.Ve
.IP "\(bu" 4
\&\f(CW\*(Aqpass\*(Aq\fR (default as of 0.36):
.Sp
.Vb 2
\&    p %var;               # prints the dump to STDERR, returns %var
\&    my %copy = p %var;    # %copy = %var. Data still printed in STDERR
.Ve
.SH "COLORS AND COLORIZATION"
.IX Header "COLORS AND COLORIZATION"
Below are all the available colorizations and their default values.
Note that both spellings ('color' and 'colour') will work.
.PP
.Vb 10
\&   use Data::Printer {
\&     color => {
\&        array       => \*(Aqbright_white\*(Aq,  # array index numbers
\&        number      => \*(Aqbright_blue\*(Aq,   # numbers
\&        string      => \*(Aqbright_yellow\*(Aq, # strings
\&        class       => \*(Aqbright_green\*(Aq,  # class names
\&        method      => \*(Aqbright_green\*(Aq,  # method names
\&        undef       => \*(Aqbright_red\*(Aq,    # the \*(Aqundef\*(Aq value
\&        hash        => \*(Aqmagenta\*(Aq,       # hash keys
\&        regex       => \*(Aqyellow\*(Aq,        # regular expressions
\&        code        => \*(Aqgreen\*(Aq,         # code references
\&        glob        => \*(Aqbright_cyan\*(Aq,   # globs (usually file handles)
\&        vstring     => \*(Aqbright_blue\*(Aq,   # version strings (v5.16.0, etc)
\&        repeated    => \*(Aqwhite on_red\*(Aq,  # references to seen values
\&        caller_info => \*(Aqbright_cyan\*(Aq,   # details on what\*(Aqs being printed
\&        weak        => \*(Aqcyan\*(Aq,          # weak references
\&        tainted     => \*(Aqred\*(Aq,           # tainted content
\&        escaped     => \*(Aqbright_red\*(Aq,    # escaped characters (\et, \en, etc)
\&
\&        # potential new Perl datatypes, unknown to Data::Printer
\&        unknown     => \*(Aqbright_yellow on_blue\*(Aq,
\&     },
\&   };
.Ve
.PP
Don't fancy colors? Disable them with:
.PP
.Vb 1
\&  use Data::Printer colored => 0;
.Ve
.PP
By default, 'colored' is set to \f(CW"auto"\fR, which means Data::Printer
will colorize only when not being used to return the dump string,
nor when the output (default: \s-1STDERR\s0) is being piped. If you're not
seeing colors, try forcing it with:
.PP
.Vb 1
\&  use Data::Printer colored => 1;
.Ve
.PP
Also worth noticing that Data::Printer \fIwill\fR honor the
\&\f(CW\*(C`ANSI_COLORS_DISABLED\*(C'\fR environment variable unless you force a
colored output by setting 'colored' to 1.
.PP
Remember to put your preferred settings in the \f(CW\*(C`.dataprinter\*(C'\fR file
so you never have to type them at all!
.SH "ALIASING"
.IX Header "ALIASING"
Data::Printer provides the nice, short, \f(CW\*(C`p()\*(C'\fR function to dump your
data structures and objects. In case you rather use a more explicit
name, already have a \f(CW\*(C`p()\*(C'\fR function (why?) in your code and want
to avoid clashing, or are just used to other function names for that
purpose, you can easily rename it:
.PP
.Vb 1
\&  use Data::Printer alias => \*(AqDumper\*(Aq;
\&
\&  Dumper( %foo );
.Ve
.SH "CUSTOMIZATION"
.IX Header "CUSTOMIZATION"
I tried to provide sane defaults for Data::Printer, so you'll never have
to worry about anything other than typing \f(CW"p( $var )"\fR in your code.
That said, and besides coloring and filtering, there are several other
customization options available, as shown below (with default values):
.PP
.Vb 10
\&  use Data::Printer {
\&      name           => \*(Aqvar\*(Aq,   # name to display on cyclic references
\&      indent         => 4,       # how many spaces in each indent
\&      hash_separator => \*(Aq   \*(Aq,   # what separates keys from values
\&      align_hash     => 1,       # align values in hash
\&      colored        => \*(Aqauto\*(Aq,  # colorize output (1 for always, 0 for never)
\&      index          => 1,       # display array indices
\&      multiline      => 1,       # display in multiple lines (see note below)
\&      max_depth      => 0,       # how deep to traverse the data (0 for all)
\&      sort_keys      => 1,       # sort hash keys
\&      deparse        => 0,       # use B::Deparse to expand (expose) subroutines
\&      show_tied      => 1,       # expose tied variables
\&      show_tainted   => 1,       # expose tainted variables
\&      show_unicode   => 0,       # show unicode flag if it exists
\&      show_weak      => 1,       # expose weak references
\&      show_readonly  => 0,       # expose scalar variables marked as read\-only
\&      show_lvalue    => 1,       # expose lvalue types
\&      print_escapes  => 0,       # print non\-printable chars as "\en", "\et", etc.
\&      escape_chars   => \*(Aqnone\*(Aq,  # escape chars into \ex{...} form.  Values are
\&                                 # "none", "nonascii", "nonlatin1", "all"
\&      quote_keys     => \*(Aqauto\*(Aq,  # quote hash keys (1 for always, 0 for never).
\&                                 # \*(Aqauto\*(Aq will quote when key is empty/space\-only.
\&      scalar_quotes  => \*(Aq"\*(Aq,     # the quote symbols to enclose scalar values
\&      separator      => \*(Aq,\*(Aq,     # uses \*(Aq,\*(Aq to separate array/hash elements
\&      end_separator  => 0,       # prints the separator after last element in array/hash.
\&                                 # the default is 0 that means not to print
\&
\&      caller_info    => 0,       # include information on what\*(Aqs being printed
\&      use_prototypes => 1,       # allow p(%foo), but prevent anonymous data
\&      return_value   => \*(Aqdump\*(Aq,  # what should p() return? See \*(AqReturn Value\*(Aq above.
\&      output         => \*(Aqstderr\*(Aq,# where to print the output. See
\&                                 # \*(AqChanging output targets\*(Aq above.
\&
\&      class_method   => \*(Aq_data_printer\*(Aq, # make classes aware of Data::Printer
\&                                         # and able to dump themselves.
\&
\&      class => {
\&          internals  => 1,       # show internal data structures of classes
\&
\&          inherited  => \*(Aqnone\*(Aq,  # show inherited methods,
\&                                 # can also be \*(Aqall\*(Aq, \*(Aqprivate\*(Aq, or \*(Aqpublic\*(Aq.
\&
\&          universal  => 1,       # include UNIVERSAL methods in inheritance list
\&
\&          parents    => 1,       # show parents, if there are any
\&          linear_isa => \*(Aqauto\*(Aq,  # show the entire @ISA, linearized, whenever
\&                                 # the object has more than one parent. Can
\&                                 # also be set to 1 (always show) or 0 (never).
\&
\&          expand     => 1,       # how deep to traverse the object (in case
\&                                 # it contains other objects). Defaults to
\&                                 # 1, meaning expand only itself. Can be any
\&                                 # number, 0 for no class expansion, and \*(Aqall\*(Aq
\&                                 # to expand everything.
\&
\&          sort_methods => 1,     # sort public and private methods
\&
\&          show_methods => \*(Aqall\*(Aq  # method list. Also \*(Aqnone\*(Aq, \*(Aqpublic\*(Aq, \*(Aqprivate\*(Aq
\&      },
\&  };
.Ve
.PP
Note: setting \f(CW\*(C`multiline\*(C'\fR to \f(CW0\fR will also set \f(CW\*(C`index\*(C'\fR and \f(CW\*(C`indent\*(C'\fR to \f(CW0\fR.
.SH "FILTERS"
.IX Header "FILTERS"
Data::Printer offers you the ability to use filters to override
any kind of data display. The filters are placed on a hash,
where keys are the types \- or class names \- and values
are anonymous subs that receive two arguments: the item itself
as first parameter, and the properties hashref (in case your
filter wants to read from it). This lets you quickly override
the way Data::Printer handles and displays data types and, in
particular, objects.
.PP
.Vb 4
\&  use Data::Printer filters => {
\&            \*(AqDateTime\*(Aq      => sub { $_[0]\->ymd },
\&            \*(AqHTTP::Request\*(Aq => sub { $_[0]\->uri },
\&  };
.Ve
.PP
Perl types are named as \f(CW\*(C`ref\*(C'\fR calls them: \fI\s-1SCALAR\s0\fR, \fI\s-1ARRAY\s0\fR,
\&\fI\s-1HASH\s0\fR, \fI\s-1REF\s0\fR, \fI\s-1CODE\s0\fR, \fIRegexp\fR and \fI\s-1GLOB\s0\fR. As for objects,
just use the class' name, as shown above.
.PP
As of version 0.13, you may also use the '\-class' filter, which
will be called for all non-perl types (objects).
.PP
Your filters are supposed to return a defined value (usually, the
string you want to print). If you don't, Data::Printer will
let the next filter of that same type have a go, or just fallback
to the defaults. You can also use an array reference to pass more
than one filter for the same type or class.
.PP
\&\fBNote\fR: If you plan on calling \f(CW\*(C`p()\*(C'\fR from \fIwithin\fR an inline
filter, please make sure you are passing only \s-1REFERENCES\s0 as
arguments. See \*(L"\s-1CAVEATS\*(R"\s0 below.
.PP
You may also like to specify standalone filter modules. Please
see Data::Printer::Filter for further information on a more
powerful filter interface for Data::Printer, including useful
filters that are shipped as part of this distribution.
.SH "MAKING YOUR CLASSES DDP-AWARE (WITHOUT ADDING ANY DEPS)"
.IX Header "MAKING YOUR CLASSES DDP-AWARE (WITHOUT ADDING ANY DEPS)"
Whenever printing the contents of a class, Data::Printer first
checks to see if that class implements a sub called '_data_printer'
(or whatever you set the \*(L"class_method\*(R" option to in your settings,
see \*(L"\s-1CUSTOMIZATION\*(R"\s0 below).
.PP
If a sub with that exact name is available in the target object,
Data::Printer will use it to get the string to print instead of
making a regular class dump.
.PP
This means you could have the following in one of your classes:
.PP
.Vb 4
\&  sub _data_printer {
\&      my ($self, $properties) = @_;
\&      return \*(AqHey, no peeking! But foo contains \*(Aq . $self\->foo;
\&  }
.Ve
.PP
Notice you don't have to depend on Data::Printer at all, just
write your sub and it will use that to pretty-print your objects.
.PP
If you want to use colors and filter helpers, and still not
add Data::Printer to your dependencies, remember you can import
them during runtime:
.PP
.Vb 3
\&  sub _data_printer {
\&      require Data::Printer::Filter;
\&      Data::Printer::Filter\->import;
\&
\&      # now we have \*(Aqindent\*(Aq, outdent\*(Aq, \*(Aqlinebreak\*(Aq, \*(Aqp\*(Aq and \*(Aqcolored\*(Aq
\&      my ($self, $properties) = @_;
\&      ...
\&  }
.Ve
.PP
Having a filter for that particular class will of course override
this setting.
.SH "CONFIGURATION FILE (RUN CONTROL)"
.IX Header "CONFIGURATION FILE (RUN CONTROL)"
Data::Printer tries to let you easily customize as much as possible
regarding the visualization of your data structures and objects.
But we don't want you to keep repeating yourself every time you
want to use it!
.PP
To avoid this, you can simply create a file called \f(CW\*(C`.dataprinter\*(C'\fR in
your home directory (usually \f(CW\*(C`/home/username\*(C'\fR in Linux), and put
your configuration hash reference in there.
.PP
This way, instead of doing something like:
.PP
.Vb 11
\&   use Data::Printer {
\&     colour => {
\&        array => \*(Aqbright_blue\*(Aq,
\&     },
\&     filters => {
\&         \*(AqCatalyst::Request\*(Aq => sub {
\&             my $req = shift;
\&             return "Cookies: " . p($req\->cookies)
\&         },
\&     },
\&   };
.Ve
.PP
You can create a .dataprinter file that looks like this:
.PP
.Vb 11
\&   {
\&     colour => {
\&        array => \*(Aqbright_blue\*(Aq,
\&     },
\&     filters => {
\&         \*(AqCatalyst::Request\*(Aq => sub {
\&             my $req = shift;
\&             return "Cookies: " . p($req\->cookies)
\&         },
\&     },
\&   };
.Ve
.PP
Note that all we did was remove the \*(L"use Data::Printer\*(R" bit when
writing the \f(CW\*(C`.dataprinter\*(C'\fR file. From then on all you have to do
while debugging scripts is:
.PP
.Vb 1
\&  use Data::Printer;
.Ve
.PP
and it will load your custom settings every time :)
.SS "Loading \s-1RC\s0 files in custom locations"
.IX Subsection "Loading RC files in custom locations"
If your \s-1RC\s0 file is somewhere other than \f(CW\*(C`.dataprinter\*(C'\fR in your home
dir, you can load whichever file you want via the \f(CW\*(Aqrc_file\*(Aq\fR parameter:
.PP
.Vb 1
\&  use Data::Printer rc_file => \*(Aq/path/to/my/rcfile.conf\*(Aq;
.Ve
.PP
You can even set this to undef or to a non-existing file to disable your
\&\s-1RC\s0 file at will.
.PP
The \s-1RC\s0 file location can also be specified with the \f(CW\*(C`DATAPRINTERRC\*(C'\fR
environment variable. Using \f(CW\*(C`rc_file\*(C'\fR in code will override the environment
variable.
.SS "\s-1RC\s0 File Security"
.IX Subsection "RC File Security"
The \f(CW\*(C`.dataprinter\*(C'\fR \s-1RC\s0 file is nothing but a Perl hash that
gets \f(CW\*(C`eval\*(C'\fR'd back into the code. This means that whatever
is in your \s-1RC\s0 file \fB\s-1WILL BE INTERPRETED BY PERL AT RUNTIME\s0\fR.
This can be quite worrying if you're not the one in control
of the \s-1RC\s0 file.
.PP
For this reason, Data::Printer takes extra precaution before
loading the file:
.IP "\(bu" 4
The file has to be in your home directory unless you
specifically point elsewhere via the '\f(CW\*(C`rc_file\*(C'\fR' property or
the \s-1DATAPRINTERRC\s0 environment variable;
.IP "\(bu" 4
The file \fBmust\fR be a plain file, never a symbolic
link, named pipe or socket;
.IP "\(bu" 4
The file \fBmust\fR be owned by you (i.e. the effective
user id that ran the script using Data::Printer);
.IP "\(bu" 4
The file \fBmust\fR be read-only for everyone but your user.
This usually means permissions \f(CW0644\fR, \f(CW0640\fR or \f(CW0600\fR in
Unix-like systems. \fB\s-1THIS IS NOT CHECKED IN WIN32\s0\fR;
.IP "\(bu" 4
The file will \fB\s-1NOT\s0\fR be loaded in Taint mode, unless
you specifically load Data::Printer with the 'allow_tainted'
option set to true. And even if you do that, Data::Printer
will still issue a warning before loading the file. But
seriously, don't do that.
.PP
Failure to comply with the security rules above will result in
the \s-1RC\s0 file not being loaded (likely with a warning on what went
wrong).
.ie n .SH "THE ""DDP"" PACKAGE ALIAS"
.el .SH "THE ``DDP'' PACKAGE ALIAS"
.IX Header "THE DDP PACKAGE ALIAS"
You're likely to add/remove Data::Printer from source code being
developed and debugged all the time, and typing it might feel too
long. Because of this, the '\s-1DDP\s0' package is provided as a shorter
alias to Data::Printer:
.PP
.Vb 2
\&   use DDP;
\&   p %some_var;
.Ve
.SH "CALLER INFORMATION"
.IX Header "CALLER INFORMATION"
If you set caller_info to a true value, Data::Printer will prepend
every call with an informational message. For example:
.PP
.Vb 1
\&  use Data::Printer caller_info => 1;
\&
\&  my $var = 42;
\&  p $var;
.Ve
.PP
will output something like:
.PP
.Vb 2
\&  Printing in line 4 of myapp.pl:
\&  42
.Ve
.PP
The default message is \f(CW\*(AqPrinting in line _\|_LINE_\|_ of _\|_FILENAME_\|_:\*(Aq\fR.
The special strings \f(CW\*(C`_\|_LINE_\|_\*(C'\fR, \f(CW\*(C`_\|_FILENAME_\|_\*(C'\fR and \f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR will
be interpolated into their according value so you can customize them at will:
.PP
.Vb 6
\&  use Data::Printer
\&    caller_info => 1,
\&    caller_message => "Okay, _\|_PACKAGE_\|_, let\*(Aqs dance!"
\&    color => {
\&        caller_info => \*(Aqbright_red\*(Aq,
\&    };
.Ve
.PP
As shown above, you may also set a color for \*(L"caller_info\*(R" in your color
hash. Default is cyan.
.SH "EXPERIMENTAL FEATURES"
.IX Header "EXPERIMENTAL FEATURES"
The following are volatile parts of the \s-1API\s0 which are subject to
change at any given version. Use them at your own risk.
.SS "Local Configuration (experimental!)"
.IX Subsection "Local Configuration (experimental!)"
You can override global configurations by writing them as the second
parameter for p(). For example:
.PP
.Vb 1
\&  p( %var, color => { hash => \*(Aqgreen\*(Aq } );
.Ve
.SS "Filter classes"
.IX Subsection "Filter classes"
As of Data::Printer 0.11, you can create complex filters as a separate
module. Those can even be uploaded to \s-1CPAN\s0 and used by other people!
See Data::Printer::Filter for further information.
.SH "CAVEATS"
.IX Header "CAVEATS"
You can't pass more than one variable at a time.
.PP
.Vb 3
\&   p($foo, $bar); # wrong
\&   p($foo);       # right
\&   p($bar);       # right
.Ve
.PP
You can't use it in variable declarations (it will most likely not do what
you want):
.PP
.Vb 2
\&    p my @array = qw(a b c d);         # wrong
\&    my @array = qw(a b c d); p @array; # right
.Ve
.PP
The default mode is to use prototypes, in which you are supposed to pass
variables, not anonymous structures:
.PP
.Vb 1
\&   p( { foo => \*(Aqbar\*(Aq } ); # wrong
\&
\&   p %somehash;        # right
\&   p $hash_ref;        # also right
.Ve
.PP
To pass anonymous structures, set \*(L"use_prototypes\*(R" option to 0. But
remember you'll have to pass your variables as references:
.PP
.Vb 1
\&   use Data::Printer use_prototypes => 0;
\&
\&   p( { foo => \*(Aqbar\*(Aq } ); # was wrong, now is right.
\&
\&   p( %foo  ); # was right, but fails without prototypes
\&   p( \e%foo ); # do this instead
.Ve
.PP
If you are using inline filters, and calling p() (or whatever name you
aliased it to) from inside those filters, you \fBmust\fR pass the arguments
to \f(CW\*(C`p()\*(C'\fR as a reference:
.PP
.Vb 12
\&  use Data::Printer {
\&      filters => {
\&          ARRAY => sub {
\&              my $listref = shift;
\&              my $string = \*(Aq\*(Aq;
\&              foreach my $item (@$listref) {
\&                  $string .= p( \e$item );      # p( $item ) will not work!
\&              }
\&              return $string;
\&          },
\&      },
\&  };
.Ve
.PP
This happens because your filter function is compiled \fIbefore\fR Data::Printer
itself loads, so the filter does not see the function prototype. As a way
to avoid unpleasant surprises, if you forget to pass a reference, Data::Printer
will generate an exception for you with the following message:
.PP
.Vb 1
\&    \*(AqWhen calling p() without prototypes, please pass arguments as references\*(Aq
.Ve
.PP
Another way to avoid this is to use the much more complete Data::Printer::Filter
interface for standalone filters.
.SH "EXTRA TIPS"
.IX Header "EXTRA TIPS"
.SS "Circumventing prototypes"
.IX Subsection "Circumventing prototypes"
The \f(CW\*(C`p()\*(C'\fR function uses prototypes by default, allowing you to say:
.PP
.Vb 1
\&  p %var;
.Ve
.PP
instead of always having to pass references, like:
.PP
.Vb 1
\&  p \e%var;
.Ve
.PP
There are cases, however, where you may want to pass anonymous
structures, like:
.PP
.Vb 1
\&  p { foo => $bar };   # this blows up, don\*(Aqt use
.Ve
.PP
and because of prototypes, you can't. If this is your case, just
set \*(L"use_prototypes\*(R" option to 0. Note, with this option,
you \fBwill\fR have to pass your variables as references:
.PP
.Vb 1
\&  use Data::Printer use_prototypes => 0;
\&
\&   p { foo => \*(Aqbar\*(Aq }; # doesn\*(Aqt blow up anymore, works just fine.
\&
\&   p %var;  # but now this blows up...
\&   p \e%var; # ...so do this instead
\&
\&   p [ $foo, $bar, \e@baz ]; # this way you can even pass
\&                            # several variables at once
.Ve
.PP
Versions prior to 0.17 don't have the \*(L"use_prototypes\*(R" option. If
you're stuck in an older version you can write \f(CW\*(C`&p()\*(C'\fR instead of \f(CW\*(C`p()\*(C'\fR
to circumvent prototypes and pass elements (including anonymous variables)
as \fB\s-1REFERENCES\s0\fR. This notation, however, requires enclosing parentheses:
.PP
.Vb 2
\&  &p( { foo => $bar } );        # this is ok, use at will
\&  &p( \e"DEBUGGING THIS BIT" );  # this works too
.Ve
.PP
Or you could just create a very simple wrapper function:
.PP
.Vb 1
\&  sub pp { p @_ };
.Ve
.PP
And use it just as you use \f(CW\*(C`p()\*(C'\fR.
.SS "Minding the return value of p()"
.IX Subsection "Minding the return value of p()"
\&\fI(contributed by Matt S. Trout (mst))\fR
.PP
There is a reason why explicit return statements are recommended unless
you know what you're doing. By default, Data::Printer's return value
depends on how it was called. When not in void context, it returns the
serialized form of the dump.
.PP
It's tempting to trust your own p() calls with that approach, but if
this is your \fIlast\fR statement in a function, you should keep in mind
your debugging code will behave differently depending on how your
function was called!
.PP
To prevent that, set the \f(CW\*(C`return_value\*(C'\fR property to either 'void'
or 'pass'. You won't be able to retrieve the dumped string but, hey,
who does that anyway :)
.PP
Assuming you have set the pass-through ('pass') property in your
\&\f(CW\*(C`.dataprinter\*(C'\fR file, another stunningly useful thing you can do with it
is change code that says:
.PP
.Vb 1
\&   return $obj\->foo;
.Ve
.PP
with:
.PP
.Vb 1
\&   use DDP;
\&
\&   return p $obj\->foo;
.Ve
.PP
You can even add it to chained calls if you wish to see the dump of
a particular state, changing this:
.PP
.Vb 1
\&   $obj\->foo\->bar\->baz;
.Ve
.PP
to:
.PP
.Vb 1
\&   $obj\->foo\->DDP::p\->bar\->baz
.Ve
.PP
And things will \*(L"Just Work\*(R".
.SS "Using p() in some/all of your loaded modules"
.IX Subsection "Using p() in some/all of your loaded modules"
\&\fI(contributed by Matt S. Trout (mst))\fR
.PP
While debugging your software, you may want to use Data::Printer in
some or all loaded modules and not bother having to load it in
each and every one of them. To do this, in any module loaded by
\&\f(CW\*(C`myapp.pl\*(C'\fR, simply write:
.PP
.Vb 1
\&  ::p( @myvar );  # note the \*(Aq::\*(Aq in front of p()
.Ve
.PP
Then call your program like:
.PP
.Vb 1
\&  perl \-MDDP myapp.pl
.Ve
.PP
This also has the great advantage that if you leave one p() call
in by accident, it will fail without the \-M, making it easier to spot :)
.PP
If you really want to have p() imported into your loaded
modules, use the next tip instead.
.SS "Adding p() to all your loaded modules"
.IX Subsection "Adding p() to all your loaded modules"
\&\fI(contributed by Árpád Szász)\fR
.PP
If you wish to automatically add Data::Printer's \f(CW\*(C`p()\*(C'\fR function to
every loaded module in you app, you can do something like this to
your main program:
.PP
.Vb 12
\&    BEGIN {
\&        {
\&            no strict \*(Aqrefs\*(Aq;
\&            require Data::Printer;
\&            my $alias = \*(Aqp\*(Aq;
\&            foreach my $package ( keys %main:: ) {
\&                if ( $package =~ m/::$/ ) {
\&                    *{ $package . $alias } = \e&Data::Printer::p;
\&                }
\&            }
\&        }
\&    }
.Ve
.PP
\&\fB\s-1WARNING\s0\fR This will override all locally defined subroutines/methods that
are named \f(CW\*(C`p\*(C'\fR, if they exist, in every loaded module. If you already
have a subroutine named '\f(CW\*(C`p()\*(C'\fR', be sure to change \f(CW$alias\fR to
something custom.
.PP
If you rather avoid namespace manipulation altogether, use the previous
tip instead.
.SS "Using Data::Printer from the Perl debugger"
.IX Subsection "Using Data::Printer from the Perl debugger"
\&\fI(contributed by Árpád Szász and Marcel Grünauer (hanekomu))\fR
.PP
With DB::Pluggable, you can easily set the perl debugger to use
Data::Printer to print variable information, replacing the debugger's
standard \f(CW\*(C`p()\*(C'\fR function. All you have to do is add these lines to
your \f(CW\*(C`.perldb\*(C'\fR file:
.PP
.Vb 2
\&  use DB::Pluggable;
\&  DB::Pluggable\->run_with_config( \e\*(Aq[DataPrinter]\*(Aq );  # note the \*(Aq\e\*(Aq
.Ve
.PP
Then call the perl debugger as you normally would:
.PP
.Vb 1
\&  perl \-d myapp.pl
.Ve
.PP
Now Data::Printer's \f(CW\*(C`p()\*(C'\fR command will be used instead of the debugger's!
.PP
See perldebug for more information on how to use the perl debugger, and
DB::Pluggable for extra functionality and other plugins.
.PP
If you can't or don't wish to use DB::Pluggable, or simply want to keep
the debugger's \f(CW\*(C`p()\*(C'\fR function and add an extended version using
Data::Printer (let's call it \f(CW\*(C`px()\*(C'\fR for instance), you can add these
lines to your \f(CW\*(C`.perldb\*(C'\fR file instead:
.PP
.Vb 6
\&    $DB::alias{px} = \*(Aqs/px/DB::px/\*(Aq;
\&    sub px {
\&        my $expr = shift;
\&        require Data::Printer;
\&        print Data::Printer::p($expr);
\&    }
.Ve
.PP
Now, inside the Perl debugger, you can pass as reference to \f(CW\*(C`px\*(C'\fR expressions
to be dumped using Data::Printer.
.SS "Using Data::Printer in a perl shell (\s-1REPL\s0)"
.IX Subsection "Using Data::Printer in a perl shell (REPL)"
Some people really enjoy using a \s-1REPL\s0 shell to quickly try Perl code. One
of the most famous ones out there is Devel::REPL. If you use it, now
you can also see its output with Data::Printer!
.PP
Just install Devel::REPL::Plugin::DataPrinter and add the following
line to your re.pl configuration file (usually \*(L".re.pl/repl.rc\*(R" in your
home dir):
.PP
.Vb 1
\&  load_plugin(\*(AqDataPrinter\*(Aq);
.Ve
.PP
The next time you run \f(CW\*(C`re.pl\*(C'\fR, it should dump all your \s-1REPL\s0 using
Data::Printer!
.SS "Easily rendering Data::Printer's output as \s-1HTML\s0"
.IX Subsection "Easily rendering Data::Printer's output as HTML"
To turn Data::Printer's output into \s-1HTML,\s0 you can do something like:
.PP
.Vb 2
\&  use HTML::FromANSI;
\&  use Data::Printer;
\&
\&  my $html_output = ansi2html( p($object, colored => 1) );
.Ve
.PP
In the example above, the \f(CW$html_output\fR variable contains the
\&\s-1HTML\s0 escaped output of \f(CW\*(C`p($object)\*(C'\fR, so you can print it for
later inspection or render it (if it's a web app).
.SS "Using Data::Printer with Template Toolkit"
.IX Subsection "Using Data::Printer with Template Toolkit"
\&\fI(contributed by Stephen Thirlwall (sdt))\fR
.PP
If you use Template Toolkit and want to dump your variables using Data::Printer,
install the Template::Plugin::DataPrinter module and load it in your template:
.PP
.Vb 1
\&   [% USE DataPrinter %]
.Ve
.PP
The provided methods match those of \f(CW\*(C`Template::Plugin::Dumper\*(C'\fR:
.PP
.Vb 2
\&   ansi\-colored dump of the data structure in "myvar":
\&   [% DataPrinter.dump( myvar ) %]
\&
\&   html\-formatted, colored dump of the same data structure:
\&   [% DataPrinter.dump_html( myvar ) %]
.Ve
.PP
The module allows several customization options, even letting you load it as a
complete drop-in replacement for Template::Plugin::Dumper so you don't even have
to change your previous templates!
.SS "Unified interface for Data::Printer and other debug formatters"
.IX Subsection "Unified interface for Data::Printer and other debug formatters"
\&\fI(contributed by Kevin McGrath (catlgrep))\fR
.PP
If you are porting your code to use Data::Printer instead of
Data::Dumper or similar, you can just replace:
.PP
.Vb 1
\&  use Data::Dumper;
.Ve
.PP
with:
.PP
.Vb 2
\&  use Data::Printer alias => \*(AqDumper\*(Aq;
\&  # use Data::Dumper;
.Ve
.PP
making sure to provide Data::Printer with the proper alias for the
previous dumping function.
.PP
If, however, you want a really unified approach where you can easily
flip between debugging outputs, use Any::Renderer and its plugins,
like Any::Renderer::Data::Printer.
.SS "Printing stack traces with arguments expanded using Data::Printer"
.IX Subsection "Printing stack traces with arguments expanded using Data::Printer"
\&\fI(contributed by Sergey Aleynikov (randir))\fR
.PP
There are times where viewing the current state of a variable is not
enough, and you want/need to see a full stack trace of a function call.
.PP
The Devel::PrettyTrace module uses Data::Printer to provide you just
that. It exports a \f(CW\*(C`bt()\*(C'\fR function that pretty-prints detailed information
on each function in your stack, making it easier to spot any issues!
.SS "Troubleshooting apps in real time without changing a single line of your code"
.IX Subsection "Troubleshooting apps in real time without changing a single line of your code"
\&\fI(contributed by Marcel Grünauer (hanekomu))\fR
.PP
dip is a dynamic instrumentation framework for troubleshooting Perl
programs, similar to DTrace <http://opensolaris.org/os/community/dtrace/>.
In a nutshell, \f(CW\*(C`dip\*(C'\fR lets you create probes for certain conditions
in your application that, once met, will perform a specific action. Since
it uses Aspect-oriented programming, it's very lightweight and you only
pay for what you use.
.PP
\&\f(CW\*(C`dip\*(C'\fR can be very useful since it allows you to debug your software
without changing a single line of your original code. And Data::Printer
comes bundled with it, so you can use the \f(CW\*(C`p()\*(C'\fR function to view your
data structures too!
.PP
.Vb 4
\&   # Print a stack trace every time the name is changed,
\&   # except when reading from the database.
\&   dip \-e \*(Aqbefore { print longmess(p $_\->{args}[1]) if $_\->{args}[1] }
\&     call "MyObj::name" & !cflow("MyObj::read")\*(Aq myapp.pl
.Ve
.PP
You can check you dip's own documentation for more information and options.
.SS "Sample output for color fine-tuning"
.IX Subsection "Sample output for color fine-tuning"
\&\fI(contributed by Yanick Champoux (yanick))\fR
.PP
The \*(L"examples/try_me.pl\*(R" file included in this distribution has a sample
dump with a complex data structure to let you quickly test color schemes.
.SS "creating fiddling filters"
.IX Subsection "creating fiddling filters"
\&\fI(contributed by dirk)\fR
.PP
Sometimes, you may want to take advantage of Data::Printer's original dump,
but add/change some of the original data to enhance your debugging ability.
Say, for example, you have an \f(CW\*(C`HTTP::Response\*(C'\fR object you want to print
but the content is encoded. The basic approach, of course, would be to
just dump the decoded content:
.PP
.Vb 3
\&  use DDP filter {
\&    \*(AqHTTP::Response\*(Aq => sub { p( \eshift\->decoded_content, %{shift} );
\&  };
.Ve
.PP
But what if you want to see the rest of the original object? Dumping it
would be a no-go, because you would just recurse forever in your own filter.
.PP
Never fear! When you create a filter in Data::Printer, you're not replacing
the original one, you're just stacking yours on top of it. To forward your data
to the original filter, all you have to do is return an undefined value. This
means you can rewrite your \f(CW\*(C`HTTP::Response\*(C'\fR filter like so, if you want:
.PP
.Vb 3
\&  use DDP filters => {
\&    \*(AqHTTP::Response\*(Aq => sub {
\&      my ($res, $p) = @_;
\&
\&      # been here before? Switch to original handler
\&      return if exists $res\->{decoded_content};
\&
\&      # first timer? Come on in!
\&      my $clone = $res\->clone;
\&      $clone\->{decoded_content} = $clone\->decoded_content;
\&      return p($clone, %$p);
\&    }
\&  };
.Ve
.PP
And voilà! Your fiddling filter now works like a charm :)
.SH "BUGS"
.IX Header "BUGS"
If you find any, please file a bug report.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Dumper
.PP
Data::Dump
.PP
Data::Dumper::Concise
.PP
Data::Dump::Streamer
.PP
Data::PrettyPrintObjects
.PP
Data::TreeDumper
.SH "AUTHOR"
.IX Header "AUTHOR"
Breno G. de Oliveira \f(CW\*(C`<garu at cpan.org>\*(C'\fR
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Many thanks to everyone that helped design and develop this module
with patches, bug reports, wishlists, comments and tests. They are
(alphabetically):
.IP "\(bu" 4
Adam Rosenstein
.IP "\(bu" 4
Allan Whiteford
.IP "\(bu" 4
Andreas König
.IP "\(bu" 4
Andy Bach
.IP "\(bu" 4
Árpád Szász
.IP "\(bu" 4
Athanasios Douitsis (aduitsis)
.IP "\(bu" 4
Baldur Kristinsson
.IP "\(bu" 4
brian d foy
.IP "\(bu" 4
Chad Granum (exodist)
.IP "\(bu" 4
Chris Prather (perigrin)
.IP "\(bu" 4
Dave Mitchell
.IP "\(bu" 4
David D Lowe (Flimm)
.IP "\(bu" 4
David Golden (xdg)
.IP "\(bu" 4
David Precious (bigpresh)
.IP "\(bu" 4
David Raab
.IP "\(bu" 4
Damien Krotkine (dams)
.IP "\(bu" 4
Denis Howe
.IP "\(bu" 4
Dotan Dimet
.IP "\(bu" 4
Eden Cardim (edenc)
.IP "\(bu" 4
Elliot Shank (elliotjs)
.IP "\(bu" 4
Fernando Corrêa (SmokeMachine)
.IP "\(bu" 4
Fitz Elliott
.IP "\(bu" 4
Frew Schmidt (frew)
.IP "\(bu" 4
Ivan Bessarabov (bessarabv)
.IP "\(bu" 4
J Mash
.IP "\(bu" 4
Jay Allen (jayallen)
.IP "\(bu" 4
Jesse Luehrs (doy)
.IP "\(bu" 4
Jim Keenan (jkeenan)
.IP "\(bu" 4
Joel Berger (jberger)
.IP "\(bu" 4
John S. Anderson (genehack)
.IP "\(bu" 4
Kartik Thakore (kthakore)
.IP "\(bu" 4
Kevin Dawson (bowtie)
.IP "\(bu" 4
Kevin McGrath (catlgrep)
.IP "\(bu" 4
Kip Hampton (ubu)
.IP "\(bu" 4
Marcel Grünauer (hanekomu)
.IP "\(bu" 4
Marco Masetti (grubert65)
.IP "\(bu" 4
Mark Fowler (Trelane)
.IP "\(bu" 4
Matt S. Trout (mst)
.IP "\(bu" 4
Maxim Vuets
.IP "\(bu" 4
Michael Conrad
.IP "\(bu" 4
Mike Doherty (doherty)
.IP "\(bu" 4
Nuba Princigalli (nuba)
.IP "\(bu" 4
Olaf Alders (oalders)
.IP "\(bu" 4
Paul Evans (LeoNerd)
.IP "\(bu" 4
Pedro Melo (melo)
.IP "\(bu" 4
Przemysław Wesołek (jest)
.IP "\(bu" 4
Rebecca Turner (iarna)
.IP "\(bu" 4
Renato Cron (renatoCRON)
.IP "\(bu" 4
Ricardo Signes (rjbs)
.IP "\(bu" 4
Rob Hoelz (hoelzro)
.IP "\(bu" 4
sawyer
.IP "\(bu" 4
Sebastian Willing (Sewi)
.IP "\(bu" 4
Sergey Aleynikov (randir)
.IP "\(bu" 4
Stanislaw Pusep (syp)
.IP "\(bu" 4
Stephen Thirlwall (sdt)
.IP "\(bu" 4
sugyan
.IP "\(bu" 4
Tatsuhiko Miyagawa (miyagawa)
.IP "\(bu" 4
Thomas Sibley (tsibley)
.IP "\(bu" 4
Tim Heaney (oylenshpeegul)
.IP "\(bu" 4
Torsten Raudssus (Getty)
.IP "\(bu" 4
Tokuhiro Matsuno (tokuhirom)
.IP "\(bu" 4
vividsnow
.IP "\(bu" 4
Wesley Dal`Col (blabos)
.IP "\(bu" 4
Yanick Champoux (yanick)
.IP "\(bu" 4
Zefram
.PP
If I missed your name, please drop me a line!
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2011\-2017 Breno G. de Oliveira \f(CW\*(C`<garu at cpan.org>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE\s0 (\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
