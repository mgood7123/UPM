.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "LexAlias 3"
.TH LexAlias 3 "2013-01-16" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::LexAlias \- alias lexical variables
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Devel::LexAlias qw(lexalias);
\&
\& sub steal_my_x {
\&     my $foo = 1;
\&     lexalias(1, \*(Aq$x\*(Aq, \e$foo);
\& }
\&
\& sub foo {
\&     my $x = 22;
\&     print $x; # prints 22
\&
\&     steal_my_x;
\&     print $x; # prints 1
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Devel::LexAlias provides the ability to alias a lexical variable in a
subroutines scope to one of your choosing.
.PP
If you don't know why you'd want to do this, I'd suggest that you skip
this module.  If you think you have a use for it, I'd insist on it.
.PP
Still here?
.ie n .IP "lexalias( $where, $name, $variable )" 4
.el .IP "lexalias( \f(CW$where\fR, \f(CW$name\fR, \f(CW$variable\fR )" 4
.IX Item "lexalias( $where, $name, $variable )"
\&\f(CW$where\fR refers to the subroutine in which to alias the lexical, it
can be a coderef or a call level such that you'd give to \f(CW\*(C`caller\*(C'\fR
.Sp
\&\f(CW$name\fR is the name of the lexical within that subroutine
.Sp
\&\f(CW$variable\fR is a reference to the variable to install at that location
.SH "BUGS"
.IX Header "BUGS"
lexalias delves into the internals of the interpreter to perform its
actions and is so very sensitive to bad data, which will likely result
in flaming death, or a core dump.  Consider this a warning.
.PP
There is no checking that you are attaching a suitable variable back
into the pad as implied by the name of the variable, so it is possible
to do the following:
.PP
.Vb 1
\& lexalias( $sub, \*(Aq$foo\*(Aq, [qw(an array)] );
.Ve
.PP
The behaviour of this is untested, I imagine badness is very close on
the horizon though.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
peek_sub from PadWalker, Devel::Peek
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Clamp <richardc@unixbeard.net> with close reference to
PadWalker by Robin Houston
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002, 2013, Richard Clamp. All Rights Reserved.  This module
is free software. It may be used, redistributed and/or modified under
the same terms as Perl itself.
