.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Net::DNS 3"
.TH Net::DNS 3 "2017-08-18" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS \- Perl Interface to the Domain Name System
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::DNS;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::DNS is a collection of Perl modules that act as a Domain Name System
(\s-1DNS\s0) resolver. It allows the programmer to perform \s-1DNS\s0 queries that are
beyond the capabilities of \*(L"gethostbyname\*(R" and \*(L"gethostbyaddr\*(R".
.PP
The programmer should be somewhat familiar with the format of a \s-1DNS\s0 packet
and its various sections. See \s-1RFC 1035\s0 or \s-1DNS\s0 and \s-1BIND\s0 (Albitz & Liu) for
details.
.SS "Resolver Objects"
.IX Subsection "Resolver Objects"
A resolver object is an instance of the Net::DNS::Resolver class.
A program can have multiple resolver objects, each maintaining its
own state information such as the nameservers to be queried, whether
recursion is desired, etc.
.SS "Packet Objects"
.IX Subsection "Packet Objects"
Net::DNS::Resolver queries return Net::DNS::Packet objects.
Packet objects have five sections:
.IP "\(bu" 3
The header section, a Net::DNS::Header object.
.IP "\(bu" 3
The question section, a list of Net::DNS::Question objects.
.IP "\(bu" 3
The answer section, a list of Net::DNS::RR objects.
.IP "\(bu" 3
The authority section, a list of Net::DNS::RR objects.
.IP "\(bu" 3
The additional section, a list of Net::DNS::RR objects.
.SS "Update Objects"
.IX Subsection "Update Objects"
Net::DNS::Update is a subclass of Net::DNS::Packet
used to create dynamic update requests.
.SS "Header Objects"
.IX Subsection "Header Objects"
Net::DNS::Header objects represent the header
section of a \s-1DNS\s0 packet.
.SS "Question Objects"
.IX Subsection "Question Objects"
Net::DNS::Question objects represent the content of the question
section of a \s-1DNS\s0 packet.
.SS "\s-1RR\s0 Objects"
.IX Subsection "RR Objects"
Net::DNS::RR is the base class for \s-1DNS\s0 resource record (\s-1RR\s0) objects
in the answer, authority, and additional sections of a \s-1DNS\s0 packet.
.PP
Do not assume that \s-1RR\s0 objects will be of the type requested.
The type of an \s-1RR\s0 object must be checked before calling any methods.
.SH "METHODS"
.IX Header "METHODS"
See the manual pages listed above for other class-specific methods.
.SS "version"
.IX Subsection "version"
.Vb 1
\&    print Net::DNS\->version, "\en";
.Ve
.PP
Returns the version of Net::DNS.
.SS "rr"
.IX Subsection "rr"
.Vb 5
\&    # Use a default resolver \-\- can not get an error string this way.
\&    use Net::DNS;
\&    my @rr = rr("example.com");
\&    my @rr = rr("example.com", "A");
\&    my @rr = rr("example.com", "A", "IN");
\&
\&    # Use your own resolver object.
\&    my $res = Net::DNS::Resolver\->new;
\&    my @rr  = rr($res, "example.com" ... );
\&
\&    my ($ptr) = rr("192.0.2.1");
.Ve
.PP
The \f(CW\*(C`rr()\*(C'\fR method provides simple \s-1RR\s0 lookup for scenarios where
the full flexibility of Net::DNS is not required.
.PP
Returns a list of Net::DNS::RR objects for the specified name
or an empty list if the query failed or no record was found.
.PP
See \*(L"\s-1EXAMPLES\*(R"\s0 for more complete examples.
.SS "mx"
.IX Subsection "mx"
.Vb 3
\&    # Use a default resolver \-\- can not get an error string this way.
\&    use Net::DNS;
\&    my @mx = mx("example.com");
\&
\&    # Use your own resolver object.
\&    my $res = Net::DNS::Resolver\->new;
\&    my @mx  = mx($res, "example.com");
.Ve
.PP
Returns a list of Net::DNS::RR::MX objects representing the \s-1MX\s0
records for the specified name.
The list will be sorted by preference.
Returns an empty list if the query failed or no \s-1MX\s0 record was found.
.PP
This method does not look up A records; it only performs \s-1MX\s0 queries.
.SH "Dynamic DNS Update Support"
.IX Header "Dynamic DNS Update Support"
The Net::DNS module provides auxiliary functions which support
dynamic \s-1DNS\s0 update requests.
.SS "yxrrset"
.IX Subsection "yxrrset"
Use this method to add an \*(L"RRset exists\*(R" prerequisite to a dynamic
update packet.	There are two forms, value-independent and
value-dependent:
.PP
.Vb 2
\&    # RRset exists (value\-independent)
\&    $update\->push(pre => yxrrset("host.example.com A"));
.Ve
.PP
Meaning:  At least one \s-1RR\s0 with the specified name and type must
exist.
.PP
.Vb 2
\&    # RRset exists (value\-dependent)
\&    $update\->push(pre => yxrrset("host.example.com A 10.1.2.3"));
.Ve
.PP
Meaning:  At least one \s-1RR\s0 with the specified name and type must
exist and must have matching data.
.PP
Returns a Net::DNS::RR object or \f(CW\*(C`undef\*(C'\fR if the object could not
be created.
.SS "nxrrset"
.IX Subsection "nxrrset"
Use this method to add an \*(L"RRset does not exist\*(R" prerequisite to
a dynamic update packet.
.PP
.Vb 1
\&    $update\->push(pre => nxrrset("host.example.com A"));
.Ve
.PP
Meaning:  No RRs with the specified name and type can exist.
.PP
Returns a Net::DNS::RR object or \f(CW\*(C`undef\*(C'\fR if the object could not
be created.
.SS "yxdomain"
.IX Subsection "yxdomain"
Use this method to add a \*(L"name is in use\*(R" prerequisite to a dynamic
update packet.
.PP
.Vb 1
\&    $update\->push(pre => yxdomain("host.example.com"));
.Ve
.PP
Meaning:  At least one \s-1RR\s0 with the specified name must exist.
.PP
Returns a Net::DNS::RR object or \f(CW\*(C`undef\*(C'\fR if the object could not
be created.
.SS "nxdomain"
.IX Subsection "nxdomain"
Use this method to add a \*(L"name is not in use\*(R" prerequisite to a
dynamic update packet.
.PP
.Vb 1
\&    $update\->push(pre => nxdomain("host.example.com"));
.Ve
.PP
Meaning:  No \s-1RR\s0 with the specified name can exist.
.PP
Returns a Net::DNS::RR object or \f(CW\*(C`undef\*(C'\fR if the object could not
be created.
.SS "rr_add"
.IX Subsection "rr_add"
Use this method to add RRs to a zone.
.PP
.Vb 1
\&    $update\->push(update => rr_add("host.example.com A 10.1.2.3"));
.Ve
.PP
Meaning:  Add this \s-1RR\s0 to the zone.
.PP
\&\s-1RR\s0 objects created by this method should be added to the \*(L"update\*(R"
section of a dynamic update packet.  The \s-1TTL\s0 defaults to 86400
seconds (24 hours) if not specified.
.PP
Returns a Net::DNS::RR object or \f(CW\*(C`undef\*(C'\fR if the object could not
be created.
.SS "rr_del"
.IX Subsection "rr_del"
Use this method to delete RRs from a zone.  There are three forms:
delete all RRsets, delete an RRset, and delete a specific \s-1RR.\s0
.PP
.Vb 2
\&    # Delete all RRsets.
\&    $update\->push(update => rr_del("host.example.com"));
.Ve
.PP
Meaning:  Delete all RRs having the specified name.
.PP
.Vb 2
\&    # Delete an RRset.
\&    $update\->push(update => rr_del("host.example.com A"));
.Ve
.PP
Meaning:  Delete all RRs having the specified name and type.
.PP
.Vb 2
\&    # Delete a specific RR.
\&    $update\->push(update => rr_del("host.example.com A 10.1.2.3"));
.Ve
.PP
Meaning:  Delete all RRs having the specified name, type, and data.
.PP
\&\s-1RR\s0 objects created by this method should be added to the \*(L"update\*(R"
section of a dynamic update packet.
.PP
Returns a Net::DNS::RR object or \f(CW\*(C`undef\*(C'\fR if the object could not
be created.
.SH "Zone Serial Number Management"
.IX Header "Zone Serial Number Management"
The Net::DNS module provides auxiliary functions which support
policy-driven zone serial numbering regimes.
.SS "\s-1SEQUENTIAL\s0"
.IX Subsection "SEQUENTIAL"
.Vb 1
\&    $successor = $soa\->serial( SEQUENTIAL );
.Ve
.PP
The existing serial number is incremented modulo 2**32.
.SS "\s-1UNIXTIME\s0"
.IX Subsection "UNIXTIME"
.Vb 1
\&    $successor = $soa\->serial( UNIXTIME );
.Ve
.PP
The Unix time scale will be used as the basis for zone serial
numbering. The serial number will be incremented if the time
elapsed since the previous update is less than one second.
.SS "YYYYMMDDxx"
.IX Subsection "YYYYMMDDxx"
.Vb 1
\&    $successor = $soa\->serial( YYYYMMDDxx );
.Ve
.PP
The 32 bit value returned by the auxiliary \f(CW\*(C`YYYYMMDDxx()\*(C'\fR function
will be used as the base for the date-coded zone serial number.
Serial number increments must be limited to 100 per day for the
date information to remain useful.
.SH "Sorting of RR arrays"
.IX Header "Sorting of RR arrays"
\&\f(CW\*(C`rrsort()\*(C'\fR provides functionality to help you sort \s-1RR\s0 arrays. In most cases
this will give you the answer that you want, but you can specify your
own sorting method by using the \f(CW\*(C`Net::DNS::RR::FOO\->set_rrsort_func()\*(C'\fR
class method. See Net::DNS::RR for details.
.SS "rrsort"
.IX Subsection "rrsort"
.Vb 1
\&    use Net::DNS;
\&
\&    my @sorted = rrsort( $rrtype, $attribute, @rr_array );
.Ve
.PP
\&\f(CW\*(C`rrsort()\*(C'\fR selects all RRs from the input array that are of the type defined
by the first argument. Those RRs are sorted based on the attribute that is
specified as second argument.
.PP
There are a number of RRs for which the sorting function is defined in the
code.
.PP
For instance:
.PP
.Vb 1
\&    my @prioritysorted = rrsort( "SRV", "priority", @rr_array );
.Ve
.PP
returns the \s-1SRV\s0 records sorted from lowest to highest priority and for
equal priorities from highest to lowest weight.
.PP
If the function does not exist then a numerical sort on the attribute
value is performed.
.PP
.Vb 1
\&    my @portsorted = rrsort( "SRV", "port", @rr_array );
.Ve
.PP
If the attribute is not defined then either the \f(CW\*(C`default_sort()\*(C'\fR function or
\&\*(L"canonical sorting\*(R" (as defined by \s-1DNSSEC\s0) will be used.
.PP
\&\f(CW\*(C`rrsort()\*(C'\fR returns a sorted array containing only elements of the specified
\&\s-1RR\s0 type.  Any other \s-1RR\s0 types are silently discarded.
.PP
\&\f(CW\*(C`rrsort()\*(C'\fR returns an empty list when arguments are incorrect.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The following brief examples illustrate some of the features of Net::DNS.
The documentation for individual modules and the demo scripts included
with the distribution provide more extensive examples.
.PP
See Net::DNS::Update for an example of performing dynamic updates.
.SS "Look up host addresses."
.IX Subsection "Look up host addresses."
.Vb 3
\&    use Net::DNS;
\&    my $res   = Net::DNS::Resolver\->new;
\&    my $reply = $res\->search("www.example.com", "A");
\&
\&    if ($reply) {
\&        foreach my $rr ($reply\->answer) {
\&            print $rr\->address, "\en" if $rr\->can("address");
\&        }
\&    } else {
\&        warn "query failed: ", $res\->errorstring, "\en";
\&    }
.Ve
.SS "Find the nameservers for a domain."
.IX Subsection "Find the nameservers for a domain."
.Vb 3
\&    use Net::DNS;
\&    my $res   = Net::DNS::Resolver\->new;
\&    my $reply = $res\->query("example.com", "NS");
\&
\&    if ($reply) {
\&        foreach $rr (grep { $_\->type eq "NS" } $reply\->answer) {
\&            print $rr\->nsdname, "\en";
\&        }
\&    } else {
\&        warn "query failed: ", $res\->errorstring, "\en";
\&    }
.Ve
.SS "Find the \s-1MX\s0 records for a domain."
.IX Subsection "Find the MX records for a domain."
.Vb 4
\&    use Net::DNS;
\&    my $name = "example.com";
\&    my $res  = Net::DNS::Resolver\->new;
\&    my @mx   = mx($res, $name);
\&
\&    if (@mx) {
\&        foreach $rr (@mx) {
\&            print $rr\->preference, "\et", $rr\->exchange, "\en";
\&        }
\&    } else {
\&        warn "Can not find MX records for $name: ", $res\->errorstring, "\en";
\&    }
.Ve
.SS "Print domain \s-1SOA\s0 record in zone file format."
.IX Subsection "Print domain SOA record in zone file format."
.Vb 3
\&    use Net::DNS;
\&    my $res   = Net::DNS::Resolver\->new;
\&    my $reply = $res\->query("example.com", "SOA");
\&
\&    if ($reply) {
\&        foreach my $rr ($reply\->answer) {
\&            $rr\->print;
\&        }
\&    } else {
\&        warn "query failed: ", $res\->errorstring, "\en";
\&    }
.Ve
.SS "Perform a zone transfer and print all the records."
.IX Subsection "Perform a zone transfer and print all the records."
.Vb 4
\&    use Net::DNS;
\&    my $res  = Net::DNS::Resolver\->new;
\&    $res\->tcp_timeout(20);
\&    $res\->nameservers("ns.example.com");
\&
\&    my @zone = $res\->axfr("example.com");
\&
\&    foreach $rr (@zone) {
\&        $rr\->print;
\&    }
\&
\&    warn $res\->errorstring if $res\->errorstring;
.Ve
.SS "Perform a background query and print the reply."
.IX Subsection "Perform a background query and print the reply."
.Vb 5
\&    use Net::DNS;
\&    my $res    = Net::DNS::Resolver\->new;
\&    $res\->udp_timeout(10);
\&    $res\->tcp_timeout(20);
\&    my $socket = $res\->bgsend("host.example.com");
\&
\&    while ( $res\->bgbusy($socket) ) {
\&        # do some work here while waiting for the answer
\&        # ...and some more here
\&    }
\&
\&    my $packet = $res\->bgread($socket);
\&    if ($packet) {
\&        $packet\->print;
\&    } else {
\&        warn "query failed: ", $res\->errorstring, "\en";
\&    }
.Ve
.SH "BUGS"
.IX Header "BUGS"
Net::DNS is slow.
.PP
For other items to be fixed, or if you discover a bug in this
distribution please use the \s-1CPAN\s0 bug reporting system.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c)1997\-2000 Michael Fuhr.
.PP
Portions Copyright (c)2002,2003 Chris Reinhardt.
.PP
Portions Copyright (c)2005 Olaf Kolkman (\s-1RIPE NCC\s0)
.PP
Portions Copyright (c)2006 Olaf Kolkman (NLnet Labs)
.PP
Portions Copyright (c)2014 Dick Franks
.PP
All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation, and that the name of the author not be used in advertising
or publicity pertaining to distribution of the software without specific
prior written permission.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "AUTHOR INFORMATION"
.IX Header "AUTHOR INFORMATION"
Net::DNS is maintained at NLnet Labs (www.nlnetlabs.nl) by Willem Toorop.
.PP
Between 2005 and 2012 Net::DNS was maintained by Olaf Kolkman.
.PP
Between 2002 and 2004 Net::DNS was maintained by Chris Reinhardt.
.PP
Net::DNS was created in 1997 by Michael Fuhr.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::DNS::Resolver, Net::DNS::Question, Net::DNS::RR,
Net::DNS::Packet, Net::DNS::Update,
\&\s-1RFC1035,\s0 <http://www.net\-dns.org/>,
\&\fI\s-1DNS\s0 and \s-1BIND\s0\fR by Paul Albitz & Cricket Liu
