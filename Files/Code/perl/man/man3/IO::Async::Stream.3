.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Async::Stream 3"
.TH IO::Async::Stream 3 "2017-10-01" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"IO::Async::Stream" \- event callbacks and write bufering for a stream
filehandle
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use IO::Async::Stream;
\&
\& use IO::Async::Loop;
\& my $loop = IO::Async::Loop\->new;
\&
\& my $stream = IO::Async::Stream\->new(
\&    read_handle  => \e*STDIN,
\&    write_handle => \e*STDOUT,
\&
\&    on_read => sub {
\&       my ( $self, $buffref, $eof ) = @_;
\&
\&       while( $$buffref =~ s/^(.*\en)// ) {
\&          print "Received a line $1";
\&       }
\&
\&       if( $eof ) {
\&          print "EOF; last partial line is $$buffref\en";
\&       }
\&
\&       return 0;
\&    }
\& );
\&
\& $loop\->add( $stream );
\&
\& $stream\->write( "An initial line here\en" );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This subclass of IO::Async::Handle contains a filehandle that represents
a byte-stream. It provides buffering for both incoming and outgoing data. It
invokes the \f(CW\*(C`on_read\*(C'\fR handler when new data is read from the filehandle. Data
may be written to the filehandle by calling the \f(CW\*(C`write\*(C'\fR method.
.PP
This class is suitable for any kind of filehandle that provides a
possibly-bidirectional reliable byte stream, such as a pipe, \s-1TTY,\s0 or
\&\f(CW\*(C`SOCK_STREAM\*(C'\fR socket (such as \s-1TCP\s0 or a byte-oriented \s-1UNIX\s0 local socket). For
datagram or raw message-based sockets (such as \s-1UDP\s0) see instead
IO::Async::Socket.
.SH "EVENTS"
.IX Header "EVENTS"
The following events are invoked, either using subclass methods or \s-1CODE\s0
references in parameters:
.ie n .SS "$ret = on_read \e$buffer, $eof"
.el .SS "\f(CW$ret\fP = on_read \e$buffer, \f(CW$eof\fP"
.IX Subsection "$ret = on_read $buffer, $eof"
Invoked when more data is available in the internal receiving buffer.
.PP
The first argument is a reference to a plain perl string. The code should
inspect and remove any data it likes, but is not required to remove all, or
indeed any of the data. Any data remaining in the buffer will be preserved for
the next call, the next time more data is received from the handle.
.PP
In this way, it is easy to implement code that reads records of some form when
completed, but ignores partially-received records, until all the data is
present. If the handler is confident no more useful data remains, it should
return \f(CW0\fR. If not, it should return \f(CW1\fR, and the handler will be called
again. This makes it easy to implement code that handles multiple incoming
records at the same time. See the examples at the end of this documentation
for more detail.
.PP
The second argument is a scalar indicating whether the stream has reported an
end-of-file (\s-1EOF\s0) condition. A reference to the buffer is passed to the
handler in the usual way, so it may inspect data contained in it. Once the
handler returns a false value, it will not be called again, as the handle is
now at \s-1EOF\s0 and no more data can arrive.
.PP
The \f(CW\*(C`on_read\*(C'\fR code may also dynamically replace itself with a new callback
by returning a \s-1CODE\s0 reference instead of \f(CW0\fR or \f(CW1\fR. The original callback
or method that the object first started with may be restored by returning
\&\f(CW\*(C`undef\*(C'\fR. Whenever the callback is changed in this way, the new code is called
again; even if the read buffer is currently empty. See the examples at the end
of this documentation for more detail.
.PP
The \f(CW\*(C`push_on_read\*(C'\fR method can be used to insert new, temporary handlers that
take precedence over the global \f(CW\*(C`on_read\*(C'\fR handler. This event is only used if
there are no further pending handlers created by \f(CW\*(C`push_on_read\*(C'\fR.
.SS "on_read_eof"
.IX Subsection "on_read_eof"
Optional. Invoked when the read handle indicates an end-of-file (\s-1EOF\s0)
condition. If there is any data in the buffer still to be processed, the
\&\f(CW\*(C`on_read\*(C'\fR event will be invoked first, before this one.
.SS "on_write_eof"
.IX Subsection "on_write_eof"
Optional. Invoked when the write handle indicates an end-of-file (\s-1EOF\s0)
condition. Note that this condition can only be detected after a \f(CW\*(C`write\*(C'\fR
syscall returns the \f(CW\*(C`EPIPE\*(C'\fR error. If there is no data pending to be written
then it will not be detected yet.
.ie n .SS "on_read_error $errno"
.el .SS "on_read_error \f(CW$errno\fP"
.IX Subsection "on_read_error $errno"
Optional. Invoked when the \f(CW\*(C`sysread\*(C'\fR method on the read handle fails.
.ie n .SS "on_write_error $errno"
.el .SS "on_write_error \f(CW$errno\fP"
.IX Subsection "on_write_error $errno"
Optional. Invoked when the \f(CW\*(C`syswrite\*(C'\fR method on the write handle fails.
.PP
The \f(CW\*(C`on_read_error\*(C'\fR and \f(CW\*(C`on_write_error\*(C'\fR handlers are passed the value of
\&\f(CW$!\fR at the time the error occurred. (The \f(CW$!\fR variable itself, by its
nature, may have changed from the original error by the time this handler
runs so it should always use the value passed in).
.PP
If an error occurs when the corresponding error callback is not supplied, and
there is not a handler for it, then the \f(CW\*(C`close\*(C'\fR method is called instead.
.ie n .SS "on_read_high_watermark $length"
.el .SS "on_read_high_watermark \f(CW$length\fP"
.IX Subsection "on_read_high_watermark $length"
.ie n .SS "on_read_low_watermark $length"
.el .SS "on_read_low_watermark \f(CW$length\fP"
.IX Subsection "on_read_low_watermark $length"
Optional. Invoked when the read buffer grows larger than the high watermark
or smaller than the low watermark respectively. These are edge-triggered
events; they will only be triggered once per crossing, not continuously while
the buffer remains above or below the given limit.
.PP
If these event handlers are not defined, the default behaviour is to disable
read-ready notifications if the read buffer grows larger than the high
watermark (so as to avoid it growing arbitrarily if nothing is consuming it),
and re-enable notifications again once something has read enough to cause it to
drop. If these events are overridden, the overriding code will have to perform
this behaviour if required, by using
.PP
.Vb 1
\& $self\->want_readready_for_read(...)
.Ve
.SS "on_outgoing_empty"
.IX Subsection "on_outgoing_empty"
Optional. Invoked when the writing data buffer becomes empty.
.SS "on_writeable_start"
.IX Subsection "on_writeable_start"
.SS "on_writeable_stop"
.IX Subsection "on_writeable_stop"
Optional. These two events inform when the filehandle becomes writeable, and
when it stops being writeable. \f(CW\*(C`on_writeable_start\*(C'\fR is invoked by the
\&\f(CW\*(C`on_write_ready\*(C'\fR event if previously it was known to be not writeable.
\&\f(CW\*(C`on_writeable_stop\*(C'\fR is invoked after a \f(CW\*(C`syswrite\*(C'\fR operation fails with
\&\f(CW\*(C`EAGAIN\*(C'\fR or \f(CW\*(C`EWOULDBLOCK\*(C'\fR. These two events track the writeability state,
and ensure that only state change cause events to be invoked. A stream starts
off being presumed writeable, so the first of these events to be observed will
be \f(CW\*(C`on_writeable_stop\*(C'\fR.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following named parameters may be passed to \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`configure\*(C'\fR:
.SS "read_handle => \s-1IO\s0"
.IX Subsection "read_handle => IO"
The \s-1IO\s0 handle to read from. Must implement \f(CW\*(C`fileno\*(C'\fR and \f(CW\*(C`sysread\*(C'\fR methods.
.SS "write_handle => \s-1IO\s0"
.IX Subsection "write_handle => IO"
The \s-1IO\s0 handle to write to. Must implement \f(CW\*(C`fileno\*(C'\fR and \f(CW\*(C`syswrite\*(C'\fR methods.
.SS "handle => \s-1IO\s0"
.IX Subsection "handle => IO"
Shortcut to specifying the same \s-1IO\s0 handle for both of the above.
.SS "on_read => \s-1CODE\s0"
.IX Subsection "on_read => CODE"
.SS "on_read_error => \s-1CODE\s0"
.IX Subsection "on_read_error => CODE"
.SS "on_outgoing_empty => \s-1CODE\s0"
.IX Subsection "on_outgoing_empty => CODE"
.SS "on_write_error => \s-1CODE\s0"
.IX Subsection "on_write_error => CODE"
.SS "on_writeable_start => \s-1CODE\s0"
.IX Subsection "on_writeable_start => CODE"
.SS "on_writeable_stop => \s-1CODE\s0"
.IX Subsection "on_writeable_stop => CODE"
\&\s-1CODE\s0 references for event handlers.
.SS "autoflush => \s-1BOOL\s0"
.IX Subsection "autoflush => BOOL"
Optional. If true, the \f(CW\*(C`write\*(C'\fR method will attempt to write data to the
operating system immediately, without waiting for the loop to indicate the
filehandle is write-ready. This is useful, for example, on streams that should
contain up-to-date logging or console information.
.PP
It currently defaults to false for any file handle, but future versions of
IO::Async may enable this by default on \s-1STDOUT\s0 and \s-1STDERR.\s0
.SS "read_len => \s-1INT\s0"
.IX Subsection "read_len => INT"
Optional. Sets the buffer size for \f(CW\*(C`read\*(C'\fR calls. Defaults to 8 KiBytes.
.SS "read_all => \s-1BOOL\s0"
.IX Subsection "read_all => BOOL"
Optional. If true, attempt to read as much data from the kernel as possible
when the handle becomes readable. By default this is turned off, meaning at
most one fixed-size buffer is read. If there is still more data in the
kernel's buffer, the handle will still be readable, and will be read from
again.
.PP
This behaviour allows multiple streams and sockets to be multiplexed
simultaneously, meaning that a large bulk transfer on one cannot starve other
filehandles of processing time. Turning this option on may improve bulk data
transfer rate, at the risk of delaying or stalling processing on other
filehandles.
.SS "write_len => \s-1INT\s0"
.IX Subsection "write_len => INT"
Optional. Sets the buffer size for \f(CW\*(C`write\*(C'\fR calls. Defaults to 8 KiBytes.
.SS "write_all => \s-1BOOL\s0"
.IX Subsection "write_all => BOOL"
Optional. Analogous to the \f(CW\*(C`read_all\*(C'\fR option, but for writing. When
\&\f(CW\*(C`autoflush\*(C'\fR is enabled, this option only affects deferred writing if the
initial attempt failed due to buffer space.
.SS "read_high_watermark => \s-1INT\s0"
.IX Subsection "read_high_watermark => INT"
.SS "read_low_watermark => \s-1INT\s0"
.IX Subsection "read_low_watermark => INT"
Optional. If defined, gives a way to implement flow control or other
behaviours that depend on the size of Stream's read buffer.
.PP
If after more data is read from the underlying filehandle the read buffer is
now larger than the high watermark, the \f(CW\*(C`on_read_high_watermark\*(C'\fR event is
triggered (which, by default, will disable read-ready notifications and pause
reading from the filehandle).
.PP
If after data is consumed by an \f(CW\*(C`on_read\*(C'\fR handler the read buffer is now
smaller than the low watermark, the \f(CW\*(C`on_read_low_watermark\*(C'\fR event is
triggered (which, by default, will re-enable read-ready notifications and
resume reading from the filehandle). For to be possible, the read handler
would have to be one added by the \f(CW\*(C`push_on_read\*(C'\fR method or one of the
Future-returning \f(CW\*(C`read_*\*(C'\fR methods.
.PP
By default these options are not defined, so this behaviour will not happen.
\&\f(CW\*(C`read_low_watermark\*(C'\fR may not be set to a larger value than
\&\f(CW\*(C`read_high_watermark\*(C'\fR, but it may be set to a smaller value, creating a
hysteresis region. If either option is defined then both must be.
.PP
If these options are used with the default event handlers, be careful not to
cause deadlocks by having a high watermark sufficiently low that a single
\&\f(CW\*(C`on_read\*(C'\fR invocation might not consider it finished yet.
.SS "reader => STRING|CODE"
.IX Subsection "reader => STRING|CODE"
.SS "writer => STRING|CODE"
.IX Subsection "writer => STRING|CODE"
Optional. If defined, gives the name of a method or a \s-1CODE\s0 reference to use
to implement the actual reading from or writing to the filehandle. These will
be invoked as
.PP
.Vb 2
\& $stream\->reader( $read_handle, $buffer, $len )
\& $stream\->writer( $write_handle, $buffer, $len )
.Ve
.PP
Each is expected to modify the passed buffer; \f(CW\*(C`reader\*(C'\fR by appending to it,
\&\f(CW\*(C`writer\*(C'\fR by removing a prefix from it. Each is expected to return a true
value on success, zero on \s-1EOF,\s0 or \f(CW\*(C`undef\*(C'\fR with \f(CW$!\fR set for errors. If not
provided, they will be substituted by implenentations using \f(CW\*(C`sysread\*(C'\fR and
\&\f(CW\*(C`syswrite\*(C'\fR on the underlying handle, respectively.
.SS "close_on_read_eof => \s-1BOOL\s0"
.IX Subsection "close_on_read_eof => BOOL"
Optional. Usually true, but if set to a false value then the stream will not
be \f(CW\*(C`close\*(C'\fRd when an \s-1EOF\s0 condition occurs on read. This is normally not useful
as at that point the underlying stream filehandle is no longer useable, but it
may be useful for reading regular files, or interacting with \s-1TTY\s0 devices.
.SS "encoding => \s-1STRING\s0"
.IX Subsection "encoding => STRING"
If supplied, sets the name of encoding of the underlying stream. If an
encoding is set, then the \f(CW\*(C`write\*(C'\fR method will expect to receive Unicode
strings and encodes them into bytes, and incoming bytes will be decoded into
Unicode strings for the \f(CW\*(C`on_read\*(C'\fR event.
.PP
If an encoding is not supplied then \f(CW\*(C`write\*(C'\fR and \f(CW\*(C`on_read\*(C'\fR will work in byte
strings.
.PP
\&\fI\s-1IMPORTANT NOTE:\s0\fR in order to handle reads of \s-1UTF\-8\s0 content or other
multibyte encodings, the code implementing the \f(CW\*(C`on_read\*(C'\fR event uses a feature
of Encode; the \f(CW\*(C`STOP_AT_PARTIAL\*(C'\fR flag. While this flag has existed for a
while and is used by the \f(CW\*(C`:encoding\*(C'\fR PerlIO layer itself for similar
purposes, the flag is not officially documented by the \f(CW\*(C`Encode\*(C'\fR module. In
principle this undocumented feature could be subject to change, in practice I
believe it to be reasonably stable.
.PP
This note applies only to the \f(CW\*(C`on_read\*(C'\fR event; data written using the
\&\f(CW\*(C`write\*(C'\fR method does not rely on any undocumented features of \f(CW\*(C`Encode\*(C'\fR.
.PP
If a read handle is given, it is required that either an \f(CW\*(C`on_read\*(C'\fR callback
reference is configured, or that the object provides an \f(CW\*(C`on_read\*(C'\fR method. It
is optional whether either is true for \f(CW\*(C`on_outgoing_empty\*(C'\fR; if neither is
supplied then no action will be taken when the writing buffer becomes empty.
.PP
An \f(CW\*(C`on_read\*(C'\fR handler may be supplied even if no read handle is yet given, to
be used when a read handle is eventually provided by the \f(CW\*(C`set_handles\*(C'\fR
method.
.PP
This condition is checked at the time the object is added to a Loop; it is
allowed to create a \f(CW\*(C`IO::Async::Stream\*(C'\fR object with a read handle but without
a \f(CW\*(C`on_read\*(C'\fR handler, provided that one is later given using \f(CW\*(C`configure\*(C'\fR
before the stream is added to its containing Loop, either directly or by being
a child of another Notifier already in a Loop, or added to one.
.SH "METHODS"
.IX Header "METHODS"
The following methods documented with a trailing call to \f(CW\*(C`\->get\*(C'\fR return
Future instances.
.SS "want_readready_for_read"
.IX Subsection "want_readready_for_read"
.SS "want_readready_for_write"
.IX Subsection "want_readready_for_write"
.Vb 1
\&   $stream\->want_readready_for_read( $set )
\&
\&   $stream\->want_readready_for_write( $set )
.Ve
.PP
Mutators for the \f(CW\*(C`want_readready\*(C'\fR property on IO::Async::Handle, which
control whether the \f(CW\*(C`read\*(C'\fR or \f(CW\*(C`write\*(C'\fR behaviour should be continued once the
filehandle becomes ready for read.
.PP
Normally, \f(CW\*(C`want_readready_for_read\*(C'\fR is always true (though the read watermark
behaviour can modify it), and \f(CW\*(C`want_readready_for_write\*(C'\fR is not used.
However, if a custom \f(CW\*(C`writer\*(C'\fR function is provided, it may find this useful
for being invoked again if it cannot proceed with a write operation until the
filehandle becomes readable (such as during transport negotiation or \s-1SSL\s0 key
management, for example).
.SS "want_writeready_for_read"
.IX Subsection "want_writeready_for_read"
.SS "want_writeready_for_write"
.IX Subsection "want_writeready_for_write"
.Vb 1
\&   $stream\->want_writeready_for_write( $set )
\&
\&   $stream\->want_writeready_for_read( $set )
.Ve
.PP
Mutators for the \f(CW\*(C`want_writeready\*(C'\fR property on IO::Async::Handle, which
control whether the \f(CW\*(C`write\*(C'\fR or \f(CW\*(C`read\*(C'\fR behaviour should be continued once the
filehandle becomes ready for write.
.PP
Normally, \f(CW\*(C`want_writeready_for_write\*(C'\fR is managed by the \f(CW\*(C`write\*(C'\fR method and
associated flushing, and \f(CW\*(C`want_writeready_for_read\*(C'\fR is not used. However, if
a custom \f(CW\*(C`reader\*(C'\fR function is provided, it may find this useful for being
invoked again if it cannot proceed with a read operation until the filehandle
becomes writable (such as during transport negotiation or \s-1SSL\s0 key management,
for example).
.SS "close"
.IX Subsection "close"
.Vb 1
\&   $stream\->close
.Ve
.PP
A synonym for \f(CW\*(C`close_when_empty\*(C'\fR. This should not be used when the deferred
wait behaviour is required, as the behaviour of \f(CW\*(C`close\*(C'\fR may change in a
future version of IO::Async. Instead, call \f(CW\*(C`close_when_empty\*(C'\fR directly.
.SS "close_when_empty"
.IX Subsection "close_when_empty"
.Vb 1
\&   $stream\->close_when_empty
.Ve
.PP
If the write buffer is empty, this method calls \f(CW\*(C`close\*(C'\fR on the underlying \s-1IO\s0
handles, and removes the stream from its containing loop. If the write buffer
still contains data, then this is deferred until the buffer is empty. This is
intended for \*(L"write-then-close\*(R" one-shot streams.
.PP
.Vb 2
\& $stream\->write( "Here is my final data\en" );
\& $stream\->close_when_empty;
.Ve
.PP
Because of this deferred nature, it may not be suitable for error handling.
See instead the \f(CW\*(C`close_now\*(C'\fR method.
.SS "close_now"
.IX Subsection "close_now"
.Vb 1
\&   $stream\->close_now
.Ve
.PP
This method immediately closes the underlying \s-1IO\s0 handles and removes the
stream from the containing loop. It will not wait to flush the remaining data
in the write buffer.
.SS "is_read_eof"
.IX Subsection "is_read_eof"
.SS "is_write_eof"
.IX Subsection "is_write_eof"
.Vb 1
\&   $eof = $stream\->is_read_eof
\&
\&   $eof = $stream\->is_write_eof
.Ve
.PP
Returns true after an \s-1EOF\s0 condition is reported on either the read or the
write handle, respectively.
.SS "write"
.IX Subsection "write"
.Vb 1
\&   $stream\->write( $data, %params )
.Ve
.PP
This method adds data to the outgoing data queue, or writes it immediately,
according to the \f(CW\*(C`autoflush\*(C'\fR parameter.
.PP
If the \f(CW\*(C`autoflush\*(C'\fR option is set, this method will try immediately to write
the data to the underlying filehandle. If this completes successfully then it
will have been written by the time this method returns. If it fails to write
completely, then the data is queued as if \f(CW\*(C`autoflush\*(C'\fR were not set, and will
be flushed as normal.
.PP
\&\f(CW$data\fR can either be a plain string, a Future, or a \s-1CODE\s0 reference. If it
is a plain string it is written immediately. If it is not, its value will be
used to generate more \f(CW$data\fR values, eventually leading to strings to be
written.
.PP
If \f(CW$data\fR is a \f(CW\*(C`Future\*(C'\fR, the Stream will wait until it is ready, and take
the single value it yields.
.PP
If \f(CW$data\fR is a \s-1CODE\s0 reference, it will be repeatedly invoked to generate new
values. Each time the filehandle is ready to write more data to it, the
function is invoked. Once the function has finished generating data it should
return undef. The function is passed the Stream object as its first argument.
.PP
It is allowed that \f(CW\*(C`Future\*(C'\fRs yield \s-1CODE\s0 references, or \s-1CODE\s0 references return
\&\f(CW\*(C`Future\*(C'\fRs, as well as plain strings.
.PP
For example, to stream the contents of an existing opened filehandle:
.PP
.Vb 1
\& open my $fileh, "<", $path or die "Cannot open $path \- $!";
\&
\& $stream\->write( sub {
\&    my ( $stream ) = @_;
\&
\&    sysread $fileh, my $buffer, 8192 or return;
\&    return $buffer;
\& } );
.Ve
.PP
Takes the following optional named parameters in \f(CW%params\fR:
.IP "write_len => \s-1INT\s0" 8
.IX Item "write_len => INT"
Overrides the \f(CW\*(C`write_len\*(C'\fR parameter for the data written by this call.
.IP "on_write => \s-1CODE\s0" 8
.IX Item "on_write => CODE"
A \s-1CODE\s0 reference which will be invoked after every successful \f(CW\*(C`syswrite\*(C'\fR
operation on the underlying filehandle. It will be passed the number of bytes
that were written by this call, which may not be the entire length of the
buffer \- if it takes more than one \f(CW\*(C`syscall\*(C'\fR operation to empty the buffer
then this callback will be invoked multiple times.
.Sp
.Vb 1
\& $on_write\->( $stream, $len )
.Ve
.IP "on_flush => \s-1CODE\s0" 8
.IX Item "on_flush => CODE"
A \s-1CODE\s0 reference which will be invoked once the data queued by this \f(CW\*(C`write\*(C'\fR
call has been flushed. This will be invoked even if the buffer itself is not
yet empty; if more data has been queued since the call.
.Sp
.Vb 1
\& $on_flush\->( $stream )
.Ve
.IP "on_error => \s-1CODE\s0" 8
.IX Item "on_error => CODE"
A \s-1CODE\s0 reference which will be invoked if a \f(CW\*(C`syswrite\*(C'\fR error happens while
performing this write. Invoked as for the \f(CW\*(C`Stream\*(C'\fR's \f(CW\*(C`on_write_error\*(C'\fR event.
.Sp
.Vb 1
\& $on_error\->( $stream, $errno )
.Ve
.PP
If the object is not yet a member of a loop and doesn't yet have a
\&\f(CW\*(C`write_handle\*(C'\fR, then calls to the \f(CW\*(C`write\*(C'\fR method will simply queue the data
and return. It will be flushed when the object is added to the loop.
.PP
If \f(CW$data\fR is a defined but empty string, the write is still queued, and the
\&\f(CW\*(C`on_flush\*(C'\fR continuation will be invoked, if supplied. This can be used to
obtain a marker, to invoke some code once the output queue has been flushed up
to this point.
.SS "write (scalar)"
.IX Subsection "write (scalar)"
.Vb 1
\&   $stream\->write( ... )\->get
.Ve
.PP
If called in non-void context, this method returns a Future which will
complete (with no value) when the write operation has been flushed. This may
be used as an alternative to, or combined with, the \f(CW\*(C`on_flush\*(C'\fR callback.
.SS "push_on_read"
.IX Subsection "push_on_read"
.Vb 1
\&   $stream\->push_on_read( $on_read )
.Ve
.PP
Pushes a new temporary \f(CW\*(C`on_read\*(C'\fR handler to the end of the queue. This queue,
if non-empty, is used to provide \f(CW\*(C`on_read\*(C'\fR event handling code in preference
to using the object's main event handler or method. New handlers can be
supplied at any time, and they will be used in first-in first-out (\s-1FIFO\s0)
order.
.PP
As with the main \f(CW\*(C`on_read\*(C'\fR event handler, each can return a (defined) boolean
to indicate if they wish to be invoked again or not, another \f(CW\*(C`CODE\*(C'\fR reference
to replace themself with, or \f(CW\*(C`undef\*(C'\fR to indicate it is now complete and
should be removed. When a temporary handler returns \f(CW\*(C`undef\*(C'\fR it is shifted
from the queue and the next one, if present, is invoked instead. If there are
no more then the object's main handler is invoked instead.
.SH "FUTURE-RETURNING READ METHODS"
.IX Header "FUTURE-RETURNING READ METHODS"
The following methods all return a Future which will become ready when
enough data has been read by the Stream into its buffer. At this point, the
data is removed from the buffer and given to the \f(CW\*(C`Future\*(C'\fR object to complete
it.
.PP
.Vb 1
\& my $f = $stream\->read_...
\&
\& my ( $string ) = $f\->get;
.Ve
.PP
Unlike the \f(CW\*(C`on_read\*(C'\fR event handlers, these methods don't allow for access to
\&\*(L"partial\*(R" results; they only provide the final result once it is ready.
.PP
If a \f(CW\*(C`Future\*(C'\fR is cancelled before it completes it is removed from the read
queue without consuming any data; i.e. each \f(CW\*(C`Future\*(C'\fR atomically either
completes or is cancelled.
.PP
Since it is possible to use a readable \f(CW\*(C`Stream\*(C'\fR entirely using these
\&\f(CW\*(C`Future\*(C'\fR\-returning methods instead of the \f(CW\*(C`on_read\*(C'\fR event, it may be useful
to configure a trivial return-false event handler to keep it from consuming
any input, and to allow it to be added to a \f(CW\*(C`Loop\*(C'\fR in the first place.
.PP
.Vb 2
\& my $stream = IO::Async::Stream\->new( on_read => sub { 0 }, ... );
\& $loop\->add( $stream );
\&
\& my $f = $stream\->read_...
.Ve
.PP
If a read \s-1EOF\s0 or error condition happens while there are read \f(CW\*(C`Future\*(C'\fRs
pending, they are all completed. In the case of a read \s-1EOF,\s0 they are done with
\&\f(CW\*(C`undef\*(C'\fR; in the case of a read error they are failed using the \f(CW$!\fR error
value as the failure.
.PP
.Vb 1
\& $f\->fail( $message, sysread => $! )
.Ve
.PP
If a read \s-1EOF\s0 condition happens to the currently-processing read \f(CW\*(C`Future\*(C'\fR, it
will return a partial result. The calling code can detect this by the fact
that the returned data is not complete according to the specification (too
short in \f(CW\*(C`read_exactly\*(C'\fR's case, or lacking the ending pattern in
\&\f(CW\*(C`read_until\*(C'\fR's case). Additionally, each \f(CW\*(C`Future\*(C'\fR will yield the \f(CW$eof\fR
value in its results.
.PP
.Vb 1
\& my ( $string, $eof ) = $f\->get;
.Ve
.SS "read_atmost"
.IX Subsection "read_atmost"
.SS "read_exactly"
.IX Subsection "read_exactly"
.Vb 1
\&   ( $string, $eof ) = $stream\->read_atmost( $len )\->get
\&
\&   ( $string, $eof ) = $stream\->read_exactly( $len )\->get
.Ve
.PP
Completes the \f(CW\*(C`Future\*(C'\fR when the read buffer contains \f(CW$len\fR or more
characters of input. \f(CW\*(C`read_atmost\*(C'\fR will also complete after the first
invocation of \f(CW\*(C`on_read\*(C'\fR, even if fewer characters are available, whereas
\&\f(CW\*(C`read_exactly\*(C'\fR will wait until at least \f(CW$len\fR are available.
.SS "read_until"
.IX Subsection "read_until"
.Vb 1
\&   ( $string, $eof ) = $stream\->read_until( $end )\->get
.Ve
.PP
Completes the \f(CW\*(C`Future\*(C'\fR when the read buffer contains a match for \f(CW$end\fR,
which may either be a plain string or a compiled \f(CW\*(C`Regexp\*(C'\fR reference. Yields
the prefix of the buffer up to and including this match.
.SS "read_until_eof"
.IX Subsection "read_until_eof"
.Vb 1
\&   ( $string, $eof ) = $stream\->read_until_eof\->get
.Ve
.PP
Completes the \f(CW\*(C`Future\*(C'\fR when the stream is eventually closed at \s-1EOF,\s0 and
yields all of the data that was available.
.SH "UTILITY CONSTRUCTORS"
.IX Header "UTILITY CONSTRUCTORS"
.SS "new_for_stdin"
.IX Subsection "new_for_stdin"
.SS "new_for_stdout"
.IX Subsection "new_for_stdout"
.SS "new_for_stdio"
.IX Subsection "new_for_stdio"
.Vb 1
\&   $stream = IO::Async::Stream\->new_for_stdin
\&
\&   $stream = IO::Async::Stream\->new_for_stdout
\&
\&   $stream = IO::Async::Stream\->new_for_stdio
.Ve
.PP
Return a \f(CW\*(C`IO::Async::Stream\*(C'\fR object preconfigured with the correct
\&\f(CW\*(C`read_handle\*(C'\fR, \f(CW\*(C`write_handle\*(C'\fR or both.
.SS "connect"
.IX Subsection "connect"
.Vb 1
\&   $future = $stream\->connect( %args )
.Ve
.PP
A convenient wrapper for calling the \f(CW\*(C`connect\*(C'\fR method on the underlying
IO::Async::Loop object, passing the \f(CW\*(C`socktype\*(C'\fR hint as \f(CW\*(C`stream\*(C'\fR if not
otherwise supplied.
.SH "DEBUGGING FLAGS"
.IX Header "DEBUGGING FLAGS"
The following flags in \f(CW\*(C`IO_ASYNC_DEBUG_FLAGS\*(C'\fR enable extra logging:
.ie n .IP """Sr""" 4
.el .IP "\f(CWSr\fR" 4
.IX Item "Sr"
Log byte buffers as data is read from a Stream
.ie n .IP """Sw""" 4
.el .IP "\f(CWSw\fR" 4
.IX Item "Sw"
Log byte buffers as data is written to a Stream
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.ie n .SS "A line-based ""on_read"" method"
.el .SS "A line-based \f(CWon_read\fP method"
.IX Subsection "A line-based on_read method"
The following \f(CW\*(C`on_read\*(C'\fR method accepts incoming \f(CW\*(C`\en\*(C'\fR\-terminated lines and
prints them to the program's \f(CW\*(C`STDOUT\*(C'\fR stream.
.PP
.Vb 4
\& sub on_read
\& {
\&    my $self = shift;
\&    my ( $buffref, $eof ) = @_;
\&
\&    while( $$buffref =~ s/^(.*\en)// ) {
\&       print "Received a line: $1";
\&    }
\&
\&    return 0;
\& }
.Ve
.PP
Because a reference to the buffer itself is passed, it is simple to use a
\&\f(CW\*(C`s///\*(C'\fR regular expression on the scalar it points at, to both check if data
is ready (i.e. a whole line), and to remove it from the buffer. If no data is
available then \f(CW0\fR is returned, to indicate it should not be tried again. If
a line was successfully extracted, then \f(CW1\fR is returned, to indicate it
should try again in case more lines exist in the buffer.
.SS "Reading binary data"
.IX Subsection "Reading binary data"
This \f(CW\*(C`on_read\*(C'\fR method accepts incoming records in 16\-byte chunks, printing
each one.
.PP
.Vb 3
\& sub on_read
\& {
\&    my ( $self, $buffref, $eof ) = @_;
\&
\&    if( length $$buffref >= 16 ) {
\&       my $record = substr( $$buffref, 0, 16, "" );
\&       print "Received a 16\-byte record: $record\en";
\&
\&       return 1;
\&    }
\&
\&    if( $eof and length $$buffref ) {
\&       print "EOF: a partial record still exists\en";
\&    }
\&
\&    return 0;
\& }
.Ve
.PP
The 4\-argument form of \f(CW\*(C`substr()\*(C'\fR extracts the 16\-byte record from the buffer
and assigns it to the \f(CW$record\fR variable, if there was enough data in the
buffer to extract it.
.PP
A lot of protocols use a fixed-size header, followed by a variable-sized body
of data, whose size is given by one of the fields of the header. The following
\&\f(CW\*(C`on_read\*(C'\fR method extracts messages in such a protocol.
.PP
.Vb 3
\& sub on_read
\& {
\&    my ( $self, $buffref, $eof ) = @_;
\&
\&    return 0 unless length $$buffref >= 8; # "N n n" consumes 8 bytes
\&
\&    my ( $len, $x, $y ) = unpack "N n n", $$buffref;
\&
\&    return 0 unless length $$buffref >= 8 + $len;
\&
\&    substr( $$buffref, 0, 8, "" );
\&    my $data = substr( $$buffref, 0, $len, "" );
\&
\&    print "A record with values x=$x y=$y\en";
\&
\&    return 1;
\& }
.Ve
.PP
In this example, the header is \f(CW\*(C`unpack()\*(C'\fRed first, to extract the body
length, and then the body is extracted. If the buffer does not have enough
data yet for a complete message then \f(CW0\fR is returned, and the buffer is left
unmodified for next time. Only when there are enough bytes in total does it
use \f(CW\*(C`substr()\*(C'\fR to remove them.
.ie n .SS "Dynamic replacement of ""on_read"""
.el .SS "Dynamic replacement of \f(CWon_read\fP"
.IX Subsection "Dynamic replacement of on_read"
Consider the following protocol (inspired by \s-1IMAP\s0), which consists of
\&\f(CW\*(C`\en\*(C'\fR\-terminated lines that may have an optional data block attached. The
presence of such a data block, as well as its size, is indicated by the line
prefix.
.PP
.Vb 4
\& sub on_read
\& {
\&    my $self = shift;
\&    my ( $buffref, $eof ) = @_;
\&
\&    if( $$buffref =~ s/^DATA (\ed+):(.*)\en// ) {
\&       my $length = $1;
\&       my $line   = $2;
\&
\&       return sub {
\&          my $self = shift;
\&          my ( $buffref, $eof ) = @_;
\&
\&          return 0 unless length $$buffref >= $length;
\&
\&          # Take and remove the data from the buffer
\&          my $data = substr( $$buffref, 0, $length, "" );
\&
\&          print "Received a line $line with some data ($data)\en";
\&
\&          return undef; # Restore the original method
\&       }
\&    }
\&    elsif( $$buffref =~ s/^LINE:(.*)\en// ) {
\&       my $line = $1;
\&
\&       print "Received a line $line with no data\en";
\&
\&       return 1;
\&    }
\&    else {
\&       print STDERR "Unrecognised input\en";
\&       # Handle it somehow
\&    }
\& }
.Ve
.PP
In the case where trailing data is supplied, a new temporary \f(CW\*(C`on_read\*(C'\fR
callback is provided in a closure. This closure captures the \f(CW$length\fR
variable so it knows how much data to expect. It also captures the \f(CW$line\fR
variable so it can use it in the event report. When this method has finished
reading the data, it reports the event, then restores the original method by
returning \f(CW\*(C`undef\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
IO::Handle \- Supply object methods for I/O handles
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
