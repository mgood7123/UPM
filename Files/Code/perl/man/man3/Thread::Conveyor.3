.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Thread::Conveyor 3"
.TH Thread::Conveyor 3 "2010-09-20" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Thread::Conveyor \- transport of any data\-structure between threads
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 0.19.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    use Thread::Conveyor;
\&    my $belt = Thread::Conveyor\->new(
\&     {
\&      maxboxes => 50,
\&      minboxes => 25,
\&      optimize => \*(Aqmemory\*(Aq, # or \*(Aqcpu\*(Aq
\&     }
\&    );
\&
\&    $belt\->put( "foo", ["bar"], {"zoo"} );
\&    my ($foo,$bar,$zoo) = $belt\->take;
\&    my ($foo,$bar,$zoo) = $belt\->take_dontwait;
\&    my ($foo,$bar,$zoo) = $belt\->peek;
\&    my ($foo,$bar,$zoo) = $belt\->peek_dontwait;
\&    my $onbelt = $belt\->onbelt;
\&
\&    my @box = $belt\->clean;
\&    my @box = $belt\->clean_dontwait;
\&    my ($foo,$bar,$zoo) = @{$box[0]};
\&
\&    $belt\->maxboxes( 100 );
\&    $belt\->minboxes( 50 );
\&
\&    $belt\->shutdown;
\&    $belt\->thread;
\&    $belt\->tid;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 1
\&                  *** A note of CAUTION ***
\&
\& This module only functions on Perl versions 5.8.0 and later.
\& And then only when threads are enabled with \-Dusethreads.  It
\& is of no use with any version of Perl before 5.8.0 or without
\& threads enabled.
\&
\&                  *************************
.Ve
.PP
The Thread::Conveyor object is a thread-safe data structure that mimics the
behaviour of a conveyor belt.  One or more worker threads can put boxes with
frozen values and references on one end of the belt to be taken off by one
or more worker threads on the other end of the belt to be thawed and returned.
.PP
A box may consist of any combination of scalars and references to scalars,
arrays (lists) and hashes.  Freezing and thawing is currently done with the
Thread::Serialize module, but that may change in the future.  Objects and
code references are currently \fBnot\fR allowed.
.PP
By default, the maximum number of boxes on the belt is limited to \fB50\fR.
Putting of boxes on the belt is halted if the maximum number of boxes is
exceeded.  This throttling feature was added because it was found that
excessive memory usage could be caused by having the belt growing too large.
Throttling can be disabled if so desired.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "new"
.IX Subsection "new"
.Vb 7
\& $belt = Thread::Conveyor\->new(
\&  {
\&   maxboxes => 50,
\&   minboxes => 25,
\&   optimize => \*(Aqmemory\*(Aq, # or \*(Aqcpu\*(Aq
\&  }
\& );
.Ve
.PP
The \*(L"new\*(R" function creates a new empty belt.  It returns the instantiated
Thread::Conveyor object.
.PP
The input parameter is a reference to a hash.  The following fields are
\&\fBoptional\fR in the hash reference:
.IP "maxboxes" 2
.IX Item "maxboxes"
.Vb 1
\& maxboxes => 50,
\&
\& maxboxes => undef,  # disable throttling
.Ve
.Sp
The \*(L"maxboxes\*(R" field specifies the \fBmaximum\fR number of boxes that can be
sitting on the belt to be handled (throttling).  If a new put would
exceed this amount, putting of boxes will be halted until the number of
boxes waiting to be handled has become at least as low as the amount
specified with the \*(L"minboxes\*(R" field.
.Sp
Fifty boxes will be assumed for the \*(L"maxboxes\*(R" field if it is not specified.
If you do not want to have any throttling, you can specify the value \*(L"undef\*(R"
for the field.  But beware!  If you do not have throttling active, you may
wind up using excessive amounts of memory used for storing all of the boxes
that have not been handled yet.
.Sp
The maxboxes method can be called to change the throttling settings
during the lifetime of the object.
.IP "minboxes" 2
.IX Item "minboxes"
.Vb 1
\& minboxes => 25, # default: maxboxes / 2
.Ve
.Sp
The \*(L"minboxes\*(R" field specifies the \fBminimum\fR number of boxes that can be
waiting on the belt to be handled before the putting of boxes is allowed
again (throttling).
.Sp
If throttling is active and the \*(L"minboxes\*(R" field is not specified, then
half of the \*(L"maxboxes\*(R" value will be assumed.
.Sp
The minboxes method can be called to change the throttling settings
during the lifetime of the object.
.IP "optimize" 2
.IX Item "optimize"
.Vb 1
\& optimize => \*(Aqcpu\*(Aq, # default: depends on Perl version
.Ve
.Sp
The \*(L"optimize\*(R" field specifies which implementation of the belt will be
selected.  Currently there are two choices: 'cpu' and 'memory'.  For Perl
5.8.0 the default is \*(L"memory\*(R".  For higher versions of perl, the default
optimization is \*(L"cpu\*(R".  The reason for this was that Perl 5.8.0 has a severe
memory leak with shared arrays, which is what is being used with the \*(L"cpu\*(R"
optimization.
.Sp
You can call the class method optimize to change the default optimization.
.SS "optimize"
.IX Subsection "optimize"
.Vb 1
\& Thread::Conveyor\->optimize( \*(Aqcpu\*(Aq );
\&
\& $optimize = Thread::Conveyor\->optimize;
.Ve
.PP
The \*(L"optimize\*(R" class method allows you to specify the default optimization
type that will be used if no \*(L"optimize\*(R" field has been explicitely specified
with a call to new.  It returns the current default type of optimization.
.PP
Currently two types of optimization can be selected:
.IP "memory" 2
.IX Item "memory"
Attempt to use as little memory as possible.  Currently, this is achieved by
starting a seperate thread which hosts an unshared array.  This uses the
\&\*(L"Thread::Conveyor::Thread\*(R" sub-class.
.IP "cpu" 2
.IX Item "cpu"
Attempt to use as little \s-1CPU\s0 as possible.  Currently, this is achieved by
using a shared array (using the \*(L"Thread::Conveyor::Array\*(R" sub-class),
encapsulated in a hash reference if throttling is activated (then also using
the \*(L"Thread::Conveyor::Throttled\*(R" sub-class).
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
The following methods operate on the instantiated Thread::Conveyor object.
.SS "put"
.IX Subsection "put"
.Vb 1
\& $belt\->put( \*(Aqstring\*(Aq,$scalar,[],{} );
.Ve
.PP
The \*(L"put\*(R" method freezes all the specified parameters together in a box and
puts the box on the beginning of the belt.
.SS "take"
.IX Subsection "take"
.Vb 1
\& ($string,$scalar,$listref,$hashref) = $belt\->take;
.Ve
.PP
The \*(L"take\*(R" method waits for a box to become available at the end of the
belt, removes that box from the belt, thaws the contents of the box and
returns the resulting values and references.
.SS "take_dontwait"
.IX Subsection "take_dontwait"
.Vb 1
\& ($string,$scalar,$listref,$hashref) = $belt\->take_dontwait;
.Ve
.PP
The \*(L"take_dontwait\*(R" method, like the take method, removes a box from the
end of the belt if there is a box waiting at the end of the belt.  If there
is \fBno\fR box available, then the \*(L"take_dontwait\*(R" method will return
immediately with an empty list.  Otherwise the contents of the box will be
thawed and the resulting values and references will be returned.
.SS "clean"
.IX Subsection "clean"
.Vb 2
\& @box = $belt\->clean;
\& ($string,$scalar,$listref,$hashref) = @{$box[0]};
.Ve
.PP
The \*(L"clean\*(R" method waits for one or more boxes to become available at the
end of the belt, removes \fBall\fR boxes from the belt, thaws the contents of
the boxes and returns the resulting values and references as an array
where each element is a reference to the original contents of each box.
.SS "clean_dontwait"
.IX Subsection "clean_dontwait"
.Vb 2
\& @box = $belt\->clean_dontwait;
\& ($string,$scalar,$listref,$hashref) = @{$box[0]};
.Ve
.PP
The \*(L"clean_dontwait\*(R" method, like the clean method, removes all boxes
from the end of the belt if there are any boxes waiting at the end of the
belt.  If there are \fBno\fR boxes available, then the \*(L"clean_dontwait\*(R" method
will return immediately with an empty list.  Otherwise the contents of the
boxes will be thawed and the resulting values and references will be
returned an an array where each element is a reference to the original
contents of each box.
.SS "peek"
.IX Subsection "peek"
.Vb 1
\& ($string,$scalar,$listref,$hashref) = $belt\->peek;
\&
\& @lookahead = $belt\->peek( $index );
.Ve
.PP
The \*(L"peek\*(R" method waits for a box to become availabe at the end of the
belt, but does \fBnot\fR remove it from the belt like the take method does.
It does however thaw the contents and returns the resulting values and
references.
.PP
For advanced, and mostly internal, usages, it is possible to specify the
ordinal number of the box in which to peek.
.PP
Please note that there is \fBno\fR guarantee that \*(L"take\*(R" will give you the
same data as which is returned with this method, as any other thread can
have taken the boxes off of the belt in the meantime.
.SS "peek_dontwait"
.IX Subsection "peek_dontwait"
.Vb 1
\& ($string,$scalar,$listref,$hashref) = $belt\->peek_dontwait;
\&
\& @lookahead = $belt\->peek_dontwait( $index );
.Ve
.PP
The \*(L"peek_dontwait\*(R" method is like the take_dontwait method, but does
\&\fBnot\fR remove the box from the belt if there is one available.  If there
is a box available, then the contents of the box will be thawed and the
resulting values and references are returned.  An empty list will be
returned if there was no box available at the end of the belt.
.PP
For advanced, and mostly internal, usages, it is possible to specify the
ordinal number of the box in which to peek.
.PP
Please note that there is \fBno\fR guarantee that \*(L"take\*(R" will give you the
same data as which is returned with this method, as any other thread can
have taken the boxes off of the belt in the meantime.
.SS "onbelt"
.IX Subsection "onbelt"
.Vb 1
\& $onbelt = $belt\->onbelt;
.Ve
.PP
The \*(L"onbelt\*(R" method returns the number of boxes that are still in the belt.
.SS "maxboxes"
.IX Subsection "maxboxes"
.Vb 2
\& $belt\->maxboxes( 100 );
\& $maxboxes = $belt\->maxboxes;
.Ve
.PP
The \*(L"maxboxes\*(R" method returns the maximum number of boxes that can be on the
belt before throttling sets in.  The input value, if specified, specifies the
new maximum number of boxes that may be on the belt.  Throttling will be
switched off if the value \fBundef\fR is specified.
.PP
Specifying the \*(L"maxboxes\*(R" field when creating the object with new is
equivalent to calling this method.
.PP
The minboxes method can be called to specify the minimum number of boxes
that must be on the belt before the putting of boxes is allowed again after
reaching the maximum number of boxes.  By default, half of the \*(L"maxboxes\*(R"
value is assumed.
.SS "minboxes"
.IX Subsection "minboxes"
.Vb 2
\& $belt\->minboxes( 50 );
\& $minboxes = $belt\->minboxes;
.Ve
.PP
The \*(L"minboxes\*(R" method returns the minimum number of boxes that must be on the
belt before the putting of boxes is allowed again after reaching the maximum
number of boxes.  The input value, if specified, specifies the new minimum
number of boxes that must be on the belt.
.PP
Specifying the \*(L"minboxes\*(R" field when creating the object with new is
equivalent to calling this method.
.PP
The maxboxes method can be called to set the maximum number of boxes that
may be on the belt before the putting of boxes will be halted.
.SS "shutdown"
.IX Subsection "shutdown"
.Vb 1
\& $belt\->shutdown;
.Ve
.PP
The \*(L"shutdown\*(R" method performs an orderly shutdown of the belt.  It waits
until all of the boxes on the belt have been removed before it returns.
.SS "thread"
.IX Subsection "thread"
.Vb 1
\& $thread = $belt\->thread;
.Ve
.PP
The \*(L"thread\*(R" method returns the thread object that is being used for the belt.
It returns undef if no seperate thread is being used.
.SS "tid"
.IX Subsection "tid"
.Vb 1
\& $tid = $belt\->tid;
.Ve
.PP
The \*(L"tid\*(R" method returns the thread id of the thread object that is being
used for the belt.  It returns undef if no seperate thread is being used.
.SH "REQUIRED MODULES"
.IX Header "REQUIRED MODULES"
.Vb 3
\& load (any)
\& Thread::Serialize (any)
\& Thread::Tie (0.09)
.Ve
.SH "OPTIMIZATIONS"
.IX Header "OPTIMIZATIONS"
This module uses load to reduce memory and \s-1CPU\s0 usage. This causes
subroutines only to be compiled in a thread when they are actually needed at
the expense of more \s-1CPU\s0 when they need to be compiled.  Simple benchmarks
however revealed that the overhead of the compiling single routines is not
much more (and sometimes a lot less) than the overhead of cloning a Perl
interpreter with a lot of subroutines pre-loaded.
.SH "CAVEATS"
.IX Header "CAVEATS"
Passing unshared values between threads is accomplished by serializing the
specified values using Thread::Serialize.  Please see the \s-1CAVEATS\s0 section
there for an up-to-date status of what can be passed around between threads.
.SH "AUTHOR"
.IX Header "AUTHOR"
Elizabeth Mattijsen, <liz@dijkmat.nl>.
.PP
Please report bugs to <perlbugs@dijkmat.nl>.
.SH "HISTORY"
.IX Header "HISTORY"
This module started life as Thread::Queue::Any and as a sub-class of
Thread::Queue.  Using the conveyor belt metaphore seemed more appropriate
and therefore the name was changed.  To cut the cord with Thread::Queue
completely, the belt mechanism was implemented from scratch.
.PP
Why would you use Thread::Conveyor over Thread::Queue::Any?  Well,
Thread::Conveyor has the following extra features:
.IP "It works with Perl 5.8.0" 2
.IX Item "It works with Perl 5.8.0"
Shared arrays leak memory very badly in Perl 5.8.0.  Therefore, you cannot
really use Thread::Queue in Perl 5.8.0, and consequently cannot use
Thread::Queue::Any in any type of production environment.
.IP "It provides throttling" 2
.IX Item "It provides throttling"
A thread that enqueues very many values quickly, can cause a large amount of
memory to be used.  With throttling, any thread that enqueues will have to
wait until there is \*(L"room\*(R" on the belt again before continuing.  See methods
\&\*(L"minboxes\*(R" and \*(L"maxboxes\*(R".
.IP "You can check for a new value without removing it from the belt" 2
.IX Item "You can check for a new value without removing it from the belt"
Sometimes it can be nice to check whether there is a new value on the belt
without actually removing it from the belt.  See the \*(L"peek\*(R" and \*(L"peek_dontwait\*(R"
methods.
.IP "You can reset the entire belt" 2
.IX Item "You can reset the entire belt"
Sometimes you want to be able to reset the contents of the belt.  See the
\&\*(L"clean\*(R" and \*(L"clean_dontwait\*(R" methods for that.
.IP "You can get everything from the belt in one go" 2
.IX Item "You can get everything from the belt in one go"
Sometimes you want everything that's on the belt in one go.  That can also
ba accomplished with the \*(L"clean\*(R" and \*(L"clean_dontwait\*(R" methods.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002, 2003, 2004, 2007, 2010 Elizabeth Mattijsen <liz@dijkmat.nl>.
All rights reserved.  This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
threads, threads::shared, Thread::Queue, Thread::Queue::Any,
Thread::Serialize.
