.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Net::DNS::RR 3"
.TH Net::DNS::RR 3 "2017-08-18" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS::RR \- DNS resource record base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::DNS;
\&
\&    $rr = new Net::DNS::RR(\*(Aqexample.com IN A 192.0.2.99\*(Aq);
\&
\&    $rr = new Net::DNS::RR(
\&            owner   => \*(Aqexample.com\*(Aq,
\&            type    => \*(AqA\*(Aq,
\&            address => \*(Aq192.0.2.99\*(Aq
\&            );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::DNS::RR is the base class for \s-1DNS\s0 Resource Record (\s-1RR\s0) objects.
See also the manual pages for each specific \s-1RR\s0 type.
.SH "METHODS"
.IX Header "METHODS"
\&\fB\s-1WARNING\s0!!!\fR  Do not assume the \s-1RR\s0 objects you receive from a query
are of a particular type.  You must always check the object type
before calling any of its methods.  If you call an unknown method,
you will get an error message and execution will be terminated.
.SS "new (from string)"
.IX Subsection "new (from string)"
.Vb 4
\&    $a     = new Net::DNS::RR(\*(Aqhost.example.com. 86400 A 192.0.2.1\*(Aq);
\&    $mx    = new Net::DNS::RR(\*(Aqexample.com. 7200 MX 10 mailhost.example.com.\*(Aq);
\&    $cname = new Net::DNS::RR(\*(Aqwww.example.com 300 IN CNAME host.example.com\*(Aq);
\&    $txt   = new Net::DNS::RR(\*(Aqtxt.example.com 3600 HS TXT "text data"\*(Aq);
.Ve
.PP
Returns an object of the appropriate \s-1RR\s0 type, or a Net::DNS::RR object
if the type is not implemented. The attribute values are extracted from the
string passed by the user. The syntax of the argument string follows the
\&\s-1RFC1035\s0 specification for zone files, and is compatible with the result
returned by the string method.
.PP
The owner and \s-1RR\s0 type are required; all other information is optional.
Omitting the optional fields is useful for creating the empty \s-1RDATA\s0
sections required for certain dynamic update operations.
See the Net::DNS::Update manual page for additional examples.
.PP
All names are interpreted as fully qualified domain names.
The trailing dot (.) is optional.
.SS "new (from hash)"
.IX Subsection "new (from hash)"
.Vb 1
\&    $rr = new Net::DNS::RR(%hash);
\&
\&    $rr = new Net::DNS::RR(
\&            owner   => \*(Aqhost.example.com\*(Aq,
\&            ttl     => 86400,
\&            class   => \*(AqIN\*(Aq,
\&            type    => \*(AqA\*(Aq,
\&            address => \*(Aq192.0.2.1\*(Aq
\&            );
\& 
\&    $rr = new Net::DNS::RR(
\&            owner   => \*(Aqtxt.example.com\*(Aq,
\&            type    => \*(AqTXT\*(Aq,
\&            txtdata => [ \*(Aqone\*(Aq, \*(Aqtwo\*(Aq ]
\&            );
.Ve
.PP
Returns an object of the appropriate \s-1RR\s0 type, or a Net::DNS::RR object
if the type is not implemented. Consult the relevant manual pages for the
usage of type specific attributes.
.PP
The owner and \s-1RR\s0 type are required; all other information is optional.
Omitting optional attributes is useful for creating the empty \s-1RDATA\s0
sections required for certain dynamic update operations.
.SS "decode"
.IX Subsection "decode"
.Vb 1
\&    ( $rr, $next ) = decode Net::DNS::RR( \e$data, $offset, @opaque );
.Ve
.PP
Decodes a \s-1DNS\s0 resource record at the specified location within a
\&\s-1DNS\s0 packet.
.PP
The argument list consists of a reference to the buffer containing
the packet data and offset indicating where resource record begins.
Remaining arguments, if any, are passed as opaque data to
subordinate decoders.
.PP
Returns a \f(CW\*(C`Net::DNS::RR\*(C'\fR object and the offset of the next record
in the packet.
.PP
An exception is raised if the data buffer contains insufficient or
corrupt data.
.PP
Any remaining arguments are passed as opaque data to subordinate
decoders and do not form part of the published interface.
.SS "encode"
.IX Subsection "encode"
.Vb 1
\&    $data = $rr\->encode( $offset, @opaque );
.Ve
.PP
Returns the \f(CW\*(C`Net::DNS::RR\*(C'\fR in binary format suitable for inclusion
in a \s-1DNS\s0 packet buffer.
.PP
The offset indicates the intended location within the packet data
where the \f(CW\*(C`Net::DNS::RR\*(C'\fR is to be stored.
.PP
Any remaining arguments are opaque data which are passed intact to
subordinate encoders.
.SS "canonical"
.IX Subsection "canonical"
.Vb 1
\&    $data = $rr\->canonical;
.Ve
.PP
Returns the \f(CW\*(C`Net::DNS::RR\*(C'\fR in canonical binary format suitable for
\&\s-1DNSSEC\s0 signature validation.
.PP
The absence of the associative array argument signals to subordinate
encoders that the canonical uncompressed lower case form of embedded
domain names is to be used.
.SS "print"
.IX Subsection "print"
.Vb 1
\&    $rr\->print;
.Ve
.PP
Prints the record to the standard output.  Calls the string method
to get the formatted \s-1RR\s0 representation.
.SS "string"
.IX Subsection "string"
.Vb 1
\&    print $rr\->string, "\en";
.Ve
.PP
Returns a string representation of the \s-1RR\s0 using the zone file format
described in \s-1RFC1035.\s0  All domain names are fully qualified with
trailing dot.  This differs from \s-1RR\s0 attribute methods, which omit
the trailing dot.
.SS "plain"
.IX Subsection "plain"
.Vb 1
\&    $plain = $rr\->plain;
.Ve
.PP
Returns a simplified single line representation of the \s-1RR\s0 using the
zone file format defined in \s-1RFC1035.\s0  This facilitates interaction
with programs like nsupdate which have rudimentary \s-1RR\s0 parsers.
.SS "token"
.IX Subsection "token"
.Vb 1
\&    @token = $rr\->token;
.Ve
.PP
Returns a token list representation of the \s-1RR\s0 zone file string.
.SS "generic"
.IX Subsection "generic"
.Vb 1
\&    $generic = $rr\->generic;
.Ve
.PP
Returns the generic \s-1RR\s0 representation defined in \s-1RFC3597.\s0 This facilitates
creation of zone files containing RRs unrecognised by outdated nameservers
and provisioning software.
.SS "owner name"
.IX Subsection "owner name"
.Vb 1
\&    $name = $rr\->owner;
.Ve
.PP
Returns the owner name of the record.
.SS "type"
.IX Subsection "type"
.Vb 1
\&    $type = $rr\->type;
.Ve
.PP
Returns the record type.
.SS "class"
.IX Subsection "class"
.Vb 1
\&    $class = $rr\->class;
.Ve
.PP
Resource record class.
.SS "ttl"
.IX Subsection "ttl"
.Vb 2
\&    $ttl = $rr\->ttl;
\&    $ttl = $rr\->ttl(3600);
.Ve
.PP
Resource record time to live in seconds.
.SS "rdata"
.IX Subsection "rdata"
.Vb 1
\&    $rr = new Net::DNS::RR( type => NULL, rdata => \*(Aqarbitrary\*(Aq );
.Ve
.PP
Resource record data section when viewed as opaque octets.
.SS "rdstring"
.IX Subsection "rdstring"
.Vb 1
\&    $rdstring = $rr\->rdstring;
.Ve
.PP
Returns a string representation of the RR-specific data.
.SS "rdlength"
.IX Subsection "rdlength"
.Vb 1
\&    $rdlength = $rr\->rdlength;
.Ve
.PP
Returns the length of the encoded RR-specific data.
.SH "Sorting of RR arrays"
.IX Header "Sorting of RR arrays"
Sorting of \s-1RR\s0 arrays is done by \fINet::DNS::rrsort()\fR, see documentation
for Net::DNS. This package provides class methods to set the
comparator function used for a particular \s-1RR\s0 based on its attributes.
.SS "set_rrsort_func"
.IX Subsection "set_rrsort_func"
.Vb 3
\&    my $function = sub {                ## numerically ascending order
\&        $Net::DNS::a\->{\*(Aqpreference\*(Aq} <=> $Net::DNS::b\->{\*(Aqpreference\*(Aq};
\&    };
\&
\&    Net::DNS::RR::MX\->set_rrsort_func( \*(Aqpreference\*(Aq, $function );
\&
\&    Net::DNS::RR::MX\->set_rrsort_func( \*(Aqdefault_sort\*(Aq, $function );
.Ve
.PP
\&\fIset_rrsort_func()\fR must be called as a class method. The first argument is
the attribute name on which the sorting is to take place. If you specify
\&\*(L"default_sort\*(R" then that is the sort algorithm that will be used when
\&\fIget_rrsort_func()\fR is called without an \s-1RR\s0 attribute as argument.
.PP
The second argument is a reference to a comparator function that uses the
global variables \f(CW$a\fR and \f(CW$b\fR in the Net::DNS package. During sorting, the
variables \f(CW$a\fR and \f(CW$b\fR will contain references to objects of the class whose
\&\fIset_rrsort_func()\fR was called. The above sorting function will only be
applied to Net::DNS::RR::MX objects.
.PP
The above example is the sorting function implemented in \s-1MX.\s0
.SS "get_rrsort_func"
.IX Subsection "get_rrsort_func"
.Vb 2
\&    $function = Net::DNS::RR::MX\->get_rrsort_func(\*(Aqpreference\*(Aq);
\&    $function = Net::DNS::RR::MX\->get_rrsort_func();
.Ve
.PP
\&\fIget_rrsort_func()\fR returns a reference to the comparator function.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c)1997\-2001 Michael Fuhr.
.PP
Portions Copyright (c)2002,2003 Chris Reinhardt.
.PP
Portions Copyright (c)2005\-2007 Olaf Kolkman.
.PP
Portions Copyright (c)2007,2012 Dick Franks.
.PP
All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation, and that the name of the author not be used in advertising
or publicity pertaining to distribution of the software without specific
prior written permission.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, Net::DNS, Net::DNS::Question,
Net::DNS::Packet, Net::DNS::Update,
\&\s-1RFC1035\s0 Section 4.1.3, \s-1RFC1123, RFC3597\s0
