.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Test::Regexp 3"
.TH Test::Regexp 3 "2017-04-01" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Regexp \- Test your regular expressions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Test::Regexp \*(Aqno_plan\*(Aq;
\&
\& match    subject      => "Foo",
\&          pattern      => qr /\ew+/;
\&
\& match    subject      => "Foo bar",
\&          keep_pattern => qr /(?<first_word>\ew+)\es+(\ew+)/,
\&          captures     => [[first_word => \*(AqFoo\*(Aq], [\*(Aqbar\*(Aq]];
\&
\& no_match subject      => "Baz",
\&          pattern      => qr /Quux/;
\&
\& $checker = Test::Regexp \-> new \-> init (
\&    keep_pattern => qr /(\ew+)\es+\eg{\-1}/,
\&    name         => "Double word matcher",
\& );
\&
\& $checker \-> match    ("foo foo", ["foo"]);
\& $checker \-> no_match ("foo bar");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is intended to test your regular expressions. Given a subject
string and a regular expression (aka pattern), the module not only tests
whether the regular expression complete matches the subject string, it
performs a \f(CW\*(C`utf8::upgrade\*(C'\fR or \f(CW\*(C`utf8::downgrade\*(C'\fR on the subject
string and performs the tests again, if necessary. Furthermore, given a
pattern with capturing parenthesis, it checks whether all captures are
present, and in the right order. Both named and unnamed captures are checked.
.PP
By default, the module exports two subroutines, \f(CW\*(C`match\*(C'\fR and
\&\f(CW\*(C`no_match\*(C'\fR. The latter is actually a thin wrapper around \f(CW\*(C`match\*(C'\fR,
calling it with \f(CW\*(C`match => 0\*(C'\fR.
.ie n .SS """Complete matching"""
.el .SS "``Complete matching''"
.IX Subsection "Complete matching"
A match is only considered to successfully match if the entire string
is matched \- that is, if \f(CW$&\fR matches the subject string. So:
.PP
.Vb 1
\&  Subject    Pattern
\&
\&  "aaabb"    qr /a+b+/     # Considered ok
\&  "aaabb"    qr /a+/       # Not considered ok
.Ve
.PP
For efficiency reasons, when the matching is performed the pattern
is actually anchored at the start. It's not anchored at the end as
that would potentially influence the matching.
.SS "\s-1UTF8\s0 matching"
.IX Subsection "UTF8 matching"
Certain regular expression constructs match differently depending on 
whether \s-1UTF8\s0 matching is in effect or not. This is only relevant 
if the subject string has characters with code points between 128 and
255, and no characters above 255 \*(-- in such a case, matching may be
different depending on whether the subject string has the \s-1UTF8\s0 flag
on or not. \f(CW\*(C`Test::Regexp\*(C'\fR detects such a case, and will then 
run the tests twice; once with the subject string \f(CW\*(C`utf8::downgraded\*(C'\fR,
and once with the subject string \f(CW\*(C`utf8::upgraded\*(C'\fR.
.SS "Number of tests"
.IX Subsection "Number of tests"
There's no fixed number of tests that is run. The number of tests
depends on the number of captures, the number of different names of
captures, and whether there is the need to up\- or downgrade the 
subject string.
.PP
It is therefore recommended to use
\&\f(CW\*(C`use Text::Regexp tests => \*(Aqno_plan\*(Aq;\*(C'\fR.
In a later version, \f(CW\*(C`Test::Regexp\*(C'\fR will use a version of 
\&\f(CW\*(C`Test::Builder\*(C'\fR that allows for nested tests.
.PP
\fIDetails\fR
.IX Subsection "Details"
.PP
The number of tests is as follows:
.PP
If no match is expected (\f(CW\*(C`no_match => 0\*(C'\fR, or \f(CW\*(C`no_match\*(C'\fR is used),
only one test is performed.
.PP
Otherwise (we are expecting a match), if \f(CW\*(C`pattern\*(C'\fR is used, there
will be three tests.
.PP
For \f(CW\*(C`keep_pattern\*(C'\fR, there will be four tests, plus one tests for
each capture, an additional test for each named capture, and a test
for each name used in the set of named captures. So, if there are
\&\f(CW\*(C`N\*(C'\fR captures, there will be at least \f(CW\*(C`4 + N\*(C'\fR tests, and
at most \f(CW\*(C`4 + 3 * N\*(C'\fR tests.
.PP
If both \f(CW\*(C`pattern\*(C'\fR and \f(CW\*(C`keep_pattern\*(C'\fR are used, the number of
tests add up.
.PP
If \f(CW\*(C`Test::Regexp\*(C'\fR decides to upgrade or downgrade, the number of 
tests double.
.ie n .SS """use"" options"
.el .SS "\f(CWuse\fP options"
.IX Subsection "use options"
When using \f(CW\*(C`Test::Regexp\*(C'\fR, there are a few options you can
give it.
.ie n .IP """tests => \*(Aqno_plan\*(Aq"", ""tests => 123""" 4
.el .IP "\f(CWtests => \*(Aqno_plan\*(Aq\fR, \f(CWtests => 123\fR" 4
.IX Item "tests => no_plan, tests => 123"
The number of tests you are going to run. Since takes some work to
figure out how many tests will be run, for now the recommendation
is to use \f(CW\*(C`tests => \*(Aqno_plan\*(Aq\*(C'\fR.
.ie n .IP """import => [methods]""" 4
.el .IP "\f(CWimport => [methods]\fR" 4
.IX Item "import => [methods]"
By default, the subroutines \f(CW\*(C`match\*(C'\fR and \f(CW\*(C`no_match\*(C'\fR are 
exported. If you want to import a subset, use the \f(CW\*(C`import\*(C'\fR
tag, and give it an arrayref with the names of the subroutines to
import.
.ie n .SS """match"""
.el .SS "\f(CWmatch\fP"
.IX Subsection "match"
The subroutine \f(CW\*(C`match\*(C'\fR is the workhorse of the module. It takes
a number of named arguments, most of them optional, and runs one or
more tests. It returns 1 if all tests were run successfully, and 0
if one or more tests failed. The following options are available:
.ie n .IP """subject => STRING""" 4
.el .IP "\f(CWsubject => STRING\fR" 4
.IX Item "subject => STRING"
The string against which the pattern is tested is passed to \f(CW\*(C`match\*(C'\fR
using the \f(CW\*(C`subject\*(C'\fR option. It's an error to not pass in a subject.
.ie n .IP """pattern => PATTERN"", ""keep_pattern => PATTERN""" 4
.el .IP "\f(CWpattern => PATTERN\fR, \f(CWkeep_pattern => PATTERN\fR" 4
.IX Item "pattern => PATTERN, keep_pattern => PATTERN"
A pattern (aka regular expression) to test can be passed with one of
\&\f(CW\*(C`pattern\*(C'\fR or \f(CW\*(C`keep_pattern\*(C'\fR. The former should be used if the
pattern does not have any matching parenthesis; the latter if the pattern
does have capturing parenthesis. If both \f(CW\*(C`pattern\*(C'\fR and \f(CW\*(C`keep_pattern\*(C'\fR
are provided, the subject is tested against both. It's an error to not give
either \f(CW\*(C`pattern\*(C'\fR or \f(CW\*(C`keep_pattern\*(C'\fR.
.ie n .IP """captures => [LIST]""" 4
.el .IP "\f(CWcaptures => [LIST]\fR" 4
.IX Item "captures => [LIST]"
If a regular expression is passed with \f(CW\*(C`keep_pattern\*(C'\fR you should 
pass in a list of captures using the \f(CW\*(C`captures\*(C'\fR option.
.Sp
This list should contain all the captures, in order. For unnamed captures,
this should just be the string matched by the capture; for a named capture,
this should be a two element array, the first element being the name of
the capture, the second element the capture. Named and unnamed captures
may be mixed, and the same name for a capture may be repeated.
.Sp
Example:
.Sp
.Vb 3
\& match  subject      =>  "Eland Wapiti Caribou",
\&        keep_pattern =>  qr /(\ew+)\es+(?<a>\ew+)\es+(\ew+)/,
\&        captures     =>  ["Eland", [a => "Wapiti"], "Caribou"];
.Ve
.ie n .IP """name => NAME""" 4
.el .IP "\f(CWname => NAME\fR" 4
.IX Item "name => NAME"
The \*(L"name\*(R" of the test. It's being used in the test comment.
.ie n .IP """comment => NAME""" 4
.el .IP "\f(CWcomment => NAME\fR" 4
.IX Item "comment => NAME"
An alternative for \f(CW\*(C`name\*(C'\fR. If both are present, \f(CW\*(C`comment\*(C'\fR is used.
.ie n .IP """utf8_upgrade => 0"", ""utf8_downgrade => 0""" 4
.el .IP "\f(CWutf8_upgrade => 0\fR, \f(CWutf8_downgrade => 0\fR" 4
.IX Item "utf8_upgrade => 0, utf8_downgrade => 0"
As explained in \*(L"\s-1UTF8\s0 matching\*(R", \f(CW\*(C`Test::Regexp\*(C'\fR detects whether
a subject may provoke different matching depending on its \s-1UTF8\s0 flag, and
then it \f(CW\*(C`utf8::upgrades\*(C'\fR or \f(CW\*(C`utf8::downgrades\*(C'\fR the subject
string and runs the test again. Setting \f(CW\*(C`utf8_upgrade\*(C'\fR to 0 prevents
\&\f(CW\*(C`Test::Regexp\*(C'\fR from downgrading the subject string, while 
setting \f(CW\*(C`utf8_upgrade\*(C'\fR to 0 prevents \f(CW\*(C`Test::Regexp\*(C'\fR from 
upgrading the subject string.
.ie n .IP """match => BOOLEAN""" 4
.el .IP "\f(CWmatch => BOOLEAN\fR" 4
.IX Item "match => BOOLEAN"
By default, \f(CW\*(C`match\*(C'\fR assumes the pattern should match. But it also 
important to test which strings do not match a regular expression. This
can be done by calling \f(CW\*(C`match\*(C'\fR with \f(CW\*(C`match => 0\*(C'\fR as parameter.
(Or by calling \f(CW\*(C`no_match\*(C'\fR instead of \f(CW\*(C`match\*(C'\fR). In this case,
the test is a failure if the pattern completely matches the subject 
string. A \f(CW\*(C`captures\*(C'\fR argument is ignored.
.ie n .IP """reason => STRING""" 4
.el .IP "\f(CWreason => STRING\fR" 4
.IX Item "reason => STRING"
If the match is expected to fail (so, when \f(CW\*(C`match => 0\*(C'\fR is passed,
or if \f(CW\*(C`no_match\*(C'\fR is called), a reason may be provided with the
\&\f(CW\*(C`reason\*(C'\fR option. The reason is then printed in the comment of the
test.
.ie n .IP """test => STRING""" 4
.el .IP "\f(CWtest => STRING\fR" 4
.IX Item "test => STRING"
If the match is expected to pass (when \f(CW\*(C`match\*(C'\fR is called, without
\&\f(CW\*(C`match\*(C'\fR being false), and this option is passed, a message is printed
indicating what this specific test is testing (the argument to \f(CW\*(C`test\*(C'\fR).
.ie n .IP """todo => STRING""" 4
.el .IP "\f(CWtodo => STRING\fR" 4
.IX Item "todo => STRING"
If the \f(CW\*(C`todo\*(C'\fR parameter is used (with a defined value), the tests
are assumed to be \s-1TODO\s0 tests. The argument is used as the \s-1TODO\s0 message.
.ie n .IP """full_text => BOOL""" 4
.el .IP "\f(CWfull_text => BOOL\fR" 4
.IX Item "full_text => BOOL"
By default, long test messages are truncated; if a true value is passed, 
the message will not get truncated.
.ie n .IP """escape => INTEGER""" 4
.el .IP "\f(CWescape => INTEGER\fR" 4
.IX Item "escape => INTEGER"
Controls how non-ASCII and non-printables are displayed in generated
test messages:
.RS 4
.IP "\fB0\fR" 2
.IX Item "0"
No characters are escape, everything is displayed as is.
.IP "\fB1\fR" 2
.IX Item "1"
Show newlines, linefeeds and tabs using their usual escape sequences
(\f(CW\*(C`\en\*(C'\fR, \f(CW\*(C`\er\*(C'\fR, and \f(CW\*(C`\et\*(C'\fR).
.IP "\fB2\fR" 2
.IX Item "2"
Show any character outside of the printable \s-1ASCII\s0 characters as named
escapes (\f(CW\*(C`\eN{UNICODE NAME}\*(C'\fR), or a hex escape if the unicode name
is not found (\f(CW\*(C`\ex{XX}\*(C'\fR). This is the default if \f(CW\*(C`\-CO\*(C'\fR is not in
effect (\f(CW\*(C`${^UNICODE}\*(C'\fR is false).
.Sp
Newlines, linefeeds and tabs are displayed as above.
.IP "\fB3\fR" 2
.IX Item "3"
Show any character outside of the printable \s-1ASCII\s0 characters as hext
escapes (\f(CW\*(C`\ex{XX}\*(C'\fR).
.Sp
Newlines, linefeeds and tabs are displayed as above.
.IP "\fB4\fR" 2
.IX Item "4"
Show the non-printable \s-1ASCII\s0 characters as hex escapes (\f(CW\*(C`\ex{XX}\*(C'\fR);
any non-ASCII character is displayed as is. This is the default if
\&\f(CW\*(C`\-CO\*(C'\fR is in effect (\f(CW\*(C`${^UNICODE}\*(C'\fR is true).
.Sp
Newlines, linefeeds and tabs are displayed as above.
.RE
.RS 4
.RE
.ie n .IP """no_keep_message => BOOL""" 4
.el .IP "\f(CWno_keep_message => BOOL\fR" 4
.IX Item "no_keep_message => BOOL"
If matching against a \fIkeeping\fR pattern, a message \f(CW\*(C`(with \-Keep)\*(C'\fR
is added to the comment. Setting this parameter suppresses this message.
Mostly useful for \f(CW\*(C`Regexp::Common510\*(C'\fR.
.ie n .SS """no_match"""
.el .SS "\f(CWno_match\fP"
.IX Subsection "no_match"
Similar to \f(CW\*(C`match\*(C'\fR, except that it tests whether a pattern does
\&\fBnot\fR match a string. Accepts the same arguments as \f(CW\*(C`match\*(C'\fR,
except for \f(CW\*(C`match\*(C'\fR.
.SS "\s-1OO\s0 interface"
.IX Subsection "OO interface"
Since one typically checks a pattern with multiple strings, and it can
be tiresome to repeatedly call \f(CW\*(C`match\*(C'\fR or \f(CW\*(C`no_match\*(C'\fR with the
same arguments, there's also an \s-1OO\s0 interface. Using a pattern, one constructs
an object and can then repeatedly call the object to match a string.
.PP
To construct and initialize the object, call the following:
.PP
.Vb 5
\& my $checker = Test::Regexp \-> new \-> init (
\&    pattern      => qr  /PATTERN/,
\&    keep_pattern => qr /(PATTERN)/,
\&    ...
\& );
.Ve
.PP
\&\f(CW\*(C`init\*(C'\fR takes exactly the same arguments as \f(CW\*(C`match\*(C'\fR, with the
exception of \f(CW\*(C`subject\*(C'\fR and \f(CW\*(C`captures\*(C'\fR. To perform a match,
all \f(CW\*(C`match\*(C'\fR (or \f(CW\*(C`no_match\*(C'\fR) on the object. The first argument
should be the subject the pattern should match against (see the
\&\f(CW\*(C`subject\*(C'\fR argument of \f(CW\*(C`match\*(C'\fR discussed above). If there is a
match against a capturing pattern, the second argument is a reference
to an array with the matches (see the \f(CW\*(C`captures\*(C'\fR argument of
\&\f(CW\*(C`match\*(C'\fR discussed above).
.PP
Both \f(CW\*(C`match\*(C'\fR and \f(CW\*(C`no_match\*(C'\fR can take additional (named) arguments,
identical to the none-OO \f(CW\*(C`match\*(C'\fR and \f(CW\*(C`no_match\*(C'\fR routines.
.SH "RATIONALE"
.IX Header "RATIONALE"
The reason \f(CW\*(C`Test::Regexp\*(C'\fR was created is to aid testing for
the rewrite of \f(CW\*(C`Regexp::Common\*(C'\fR.
.SH "DEVELOPMENT"
.IX Header "DEVELOPMENT"
The current sources of this module are found on github,
<git://github.com/Abigail/Test\-Regexp.git>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Abigail <mailto:test\-regexp@abigail.be>.
.SH "COPYRIGHT and LICENSE"
.IX Header "COPYRIGHT and LICENSE"
Copyright (C) 2009 by Abigail
.PP
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\s0 
\&\s-1FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.\s0
.SH "INSTALLATION"
.IX Header "INSTALLATION"
To install this module, run, after unpacking the tar-ball, the
following commands:
.PP
.Vb 4
\&   perl Makefile.PL
\&   make
\&   make test
\&   make install
.Ve
