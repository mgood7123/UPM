.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "IO::CaptureOutput 3"
.TH IO::CaptureOutput 3 "2015-01-24" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::CaptureOutput \- capture STDOUT and STDERR from Perl code, subprocesses or XS
.SH "VERSION"
.IX Header "VERSION"
version 1.1104
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use IO::CaptureOutput qw(capture qxx qxy);
\&
\&    # STDOUT and STDERR separately
\&    capture { noisy_sub(@args) } \e$stdout, \e$stderr;
\&
\&    # STDOUT and STDERR together
\&    capture { noisy_sub(@args) } \e$combined, \e$combined;
\&
\&    # STDOUT and STDERR from external command
\&    ($stdout, $stderr, $success) = qxx( @cmd );
\&
\&    # STDOUT and STDERR together from external command
\&    ($combined, $success) = qxy( @cmd );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBThis module is no longer recommended by the maintainer\fR \- see
Capture::Tiny instead.
.PP
This module provides routines for capturing \s-1STDOUT\s0 and \s-1STDERR\s0 from perl
subroutines, forked system calls (e.g. \f(CW\*(C`system()\*(C'\fR, \f(CW\*(C`fork()\*(C'\fR) and from \s-1XS\s0
or C modules.
.SH "NAME"
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The following functions will be exported on demand.
.SS "\fIcapture()\fP"
.IX Subsection "capture()"
.Vb 1
\&    capture \e&subroutine, \e$stdout, \e$stderr;
.Ve
.PP
Captures everything printed to \f(CW\*(C`STDOUT\*(C'\fR and \f(CW\*(C`STDERR\*(C'\fR for the duration of
\&\f(CW&subroutine\fR. \f(CW$stdout\fR and \f(CW$stderr\fR are optional scalars that will
contain \f(CW\*(C`STDOUT\*(C'\fR and \f(CW\*(C`STDERR\*(C'\fR respectively.
.PP
\&\f(CW\*(C`capture()\*(C'\fR uses a code prototype so the first argument can be specified
directly within brackets if desired.
.PP
.Vb 2
\&    # shorthand with prototype
\&    capture C< print _\|_PACKAGE_\|_ > \e$stdout, \e$stderr;
.Ve
.PP
Returns the return value(s) of \f(CW&subroutine\fR. The sub is called in the
same context as \f(CW\*(C`capture()\*(C'\fR was called e.g.:
.PP
.Vb 3
\&    @rv = capture C< wantarray > ; # returns true
\&    $rv = capture C< wantarray > ; # returns defined, but not true
\&    capture C< wantarray >;       # void, returns undef
.Ve
.PP
\&\f(CW\*(C`capture()\*(C'\fR is able to capture output from subprocesses and C code, which
traditional \f(CW\*(C`tie()\*(C'\fR methods of output capture are unable to do.
.PP
\&\fBNote:\fR \f(CW\*(C`capture()\*(C'\fR will only capture output that has been written or
flushed to the filehandle.
.PP
If the two scalar references refer to the same scalar, then \f(CW\*(C`STDERR\*(C'\fR will
be merged to \f(CW\*(C`STDOUT\*(C'\fR before capturing and the scalar will hold the
combined output of both.
.PP
.Vb 1
\&    capture \e&subroutine, \e$combined, \e$combined;
.Ve
.PP
Normally, \f(CW\*(C`capture()\*(C'\fR uses anonymous, temporary files for capturing
output.  If desired, specific file names may be provided instead as
additional options.
.PP
.Vb 1
\&    capture \e&subroutine, \e$stdout, \e$stderr, $out_file, $err_file;
.Ve
.PP
Files provided will be clobbered, overwriting any previous data, but will
persist after the call to \f(CW\*(C`capture()\*(C'\fR for inspection or other
manipulation.
.PP
By default, when no references are provided to hold \s-1STDOUT\s0 or \s-1STDERR,\s0
output is captured and silently discarded.
.PP
.Vb 2
\&    # Capture STDOUT, discard STDERR
\&    capture \e&subroutine, \e$stdout;
\&
\&    # Discard STDOUT, capture STDERR
\&    capture \e&subroutine, undef, \e$stderr;
.Ve
.PP
However, even when using \f(CW\*(C`undef\*(C'\fR, output can be captured to specific
files.
.PP
.Vb 2
\&    # Capture STDOUT to a specific file, discard STDERR
\&    capture \e&subroutine, \e$stdout, undef, $outfile;
\&
\&    # Discard STDOUT, capture STDERR to a specific file
\&    capture \e&subroutine, undef, \e$stderr, undef, $err_file;
\&
\&    # Discard both, capture merged output to a specific file
\&    capture \e&subroutine, undef, undef, $mergedfile;
.Ve
.PP
It is a fatal error to merge \s-1STDOUT\s0 and \s-1STDERR\s0 and request separate,
specific files for capture.
.PP
.Vb 3
\&    # ERROR:
\&    capture \e&subroutine, \e$stdout, \e$stdout, $out_file, $err_file;
\&    capture \e&subroutine, undef, undef, $out_file, $err_file;
.Ve
.PP
If either \s-1STDOUT\s0 or \s-1STDERR\s0 should be passed through to the terminal instead
of captured, provide a reference to undef \*(-- \f(CW\*(C`\eundef\*(C'\fR \*(-- instead of a
capture variable.
.PP
.Vb 2
\&    # Capture STDOUT, display STDERR
\&    capture \e&subroutine, \e$stdout, \eundef;
\&
\&    # Display STDOUT, capture STDERR
\&    capture \e&subroutine, \eundef, \e$stderr;
.Ve
.SS "\fIcapture_exec()\fP"
.IX Subsection "capture_exec()"
.Vb 1
\&    ($stdout, $stderr, $success, $exit_code) = capture_exec(@args);
.Ve
.PP
Captures and returns the output from \f(CW\*(C`system(@args)\*(C'\fR. In scalar context,
\&\f(CW\*(C`capture_exec()\*(C'\fR will return what was printed to \f(CW\*(C`STDOUT\*(C'\fR. In list
context, it returns what was printed to \f(CW\*(C`STDOUT\*(C'\fR and \f(CW\*(C`STDERR\*(C'\fR as well as
a success flag and the exit value.
.PP
.Vb 1
\&    $stdout = capture_exec(\*(Aqperl\*(Aq, \*(Aq\-e\*(Aq, \*(Aqprint "hello world"\*(Aq);
\&
\&    ($stdout, $stderr, $success, $exit_code) =
\&        capture_exec(\*(Aqperl\*(Aq, \*(Aq\-e\*(Aq, \*(Aqwarn "Test"\*(Aq);
.Ve
.PP
\&\f(CW\*(C`capture_exec\*(C'\fR passes its arguments to \f(CW\*(C`system()\*(C'\fR and on MSWin32 will
protect arguments with shell quotes if necessary.  This makes it a handy
and slightly more portable alternative to backticks, piped \f(CW\*(C`open()\*(C'\fR and
\&\f(CW\*(C`IPC::Open3\*(C'\fR.
.PP
The \f(CW$success\fR flag returned will be true if the command ran successfully
and false if it did not (if the command could not be run or if it ran and
returned a non-zero exit value).  On failure, the raw exit value of the
\&\f(CW\*(C`system()\*(C'\fR call is available both in the \f(CW$exit_code\fR returned and in the
\&\f(CW$?\fR variable.
.PP
.Vb 2
\&  ($stdout, $stderr, $success, $exit_code) =
\&      capture_exec(\*(Aqperl\*(Aq, \*(Aq\-e\*(Aq, \*(Aqwarn "Test" and exit 1\*(Aq);
\&
\&  if ( ! $success ) {
\&      print "The exit code was " . ($exit_code >> 8) . "\en";
\&  }
.Ve
.PP
See perlvar for more information on interpreting a child process exit
code.
.SS "\fIcapture_exec_combined()\fP"
.IX Subsection "capture_exec_combined()"
.Vb 3
\&    ($combined, $success, $exit_code) = capture_exec_combined(
\&        \*(Aqperl\*(Aq, \*(Aq\-e\*(Aq, \*(Aqprint "hello\en"\*(Aq, \*(Aqwarn "Test\en"
\&    );
.Ve
.PP
This is just like \f(CW\*(C`capture_exec()\*(C'\fR, except that it merges \f(CW\*(C`STDERR\*(C'\fR with
\&\f(CW\*(C`STDOUT\*(C'\fR before capturing output.
.PP
\&\fBNote:\fR there is no guarantee that text printed to \f(CW\*(C`STDOUT\*(C'\fR and \f(CW\*(C`STDERR\*(C'\fR
in the subprocess will be appear in order. The actual order will depend on
how \s-1IO\s0 buffering is handled in the subprocess.
.SS "\fIqxx()\fP"
.IX Subsection "qxx()"
This is an alias for \f(CW\*(C`capture_exec()\*(C'\fR.
.SS "\fIqxy()\fP"
.IX Subsection "qxy()"
This is an alias for \f(CW\*(C`capture_exec_combined()\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Capture::Tiny
.IP "\(bu" 4
IPC::Open3
.IP "\(bu" 4
IO::Capture
.IP "\(bu" 4
IO::Utils
.IP "\(bu" 4
IPC::System::Simple
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/dagolden/IO\-CaptureOutput/issues>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/IO\-CaptureOutput>
.PP
.Vb 1
\&  git clone https://github.com/dagolden/IO\-CaptureOutput.git
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Simon Flack <simonflk@cpan.org>
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Mike Latimer <mlatimer@suse.com>
.IP "\(bu" 4
Olivier Mengué <dolmen@cpan.org>
.IP "\(bu" 4
Tony Cook <tony@develop\-help.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Simon Flack and David Golden.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
