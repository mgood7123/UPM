.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Devel::Symdump 3"
.TH Devel::Symdump 3 "2017-02-06" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::Symdump \- dump symbol names or the symbol table
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    # Constructor
\&    require Devel::Symdump;
\&    @packs = qw(some_package another_package);
\&    $obj = Devel::Symdump\->new(@packs);        # no recursion
\&    $obj = Devel::Symdump\->rnew(@packs);       # with recursion
\&
\&    # Methods
\&    @array = $obj\->packages;
\&    @array = $obj\->scalars;
\&    @array = $obj\->arrays;
\&    @array = $obj\->hashes;
\&    @array = $obj\->functions;
\&    @array = $obj\->filehandles;  # deprecated, use ios instead
\&    @array = $obj\->dirhandles;   # deprecated, use ios instead
\&    @array = $obj\->ios;
\&    @array = $obj\->unknowns;     # only perl version < 5.003 had some
\&
\&    $string = $obj\->as_string;
\&    $string = $obj\->as_HTML;
\&    $string = $obj1\->diff($obj2);
\&
\&    $string = Devel::Symdump\->isa_tree;    # or $obj\->isa_tree
\&    $string = Devel::Symdump\->inh_tree;    # or $obj\->inh_tree
\&
\&    # Methods with autogenerated objects
\&    # all of those call new(@packs) internally
\&    @array = Devel::Symdump\->packages(@packs);
\&    @array = Devel::Symdump\->scalars(@packs);
\&    @array = Devel::Symdump\->arrays(@packs);
\&    @array = Devel::Symdump\->hashes(@packs);
\&    @array = Devel::Symdump\->functions(@packs);
\&    @array = Devel::Symdump\->ios(@packs);
\&    @array = Devel::Symdump\->unknowns(@packs);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This little package serves to access the symbol table of perl.
.ie n .IP """Devel::Symdump\->rnew(@packages)""" 4
.el .IP "\f(CWDevel::Symdump\->rnew(@packages)\fR" 4
.IX Item "Devel::Symdump->rnew(@packages)"
returns a symbol table object for all subtrees below \f(CW@packages\fR.
Nested Modules are analyzed recursively. If no package is given as
argument, it defaults to \f(CW\*(C`main\*(C'\fR. That means to get the whole symbol
table, just do a \f(CW\*(C`rnew\*(C'\fR without arguments.
.Sp
The global variable \f(CW$Devel::Symdump::MAX_RECURSION\fR limits the
recursion to prevent contention. The default value is set to 97, just
low enough to survive the test suite without a warning about deep
recursion.
.ie n .IP """Devel::Symdump\->new(@packages)""" 4
.el .IP "\f(CWDevel::Symdump\->new(@packages)\fR" 4
.IX Item "Devel::Symdump->new(@packages)"
does not go into recursion and only analyzes the packages that are
given as arguments.
.IP "packages, scalars, arrays, hashes, functions, ios" 4
.IX Item "packages, scalars, arrays, hashes, functions, ios"
The methods \fIpackages()\fR, \fIscalars()\fR, \fIarrays()\fR, \fIhashes()\fR, \fIfunctions()\fR,
\&\fIios()\fR, and (for older perls) \fIunknowns()\fR each return an array of fully
qualified symbols of the specified type in all packages that are held
within a Devel::Symdump object, but without the leading \f(CW\*(C`$\*(C'\fR, \f(CW\*(C`@\*(C'\fR or
\&\f(CW\*(C`%\*(C'\fR. In a scalar context, they will return the number of such
symbols. Unknown symbols are usually either formats or variables that
haven't yet got a defined value.
.Sp
Note that scalar symbol table entries are a special case.  If a symbol
table entry exists at all, presence of a scalar is currently
unknowable, due to a feature of Perl described in \*(L"Making
References\*(R" in perlref point 7.  For example, this package will mark a scalar
value \f(CW$foo\fR as present if any of \f(CW@foo\fR, \f(CW%foo\fR, \f(CW&foo\fR etc. have
been declared or used.
.IP "as_string" 4
.IX Item "as_string"
.PD 0
.IP "as_HTML" 4
.IX Item "as_HTML"
.PD
\&\fIAs_string()\fR and \fIas_HTML()\fR return a simple string/HTML representations
of the object.
.IP "diff" 4
.IX Item "diff"
\&\fIDiff()\fR prints the difference between two Devel::Symdump objects in
human readable form. The format is similar to the one used by the
as_string method.
.IP "isa_tree" 4
.IX Item "isa_tree"
.PD 0
.IP "inh_tree" 4
.IX Item "inh_tree"
.PD
\&\fIIsa_tree()\fR and \fIinh_tree()\fR both return a simple string representation
of the current inheritance tree. The difference between the two
methods is the direction from which the tree is viewed: top-down or
bottom-up. As I'm sure, many users will have different expectation
about what is top and what is bottom, I'll provide an example what
happens when the Socket module is loaded:
.IP "% print Devel::Symdump\->inh_tree" 4
.IX Item "% print Devel::Symdump->inh_tree"
.Vb 9
\&    AutoLoader
\&            DynaLoader
\&                    Socket
\&    DynaLoader
\&            Socket
\&    Exporter
\&            Carp
\&            Config
\&            Socket
.Ve
.Sp
The inh_tree method shows on the left hand side a package name and
indented to the right the packages that use the former.
.IP "% print Devel::Symdump\->isa_tree" 4
.IX Item "% print Devel::Symdump->isa_tree"
.Vb 10
\&    Carp
\&            Exporter
\&    Config
\&            Exporter
\&    DynaLoader
\&            AutoLoader
\&    Socket
\&            Exporter
\&            DynaLoader
\&                    AutoLoader
.Ve
.Sp
The isa_tree method displays from left to right \s-1ISA\s0 relationships, so
Socket \s-1IS A\s0 DynaLoader and DynaLoader \s-1IS A\s0 AutoLoader. (Actually, they
were at the time this manpage was written)
.PP
You may call both methods, \fIisa_tree()\fR and \fIinh_tree()\fR, with an
object. If you do that, the object will store the output and retrieve
it when you call the same method again later. The typical usage would
be to use them as class methods directly though.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
The design of this package is intentionally primitive and allows it to
be subclassed easily. An example of a (maybe) useful subclass is
Devel::Symdump::Export, a package which exports all methods of the
Devel::Symdump package and turns them into functions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Routines for manipulating stashes: \f(CW\*(C`Package::Stash\*(C'\fR; to work with
lexicals: \f(CW\*(C`PadWalker\*(C'\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
Andreas Koenig \fI<andk@cpan.org>\fR and Tom Christiansen
\&\fI<tchrist@perl.com>\fR. Based on the old \fIdumpvar.pl\fR by Larry
Wall.
.SH "COPYRIGHT, LICENSE"
.IX Header "COPYRIGHT, LICENSE"
This module is
.PP
Copyright (c) 1995, 1997, 2000, 2002, 2005, 2006 Andreas Koenig \f(CW\*(C`<andk@cpan.org>\*(C'\fR.
.PP
All rights reserved.
.PP
This library is free software;
you may use, redistribute and/or modify it under the same
terms as Perl itself.
