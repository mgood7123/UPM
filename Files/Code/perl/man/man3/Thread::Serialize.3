.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Thread::Serialize 3"
.TH Thread::Serialize 3 "2012-12-07" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Thread::Serialize \- serialize data\-structures between threads
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Thread::Serialize;    # export freeze() and thaw()
\&
\&  use Thread::Serialize (); # must call fully qualified subs
\&
\&  my $frozen = freeze( any data structure );
\&  any data structure = thaw( $frozen );
.Ve
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 1.01.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 1
\&                  *** A note of CAUTION ***
\&
\& This module only functions if threading has been enabled when building
\& Perl, or if the "forks" module has been installed on an unthreaded Perl.
\&
\&                  *************************
.Ve
.PP
The Thread::Serialize module is a library for centralizing the routines
used to serialize data-structures between threads.  Because of this central
location, other modules such as Thread::Conveyor, Thread::Pool or
Thread::Tie can benefit from the same optimilizations that may take
place here in the future.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
There are only two subroutines.
.SS "freeze"
.IX Subsection "freeze"
.Vb 1
\& my $frozen = freeze( $scalar );
\&
\& my $frozen = freeze( @array );
.Ve
.PP
The \*(L"freeze\*(R" subroutine takes all the parameters passed to it, freezes them
and returns a frozen representation of what was given.  The parameters can
be scalar values or references to arrays or hashes.  Use the thaw
subroutine to obtain the original data-structure back.
.SS "thaw"
.IX Subsection "thaw"
.Vb 1
\& my $scalar = thaw( $frozen );
\&
\& my @array = thaw( $frozen );
.Ve
.PP
The \*(L"thaw\*(R" subroutine returns the data-structure that was frozen with a call
to freeze.  If called in a scalar context, only the first element of the
data-structure that was passed, will be returned.  Otherwise the entire
data-structure will be returned.
.PP
It is up to the developer to make sure that single argument calls to freeze
are always matched by scalar context calls to thaw.
.SH "REQUIRED MODULES"
.IX Header "REQUIRED MODULES"
.Vb 2
\& Storable (any)
\& Test::More (0.88)
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
This distribution contains two versions of the code: one maintenance version
for versions of perl < 5.014 (known as 'maint'), and the version currently in
development (known as 'blead').  The standard build for your perl version is:
.PP
.Vb 4
\& perl Makefile.PL
\& make
\& make test
\& make install
.Ve
.PP
This will try to test and install the \*(L"blead\*(R" version of the code.  If the
Perl version does not support the \*(L"blead\*(R" version, then the running of the
Makefile.PL will *fail*.  In such a case, one can force the installing of
the \*(L"maint\*(R" version of the code by doing:
.PP
.Vb 1
\& perl Makefile.PL maint
.Ve
.PP
Alternately, if you want automatic selection behavior, you can set the
\&\s-1AUTO_SELECT_MAINT_OR_BLEAD\s0 environment variable to a true value.  On Unix-like
systems like so:
.PP
.Vb 1
\& AUTO_SELECT_MAINT_OR_BLEAD=1 perl Makefile.PL
.Ve
.PP
If your perl does not support the \*(L"blead\*(R" version of the code, then it will
automatically install the \*(L"maint\*(R" version of the code.
.PP
Please note that any additional parameters will simply be passed on to the
underlying Makefile.PL processing.
.SH "OPTIMIZATIONS"
.IX Header "OPTIMIZATIONS"
To reduce memory and \s-1CPU\s0 usage, this module uses load.  This causes
subroutines only to be compiled in a thread when they are actually needed at
the expense of more \s-1CPU\s0 when they need to be compiled.  Simple benchmarks
however revealed that the overhead of the compiling single routines is not
much more (and sometimes a lot less) than the overhead of cloning a Perl
interpreter with a lot of subroutines pre-loaded.
.PP
To reduce the number of modules and subroutines loaded, an external Perl
interpreter is started to determine the Storable signature at compile time.
In some situations this may cause a problem: please set the
\&\f(CW$Thread::Serialize::no_external_perl\fR variable to a true value at compile
time \fBbefore\fR loading Thread::Serialize if this causes a problem.
.PP
.Vb 2
\& BEGIN { $Thread::Serialize::no_external_perl= 1 }
\& use Thread::Serialize;
.Ve
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
.SS "Embedded Perls"
.IX Subsection "Embedded Perls"
Philip Monsen reported that in the case of an embedded Perl interpreter (e.g.
in a C program), the use of an external executor to determine the Storable
signature, causes problems.  This has been fixed by introducing the global
variable \f(CW$Thread::Serialize::no_external_perl\fR (see \s-1OPTIMIZATIONS\s0).
.SH "AUTHOR"
.IX Header "AUTHOR"
Elizabeth Mattijsen, <liz@dijkmat.nl>.
.PP
Please report bugs to <perlbugs@dijkmat.nl>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002, 2003, 2004, 2010, 2012 Elizabeth Mattijsen <liz@dijkmat.nl>.
All rights reserved.  This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
load, Thread::Conveyor, Thread::Pool, Thread::Tie.
