.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Find::Object::Rule 3"
.TH File::Find::Object::Rule 3 "2017-10-01" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Find::Object::Rule \- Alternative interface to File::Find::Object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use File::Find::Object::Rule;
\&  # find all the subdirectories of a given directory
\&  my @subdirs = File::Find::Object::Rule\->directory\->in( $directory );
\&
\&  # find all the .pm files in @INC
\&  my @files = File::Find::Object::Rule\->file()
\&                              \->name( \*(Aq*.pm\*(Aq )
\&                              \->in( @INC );
\&
\&  # as above, but without method chaining
\&  my $rule =  File::Find::Object::Rule\->new;
\&  $rule\->file;
\&  $rule\->name( \*(Aq*.pm\*(Aq );
\&  my @files = $rule\->in( @INC );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
File::Find::Object::Rule is a friendlier interface to File::Find::Object .
It allows you to build rules which specify the desired files and directories.
.PP
\&\fB\s-1WARNING\s0\fR : This module is a fork of version 0.30 of File::Find::Rule
(which has been unmaintained for several years as of February, 2009), and may
still have some bugs due to its reliance on File::Find'isms. As such it is
considered Alpha software. Please report any problems with
File::Find::Object::Rule to its \s-1RT CPAN\s0 Queue.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP """new""" 4
.el .IP "\f(CWnew\fR" 4
.IX Item "new"
A constructor.  You need not invoke \f(CW\*(C`new\*(C'\fR manually unless you wish
to, as each of the rule-making methods will auto-create a suitable
object if called as class methods.
.SS "finder"
.IX Subsection "finder"
The File::Find::Object finder instance itself.
.ie n .SS "my @rules = @{$ffor\->\fIrules()\fP};"
.el .SS "my \f(CW@rules\fP = @{$ffor\->\fIrules()\fP};"
.IX Subsection "my @rules = @{$ffor->rules()};"
The rules to match against. For internal use only.
.SS "Matching Rules"
.IX Subsection "Matching Rules"
.ie n .IP """name( @patterns )""" 4
.el .IP "\f(CWname( @patterns )\fR" 4
.IX Item "name( @patterns )"
Specifies names that should match.  May be globs or regular
expressions.
.Sp
.Vb 3
\& $set\->name( \*(Aq*.mp3\*(Aq, \*(Aq*.ogg\*(Aq ); # mp3s or oggs
\& $set\->name( qr/\e.(mp3|ogg)$/ ); # the same as a regex
\& $set\->name( \*(Aqfoo.bar\*(Aq );        # just things named foo.bar
.Ve
.IP "\-X tests" 4
.IX Item "-X tests"
Synonyms are provided for each of the \-X tests. See \*(L"\-X\*(R" in perlfunc for
details.  None of these methods take arguments.
.Sp
.Vb 10
\&  Test | Method               Test |  Method
\& \-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-        \-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   \-r  |  readable             \-R  |  r_readable
\&   \-w  |  writeable            \-W  |  r_writeable
\&   \-w  |  writable             \-W  |  r_writable
\&   \-x  |  executable           \-X  |  r_executable
\&   \-o  |  owned                \-O  |  r_owned
\&       |                           |
\&   \-e  |  exists               \-f  |  file
\&   \-z  |  empty                \-d  |  directory
\&   \-s  |  nonempty             \-l  |  symlink
\&       |                       \-p  |  fifo
\&   \-u  |  setuid               \-S  |  socket
\&   \-g  |  setgid               \-b  |  block
\&   \-k  |  sticky               \-c  |  character
\&       |                       \-t  |  tty
\&   \-M  |  modified                 |
\&   \-A  |  accessed             \-T  |  ascii
\&   \-C  |  changed              \-B  |  binary
.Ve
.Sp
Though some tests are fairly meaningless as binary flags (\f(CW\*(C`modified\*(C'\fR,
\&\f(CW\*(C`accessed\*(C'\fR, \f(CW\*(C`changed\*(C'\fR), they have been included for completeness.
.Sp
.Vb 3
\& # find nonempty files
\& $rule\->file,
\&      \->nonempty;
.Ve
.IP "stat tests" 4
.IX Item "stat tests"
The following \f(CW\*(C`stat\*(C'\fR based methods are provided: \f(CW\*(C`dev\*(C'\fR, \f(CW\*(C`ino\*(C'\fR,
\&\f(CW\*(C`mode\*(C'\fR, \f(CW\*(C`nlink\*(C'\fR, \f(CW\*(C`uid\*(C'\fR, \f(CW\*(C`gid\*(C'\fR, \f(CW\*(C`rdev\*(C'\fR, \f(CW\*(C`size\*(C'\fR, \f(CW\*(C`atime\*(C'\fR,
\&\f(CW\*(C`mtime\*(C'\fR, \f(CW\*(C`ctime\*(C'\fR, \f(CW\*(C`blksize\*(C'\fR, and \f(CW\*(C`blocks\*(C'\fR.  See \*(L"stat\*(R" in perlfunc
for details.
.Sp
Each of these can take a number of targets, which will follow
Number::Compare semantics.
.Sp
.Vb 5
\& $rule\->size( 7 );         # exactly 7
\& $rule\->size( ">7Ki" );    # larger than 7 * 1024 * 1024 bytes
\& $rule\->size( ">=7" )
\&      \->size( "<=90" );    # between 7 and 90, inclusive
\& $rule\->size( 7, 9, 42 );  # 7, 9 or 42
.Ve
.ie n .IP """any( @rules )""" 4
.el .IP "\f(CWany( @rules )\fR" 4
.IX Item "any( @rules )"
.PD 0
.ie n .IP """or( @rules )""" 4
.el .IP "\f(CWor( @rules )\fR" 4
.IX Item "or( @rules )"
.PD
Allows shortcircuiting boolean evaluation as an alternative to the
default and-like nature of combined rules.  \f(CW\*(C`any\*(C'\fR and \f(CW\*(C`or\*(C'\fR are
interchangeable.
.Sp
.Vb 5
\& # find avis, movs, things over 200M and empty files
\& $rule\->any( File::Find::Object::Rule\->name( \*(Aq*.avi\*(Aq, \*(Aq*.mov\*(Aq ),
\&             File::Find::Object::Rule\->size( \*(Aq>200M\*(Aq ),
\&             File::Find::Object::Rule\->file\->empty,
\&           );
.Ve
.ie n .IP """none( @rules )""" 4
.el .IP "\f(CWnone( @rules )\fR" 4
.IX Item "none( @rules )"
.PD 0
.ie n .IP """not( @rules )""" 4
.el .IP "\f(CWnot( @rules )\fR" 4
.IX Item "not( @rules )"
.PD
Negates a rule.  (The inverse of \f(CW\*(C`any\*(C'\fR.)  \f(CW\*(C`none\*(C'\fR and \f(CW\*(C`not\*(C'\fR are
interchangeable.
.Sp
.Vb 3
\&  # files that aren\*(Aqt 8.3 safe
\&  $rule\->file
\&       \->not( $rule\->new\->name( qr/^[^.]{1,8}(\e.[^.]{0,3})?$/ ) );
.Ve
.ie n .IP """prune""" 4
.el .IP "\f(CWprune\fR" 4
.IX Item "prune"
Traverse no further.  This rule always matches.
.ie n .IP """discard""" 4
.el .IP "\f(CWdiscard\fR" 4
.IX Item "discard"
Don't keep this file.  This rule always matches.
.ie n .IP """exec( \e&subroutine( $shortname, $path, $fullname ) )""" 4
.el .IP "\f(CWexec( \e&subroutine( $shortname, $path, $fullname ) )\fR" 4
.IX Item "exec( &subroutine( $shortname, $path, $fullname ) )"
Allows user-defined rules.  Your subroutine will be invoked with parameters of
the name, the path you're in, and the full relative filename.
In addition, \f(CW$_\fR is set to the current short name, but its use is
discouraged since as opposed to File::Find::Rule, File::Find::Object::Rule
does not cd to the containing directory.
.Sp
Return a true value if your rule matched.
.Sp
.Vb 2
\& # get things with long names
\& $rules\->exec( sub { length > 20 } );
.Ve
.ie n .IP "\->grep( @specifiers );" 4
.el .IP "\->grep( \f(CW@specifiers\fR );" 4
.IX Item "->grep( @specifiers );"
Opens a file and tests it each line at a time.
.Sp
For each line it evaluates each of the specifiers, stopping at the
first successful match.  A specifier may be a regular expression or a
subroutine.  The subroutine will be invoked with the same parameters
as an \->exec subroutine.
.Sp
It is possible to provide a set of negative specifiers by enclosing
them in anonymous arrays.  Should a negative specifier match the
iteration is aborted and the clause is failed.  For example:
.Sp
.Vb 1
\& $rule\->grep( qr/^#!.*\ebperl/, [ sub { 1 } ] );
.Ve
.Sp
Is a passing clause if the first line of a file looks like a perl
shebang line.
.ie n .IP """maxdepth( $level )""" 4
.el .IP "\f(CWmaxdepth( $level )\fR" 4
.IX Item "maxdepth( $level )"
Descend at most \f(CW$level\fR (a non-negative integer) levels of directories
below the starting point.
.Sp
May be invoked many times per rule, but only the most recent value is
used.
.ie n .IP """mindepth( $level )""" 4
.el .IP "\f(CWmindepth( $level )\fR" 4
.IX Item "mindepth( $level )"
Do not apply any tests at levels less than \f(CW$level\fR (a non-negative
integer).
.ie n .IP """extras( \e%extras )""" 4
.el .IP "\f(CWextras( \e%extras )\fR" 4
.IX Item "extras( %extras )"
Specifies extra values to pass through to \f(CW\*(C`File::File::find\*(C'\fR as part
of the options hash.
.Sp
For example this allows you to specify following of symlinks like so:
.Sp
.Vb 1
\& my $rule = File::Find::Object::Rule\->extras({ follow => 1 });
.Ve
.Sp
May be invoked many times per rule, but only the most recent value is
used.
.ie n .IP """relative""" 4
.el .IP "\f(CWrelative\fR" 4
.IX Item "relative"
Trim the leading portion of any path found
.ie n .IP """not_*""" 4
.el .IP "\f(CWnot_*\fR" 4
.IX Item "not_*"
Negated version of the rule.  An effective shortand related to ! in
the procedural interface.
.Sp
.Vb 1
\& $foo\->not_name(\*(Aq*.pl\*(Aq);
\&
\& $foo\->not( $foo\->new\->name(\*(Aq*.pl\*(Aq ) );
.Ve
.SS "Query Methods"
.IX Subsection "Query Methods"
.ie n .IP """in( @directories )""" 4
.el .IP "\f(CWin( @directories )\fR" 4
.IX Item "in( @directories )"
Evaluates the rule, returns a list of paths to matching files and
directories.
.ie n .IP """start( @directories )""" 4
.el .IP "\f(CWstart( @directories )\fR" 4
.IX Item "start( @directories )"
Starts a find across the specified directories.  Matching items may
then be queried using \*(L"match\*(R".  This allows you to use a rule as an
iterator.
.Sp
.Vb 4
\& my $rule = File::Find::Object::Rule\->file\->name("*.jpeg")\->start( "/web" );
\& while ( my $image = $rule\->match ) {
\&     ...
\& }
.Ve
.ie n .IP """match""" 4
.el .IP "\f(CWmatch\fR" 4
.IX Item "match"
Returns the next file which matches, false if there are no more.
.SS "Extensions"
.IX Subsection "Extensions"
Extension modules are available from \s-1CPAN\s0 in the File::Find::Object::Rule
namespace.  In order to use these extensions either use them directly:
.PP
.Vb 2
\& use File::Find::Object::Rule::ImageSize;
\& use File::Find::Object::Rule::MMagic;
\&
\& # now your rules can use the clauses supplied by the ImageSize and
\& # MMagic extension
.Ve
.PP
or, specify that File::Find::Object::Rule should load them for you:
.PP
.Vb 1
\& use File::Find::Object::Rule qw( :ImageSize :MMagic );
.Ve
.PP
For notes on implementing your own extensions, consult
File::Find::Object::Rule::Extending
.SS "Further examples"
.IX Subsection "Further examples"
.IP "Finding perl scripts" 4
.IX Item "Finding perl scripts"
.Vb 10
\& my $finder = File::Find::Object::Rule\->or
\&  (
\&   File::Find::Object::Rule\->name( \*(Aq*.pl\*(Aq ),
\&   File::Find::Object::Rule\->exec(
\&                          sub {
\&                              if (open my $fh, $_) {
\&                                  my $shebang = <$fh>;
\&                                  close $fh;
\&                                  return $shebang =~ /^#!.*\ebperl/;
\&                              }
\&                              return 0;
\&                          } ),
\&  );
.Ve
.Sp
Based upon this message http://use.perl.org/comments.pl?sid=7052&cid=10842
.IP "ignore \s-1CVS\s0 directories" 4
.IX Item "ignore CVS directories"
.Vb 7
\& my $rule = File::Find::Object::Rule\->new;
\& $rule\->or($rule\->new
\&                \->directory
\&                \->name(\*(AqCVS\*(Aq)
\&                \->prune
\&                \->discard,
\&           $rule\->new);
.Ve
.Sp
Note here the use of a null rule.  Null rules match anything they see,
so the effect is to match (and discard) directories called '\s-1CVS\s0' or to
match anything.
.SH "TWO FOR THE PRICE OF ONE"
.IX Header "TWO FOR THE PRICE OF ONE"
File::Find::Object::Rule also gives you a procedural interface.  This is
documented in File::Find::Object::Rule::Procedural
.SH "EXPORTS"
.IX Header "EXPORTS"
.SS "find"
.IX Subsection "find"
.SS "rule"
.IX Subsection "rule"
.SH "Tests"
.IX Header "Tests"
.SS "accessed"
.IX Subsection "accessed"
Corresponds to \f(CW\*(C`\-A\*(C'\fR.
.SS "ascii"
.IX Subsection "ascii"
Corresponds to \f(CW\*(C`\-T\*(C'\fR.
.SS "atime"
.IX Subsection "atime"
See \*(L"stat tests\*(R".
.SS "binary"
.IX Subsection "binary"
Corresponds to \f(CW\*(C`\-b\*(C'\fR.
.SS "blksize"
.IX Subsection "blksize"
See \*(L"stat tests\*(R".
.SS "block"
.IX Subsection "block"
Corresponds to \f(CW\*(C`\-b\*(C'\fR.
.SS "blocks"
.IX Subsection "blocks"
See \*(L"stat tests\*(R".
.SS "changed"
.IX Subsection "changed"
Corresponds to \f(CW\*(C`\-C\*(C'\fR.
.SS "character"
.IX Subsection "character"
Corresponds to \f(CW\*(C`\-c\*(C'\fR.
.SS "ctime"
.IX Subsection "ctime"
See \*(L"stat tests\*(R".
.SS "dev"
.IX Subsection "dev"
See \*(L"stat tests\*(R".
.SS "directory"
.IX Subsection "directory"
Corresponds to \f(CW\*(C`\-d\*(C'\fR.
.SS "empty"
.IX Subsection "empty"
Corresponds to \f(CW\*(C`\-z\*(C'\fR.
.SS "executable"
.IX Subsection "executable"
Corresponds to \f(CW\*(C`\-x\*(C'\fR.
.SS "exists"
.IX Subsection "exists"
Corresponds to \f(CW\*(C`\-e\*(C'\fR.
.SS "fifo"
.IX Subsection "fifo"
Corresponds to \f(CW\*(C`\-p\*(C'\fR.
.SS "file"
.IX Subsection "file"
Corresponds to \f(CW\*(C`\-f\*(C'\fR.
.SS "gid"
.IX Subsection "gid"
See \*(L"stat tests\*(R".
.SS "ino"
.IX Subsection "ino"
See \*(L"stat tests\*(R".
.SS "mode"
.IX Subsection "mode"
See \*(L"stat tests\*(R".
.SS "modified"
.IX Subsection "modified"
Corresponds to \f(CW\*(C`\-M\*(C'\fR.
.SS "mtime"
.IX Subsection "mtime"
See \*(L"stat tests\*(R".
.SS "nlink"
.IX Subsection "nlink"
See \*(L"stat tests\*(R".
.SS "r_executable"
.IX Subsection "r_executable"
Corresponds to \f(CW\*(C`\-X\*(C'\fR.
.SS "r_owned"
.IX Subsection "r_owned"
Corresponds to \f(CW\*(C`\-O\*(C'\fR.
.SS "nonempty"
.IX Subsection "nonempty"
A predicate that determines if the file is empty. Uses \f(CW\*(C`\-s\*(C'\fR.
.SS "owned"
.IX Subsection "owned"
Corresponds to \f(CW\*(C`\-o\*(C'\fR.
.SS "r_readable"
.IX Subsection "r_readable"
Corresponds to \f(CW\*(C`\-R\*(C'\fR.
.SS "r_writeable"
.IX Subsection "r_writeable"
.SS "r_writable"
.IX Subsection "r_writable"
Corresponds to \f(CW\*(C`\-W\*(C'\fR.
.SS "rdev"
.IX Subsection "rdev"
See \*(L"stat tests\*(R".
.SS "readable"
.IX Subsection "readable"
Corresponds to \f(CW\*(C`\-r\*(C'\fR.
.SS "setgid"
.IX Subsection "setgid"
Corresponds to \f(CW\*(C`\-g\*(C'\fR.
.SS "setuid"
.IX Subsection "setuid"
Corresponds to \f(CW\*(C`\-u\*(C'\fR.
.SS "size"
.IX Subsection "size"
See stat tests.
.SS "socket"
.IX Subsection "socket"
Corresponds to \f(CW\*(C`\-S\*(C'\fR.
.SS "sticky"
.IX Subsection "sticky"
Corresponds to \f(CW\*(C`\-k\*(C'\fR.
.SS "symlink"
.IX Subsection "symlink"
Corresponds to \f(CW\*(C`\-l\*(C'\fR.
.SS "uid"
.IX Subsection "uid"
See \*(L"stat tests\*(R".
.SS "tty"
.IX Subsection "tty"
Corresponds to \f(CW\*(C`\-t\*(C'\fR.
.SS "\fIwritable()\fP"
.IX Subsection "writable()"
Corresponds to \f(CW\*(C`\-w\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
The code relies on qr// compiled regexes, therefore this module
requires perl version 5.005_03 or newer.
.PP
Currently it isn't possible to remove a clause from a rule object.  If
this becomes a significant issue it will be addressed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Clamp <richardc@unixbeard.net> with input gained from this
use.perl discussion: http://use.perl.org/~richardc/journal/6467
.PP
Additional proofreading and input provided by Kake, Greg McCarroll,
and Andy Lester andy@petdance.com.
.PP
Ported to use File::Find::Object as File::Find::Object::Rule by
Shlomi Fish.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2002, 2003, 2004, 2006 Richard Clamp.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Find::Object, Text::Glob, Number::Compare, \fIfind\fR\|(1)
.PP
If you want to know about the procedural interface, see
File::Find::Object::Rule::Procedural, and if you have an idea for a neat
extension, see  File::Find::Object::Rule::Extending .
.PP
Path::Class::Rule Xs \s-1SEE ALSO\s0 contains a review of many directory traversal
modules on \s-1CPAN,\s0 including File::Find::Object::Rule and File::Find::Rule
(on which this module is based).
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
The tests don't run successfully when directly inside an old Subversion
checkout, due to the presence of \f(CW\*(C`.svn\*(C'\fR directories. \f(CW\*(C`./Build disttest\*(C'\fR or
\&\f(CW\*(C`./Build distruntest\*(C'\fR run fine.
