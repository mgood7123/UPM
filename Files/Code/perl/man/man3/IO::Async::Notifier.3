.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Async::Notifier 3"
.TH IO::Async::Notifier 3 "2017-10-01" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"IO::Async::Notifier" \- base class for IO::Async event objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Usually not directly used by a program, but one valid use case may be:
.PP
.Vb 1
\& use IO::Async::Notifier;
\&
\& use IO::Async::Stream;
\& use IO::Async::Signal;
\&
\& use IO::Async::Loop;
\& my $loop = IO::Async::Loop\->new;
\&
\& my $notifier = IO::Async::Notifier\->new;
\&
\& $notifier\->add_child(
\&    IO::Async::Stream\->new_for_stdin(
\&       on_read => sub {
\&          my $self = shift;
\&          my ( $buffref, $eof ) = @_;
\&
\&          while( $$buffref =~ s/^(.*)\en// ) {
\&             print "You said $1\en";
\&          }
\&
\&          return 0;
\&       },
\&    )
\& );
\&
\& $notifier\->add_child(
\&    IO::Async::Signal\->new(
\&       name => \*(AqINT\*(Aq,
\&       on_receipt => sub {
\&          print "Goodbye!\en";
\&          $loop\->stop;
\&       },
\&    )
\& );
\&
\& $loop\->add( $notifier );
\&
\& $loop\->run;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object class forms the basis for all the other event objects that an
IO::Async program uses. It provides the lowest level of integration with a
IO::Async::Loop container, and a facility to collect Notifiers together, in
a tree structure, where any Notifier can contain a collection of children.
.PP
Normally, objects in this class would not be directly used by an end program,
as it performs no actual \s-1IO\s0 work, and generates no actual events. These are all
left to the various subclasses, such as:
.IP "\(bu" 4
IO::Async::Handle \- event callbacks for a non-blocking file descriptor
.IP "\(bu" 4
IO::Async::Stream \- event callbacks and write bufering for a stream
filehandle
.IP "\(bu" 4
IO::Async::Socket \- event callbacks and send buffering for a socket
filehandle
.IP "\(bu" 4
IO::Async::Timer \- base class for Notifiers that use timed delays
.IP "\(bu" 4
IO::Async::Signal \- event callback on receipt of a \s-1POSIX\s0 signal
.IP "\(bu" 4
IO::Async::PID \- event callback on exit of a child process
.IP "\(bu" 4
IO::Async::Process \- start and manage a child process
.PP
For more detail, see the \s-1SYNOPSIS\s0 section in one of the above.
.PP
One case where this object class would be used, is when a library wishes to
provide a sub-component which consists of multiple other \f(CW\*(C`Notifier\*(C'\fR
subclasses, such as \f(CW\*(C`Handle\*(C'\fRs and \f(CW\*(C`Timers\*(C'\fR, but no particular object is
suitable to be the root of a tree. In this case, a plain \f(CW\*(C`Notifier\*(C'\fR object
can be used as the tree root, and all the other notifiers added as children of
it.
.SH "AS A MIXIN"
.IX Header "AS A MIXIN"
Rather than being used as a subclass this package also supports being used as
a non-principle superclass for an object, as a mix-in. It still provides
methods and satisfies an \f(CW\*(C`isa\*(C'\fR test, even though the constructor is not
directly called. This simply requires that the object be based on a normal
blessed hash reference and include \f(CW\*(C`IO::Async::Notifier\*(C'\fR somewhere in its
\&\f(CW@ISA\fR list.
.PP
The methods in this class all use only keys in the hash prefixed by
\&\f(CW"IO_Async_Notifier_\|_"\fR for namespace purposes.
.PP
This is intended mainly for defining a subclass of some other object that is
also an \f(CW\*(C`IO::Async::Notifier\*(C'\fR, suitable to be added to an IO::Async::Loop.
.PP
.Vb 2
\& package SomeEventSource::Async;
\& use base qw( SomeEventSource IO::Async::Notifier );
\&
\& sub _add_to_loop
\& {
\&    my $self = shift;
\&    my ( $loop ) = @_;
\&
\&    # Code here to set up event handling on $loop that may be required
\& }
\&
\& sub _remove_from_loop
\& {
\&    my $self = shift;
\&    my ( $loop ) = @_;
\&
\&    # Code here to undo the event handling set up above
\& }
.Ve
.PP
Since all the methods documented here will be available, the implementation
may wish to use the \f(CW\*(C`configure\*(C'\fR and \f(CW\*(C`make_event_cb\*(C'\fR or \f(CW\*(C`invoke_event\*(C'\fR
methods to implement its own event callbacks.
.SH "EVENTS"
.IX Header "EVENTS"
The following events are invoked, either using subclass methods or \s-1CODE\s0
references in parameters:
.ie n .SS "on_error $message, $name, @details"
.el .SS "on_error \f(CW$message\fP, \f(CW$name\fP, \f(CW@details\fP"
.IX Subsection "on_error $message, $name, @details"
Invoked by \f(CW\*(C`invoke_error\*(C'\fR.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
A specific subclass of \f(CW\*(C`IO::Async::Notifier\*(C'\fR defines named parameters that
control its behaviour. These may be passed to the \f(CW\*(C`new\*(C'\fR constructor, or to
the \f(CW\*(C`configure\*(C'\fR method. The documentation on each specific subclass will give
details on the parameters that exist, and their uses. Some parameters may only
support being set once at construction time, or only support being changed if
the object is in a particular state.
.PP
The following parameters are supported by all Notifiers:
.IP "on_error => \s-1CODE\s0" 8
.IX Item "on_error => CODE"
\&\s-1CODE\s0 reference for event handler.
.IP "notifier_name => \s-1STRING\s0" 8
.IX Item "notifier_name => STRING"
Optional string used to identify this particular Notifier. This value will be
returned by the \f(CW\*(C`notifier_name\*(C'\fR method.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
.Vb 1
\&   $notifier = IO::Async::Notifier\->new( %params )
.Ve
.PP
This function returns a new instance of a \f(CW\*(C`IO::Async::Notifier\*(C'\fR object with
the given initial values of the named parameters.
.PP
Up until IO::Async version 0.19, this module used to implement the \s-1IO\s0
handle features now found in the IO::Async::Handle subclass. Code that
needs to use any of \f(CW\*(C`handle\*(C'\fR, \f(CW\*(C`read_handle\*(C'\fR, \f(CW\*(C`write_handle\*(C'\fR,
\&\f(CW\*(C`on_read_ready\*(C'\fR or \f(CW\*(C`on_write_ready\*(C'\fR should use IO::Async::Handle instead.
.SH "METHODS"
.IX Header "METHODS"
.SS "configure"
.IX Subsection "configure"
.Vb 1
\&   $notifier\->configure( %params )
.Ve
.PP
Adjust the named parameters of the \f(CW\*(C`Notifier\*(C'\fR as given by the \f(CW%params\fR
hash.
.SS "loop"
.IX Subsection "loop"
.Vb 1
\&   $loop = $notifier\->loop
.Ve
.PP
Returns the IO::Async::Loop that this Notifier is a member of.
.SS "notifier_name"
.IX Subsection "notifier_name"
.Vb 1
\&   $name = $notifier\->notifier_name
.Ve
.PP
Returns the name to identify this Notifier. If a has not been set, it will
return the empty string. Subclasses may wish to override this behaviour to
return some more useful information, perhaps from configured parameters.
.SS "adopt_future"
.IX Subsection "adopt_future"
.Vb 1
\&   $f = $notifier\->adopt_future( $f )
.Ve
.PP
Stores a reference to the Future instance within the notifier itself, so
the reference doesn't get lost. This reference will be dropped when the future
becomes ready (either by success or failure). Additionally, if the future
failed the notifier's \f(CW\*(C`invoke_error\*(C'\fR method will be informed.
.PP
This means that if the notifier does not provide an \f(CW\*(C`on_error\*(C'\fR handler, nor
is there one anywhere in the parent chain, this will be fatal to the caller of
\&\f(CW\*(C`$f\->fail\*(C'\fR. To avoid this being fatal if the failure is handled
elsewhere, use the \f(CW\*(C`else_done\*(C'\fR method on the future to obtain a sequence one
that never fails.
.PP
.Vb 1
\& $notifier\->adopt_future( $f\->else_done() )
.Ve
.PP
The future itself is returned.
.SH "CHILD NOTIFIERS"
.IX Header "CHILD NOTIFIERS"
During the execution of a program, it may be the case that certain \s-1IO\s0 handles
cause other handles to be created; for example, new sockets that have been
\&\f(CW\*(C`accept()\*(C'\fRed from a listening socket. To facilitate these, a notifier may
contain child notifier objects, that are automatically added to or removed
from the IO::Async::Loop that manages their parent.
.SS "parent"
.IX Subsection "parent"
.Vb 1
\&   $parent = $notifier\->parent
.Ve
.PP
Returns the parent of the notifier, or \f(CW\*(C`undef\*(C'\fR if does not have one.
.SS "children"
.IX Subsection "children"
.Vb 1
\&   @children = $notifier\->children
.Ve
.PP
Returns a list of the child notifiers contained within this one.
.SS "add_child"
.IX Subsection "add_child"
.Vb 1
\&   $notifier\->add_child( $child )
.Ve
.PP
Adds a child notifier. This notifier will be added to the containing loop, if
the parent has one. Only a notifier that does not currently have a parent and
is not currently a member of any loop may be added as a child. If the child
itself has grandchildren, these will be recursively added to the containing
loop.
.SS "remove_child"
.IX Subsection "remove_child"
.Vb 1
\&   $notifier\->remove_child( $child )
.Ve
.PP
Removes a child notifier. The child will be removed from the containing loop,
if the parent has one. If the child itself has grandchildren, these will be
recurively removed from the loop.
.SS "remove_from_parent"
.IX Subsection "remove_from_parent"
.Vb 1
\&   $notifier\->remove_from_parent
.Ve
.PP
Removes this notifier object from its parent (either another notifier object
or the containing loop) if it has one. If the notifier is not a child of
another notifier nor a member of a loop, this method does nothing.
.SH "SUBCLASS METHODS"
.IX Header "SUBCLASS METHODS"
\&\f(CW\*(C`IO::Async::Notifier\*(C'\fR is a base class provided so that specific subclasses of
it provide more specific behaviour. The base class provides a number of
methods that subclasses may wish to override.
.PP
If a subclass implements any of these, be sure to invoke the superclass method
at some point within the code.
.SS "_init"
.IX Subsection "_init"
.Vb 1
\&   $notifier\->_init( $paramsref )
.Ve
.PP
This method is called by the constructor just before calling \f(CW\*(C`configure\*(C'\fR.
It is passed a reference to the \s-1HASH\s0 storing the constructor arguments.
.PP
This method may initialise internal details of the Notifier as required,
possibly by using parameters from the \s-1HASH.\s0 If any parameters are
construction-only they should be \f(CW\*(C`delete\*(C'\fRd from the hash.
.SS "configure"
.IX Subsection "configure"
.Vb 1
\&   $notifier\->configure( %params )
.Ve
.PP
This method is called by the constructor to set the initial values of named
parameters, and by users of the object to adjust the values once constructed.
.PP
This method should \f(CW\*(C`delete\*(C'\fR from the \f(CW%params\fR hash any keys it has dealt
with, then pass the remaining ones to the \f(CW\*(C`SUPER::configure\*(C'\fR. The base
class implementation will throw an exception if there are any unrecognised
keys remaining.
.SS "configure_unknown"
.IX Subsection "configure_unknown"
.Vb 1
\&   $notifier\->configure_unknown( %params )
.Ve
.PP
This method is called by the base class \f(CW\*(C`configure\*(C'\fR method, for any remaining
parameters that are not recognised. The default implementation throws an
exception using \f(CW\*(C`Carp\*(C'\fR that lists the unrecognised keys. This method is
provided to allow subclasses to override the behaviour, perhaps to store
unrecognised keys, or to otherwise inspect the left-over arguments for some
other purpose.
.SS "_add_to_loop"
.IX Subsection "_add_to_loop"
.Vb 1
\&   $notifier\->_add_to_loop( $loop )
.Ve
.PP
This method is called when the Notifier has been added to a Loop; either
directly, or indirectly through being a child of a Notifer already in a loop.
.PP
This method may be used to perform any initial startup activity required for
the Notifier to be fully functional but which requires a Loop to do so.
.SS "_remove_from_loop"
.IX Subsection "_remove_from_loop"
.Vb 1
\&   $notifier\->_remove_from_loop( $loop )
.Ve
.PP
This method is called when the Notifier has been removed from a Loop; either
directly, or indirectly through being a child of a Notifier removed from the
loop.
.PP
This method may be used to undo the effects of any setup that the
\&\f(CW\*(C`_add_to_loop\*(C'\fR method had originally done.
.SH "UTILITY METHODS"
.IX Header "UTILITY METHODS"
.SS "_capture_weakself"
.IX Subsection "_capture_weakself"
.Vb 1
\&   $mref = $notifier\->_capture_weakself( $code )
.Ve
.PP
Returns a new \s-1CODE\s0 ref which, when invoked, will invoke the originally-passed
ref, with additionally a reference to the Notifier as its first argument. The
Notifier reference is stored weakly in \f(CW$mref\fR, so this \s-1CODE\s0 ref may be
stored in the Notifier itself without creating a cycle.
.PP
For example,
.PP
.Vb 4
\& my $mref = $notifier\->_capture_weakself( sub {
\&    my ( $notifier, $arg ) = @_;
\&    print "Notifier $notifier got argument $arg\en";
\& } );
\&
\& $mref\->( 123 );
.Ve
.PP
This is provided as a utility for Notifier subclasses to use to build a
callback CODEref to pass to a Loop method, but which may also want to store
the \s-1CODE\s0 ref internally for efficiency.
.PP
The \f(CW$code\fR argument may also be a plain string, which will be used as a
method name; the returned \s-1CODE\s0 ref will then invoke that method on the object.
In this case the method name is stored symbolically in the returned \s-1CODE\s0
reference, and dynamically dispatched each time the reference is invoked. This
allows it to follow code reloading, dynamic replacement of class methods, or
other similar techniques.
.PP
If the \f(CW$mref\fR \s-1CODE\s0 reference is being stored in some object other than the
one it refers to, remember that since the Notifier is only weakly captured, it
is possible that it has been destroyed by the time the code runs, and so the
reference will be passed as \f(CW\*(C`undef\*(C'\fR. This should be protected against by the
code body.
.PP
.Vb 5
\& $other_object\->{on_event} = $notifier\->_capture_weakself( sub {
\&    my $notifier = shift or return;
\&    my ( @event_args ) = @_;
\&    ...
\& } );
.Ve
.PP
For stand-alone generic implementation of this behaviour, see also curry
and \f(CW\*(C`curry::weak\*(C'\fR.
.SS "_replace_weakself"
.IX Subsection "_replace_weakself"
.Vb 1
\&   $mref = $notifier\->_replace_weakself( $code )
.Ve
.PP
Returns a new \s-1CODE\s0 ref which, when invoked, will invoke the originally-passed
ref, with a reference to the Notifier replacing its first argument. The
Notifier reference is stored weakly in \f(CW$mref\fR, so this \s-1CODE\s0 ref may be
stored in the Notifier itself without creating a cycle.
.PP
For example,
.PP
.Vb 4
\& my $mref = $notifier\->_replace_weakself( sub {
\&    my ( $notifier, $arg ) = @_;
\&    print "Notifier $notifier got argument $arg\en";
\& } );
\&
\& $mref\->( $object, 123 );
.Ve
.PP
This is provided as a utility for Notifier subclasses to use for event
callbacks on other objects, where the delegated object is passed in the
function's arguments.
.PP
The \f(CW$code\fR argument may also be a plain string, which will be used as a
method name; the returned \s-1CODE\s0 ref will then invoke that method on the object.
As with \f(CW\*(C`_capture_weakself\*(C'\fR this is stored symbolically.
.PP
As with \f(CW\*(C`_capture_weakself\*(C'\fR, care should be taken against Notifier
destruction if the \f(CW$mref\fR \s-1CODE\s0 reference is stored in some other object.
.SS "can_event"
.IX Subsection "can_event"
.Vb 1
\&   $code = $notifier\->can_event( $event_name )
.Ve
.PP
Returns a \f(CW\*(C`CODE\*(C'\fR reference if the object can perform the given event name,
either by a configured \f(CW\*(C`CODE\*(C'\fR reference parameter, or by implementing a
method. If the object is unable to handle this event, \f(CW\*(C`undef\*(C'\fR is returned.
.SS "make_event_cb"
.IX Subsection "make_event_cb"
.Vb 1
\&   $callback = $notifier\->make_event_cb( $event_name )
.Ve
.PP
Returns a \f(CW\*(C`CODE\*(C'\fR reference which, when invoked, will execute the given event
handler. Event handlers may either be subclass methods, or parameters given to
the \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`configure\*(C'\fR method.
.PP
The event handler can be passed extra arguments by giving them to the \f(CW\*(C`CODE\*(C'\fR
reference; the first parameter received will be a reference to the notifier
itself. This is stored weakly in the closure, so it is safe to store the
resulting \f(CW\*(C`CODE\*(C'\fR reference in the object itself without causing a reference
cycle.
.SS "maybe_make_event_cb"
.IX Subsection "maybe_make_event_cb"
.Vb 1
\&   $callback = $notifier\->maybe_make_event_cb( $event_name )
.Ve
.PP
Similar to \f(CW\*(C`make_event_cb\*(C'\fR but will return \f(CW\*(C`undef\*(C'\fR if the object cannot
handle the named event, rather than throwing an exception.
.SS "invoke_event"
.IX Subsection "invoke_event"
.Vb 1
\&   @ret = $notifier\->invoke_event( $event_name, @args )
.Ve
.PP
Invokes the given event handler, passing in the given arguments. Event
handlers may either be subclass methods, or parameters given to the \f(CW\*(C`new\*(C'\fR or
\&\f(CW\*(C`configure\*(C'\fR method. Returns whatever the underlying method or \s-1CODE\s0 reference
returned.
.SS "maybe_invoke_event"
.IX Subsection "maybe_invoke_event"
.Vb 1
\&   $retref = $notifier\->maybe_invoke_event( $event_name, @args )
.Ve
.PP
Similar to \f(CW\*(C`invoke_event\*(C'\fR but will return \f(CW\*(C`undef\*(C'\fR if the object cannot
handle the name event, rather than throwing an exception. In order to
distinguish this from an event-handling function that simply returned
\&\f(CW\*(C`undef\*(C'\fR, if the object does handle the event, the list that it returns will
be returned in an \s-1ARRAY\s0 reference.
.SH "DEBUGGING SUPPORT"
.IX Header "DEBUGGING SUPPORT"
.SS "debug_printf"
.IX Subsection "debug_printf"
.Vb 1
\&   $notifier\->debug_printf( $format, @args )
.Ve
.PP
Conditionally print a debugging message to \f(CW\*(C`STDERR\*(C'\fR if debugging is enabled.
If such a message is printed, it will be printed using \f(CW\*(C`printf\*(C'\fR using the
given format and arguments. The message will be prefixed with a string, in
square brackets, to help identify the \f(CW$notifier\fR instance. This string will
be the class name of the notifier, and any parent notifiers it is contained
by, joined by an arrow \f(CW\*(C`<\-\*(C'\fR. To ensure this string does not grow too
long, certain prefixes are abbreviated:
.PP
.Vb 3
\& IO::Async::Protocol::  =>  IaP:
\& IO::Async::            =>  Ia:
\& Net::Async::           =>  Na:
.Ve
.PP
Finally, each notifier that has a name defined using the \f(CW\*(C`notifier_name\*(C'\fR
parameter has that name appended in braces.
.PP
For example, invoking
.PP
.Vb 1
\& $stream\->debug_printf( "EVENT on_read" )
.Ve
.PP
On an IO::Async::Stream instance reading and writing a file descriptor
whose \f(CW\*(C`fileno\*(C'\fR is 4, which is a child of an IO::Async::Protocol::Stream,
will produce a line of output:
.PP
.Vb 1
\& [Ia:Stream{rw=4}<\-IaP:Stream] EVENT on_read
.Ve
.SS "invoke_error"
.IX Subsection "invoke_error"
.Vb 1
\&   $notifier\->invoke_error( $message, $name, @details )
.Ve
.PP
Invokes the stored \f(CW\*(C`on_error\*(C'\fR event handler, passing in the given arguments.
If no handler is defined, it will be passed up to the containing parent
notifier, if one exists. If no parent exists, the error message will be thrown
as an exception by using \f(CW\*(C`die()\*(C'\fR and this method will not return.
.PP
If a handler is found to handle this error, the method will return as normal.
However, as the expected use-case is to handle \*(L"fatal\*(R" errors that now render
the notifier unsuitable to continue, code should be careful not to perform any
further work after invoking it. Specifically, sockets may become disconnected,
or the entire notifier may now be removed from its containing loop.
.PP
The \f(CW$name\fR and \f(CW@details\fR list should follow similar semantics to Future
failures. That is, the \f(CW$name\fR should be a string giving a category of
failure, and the \f(CW@details\fR list should contain additional arguments that
relate to that kind of failure.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
