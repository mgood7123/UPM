.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Test::MockRandom 3"
.TH Test::MockRandom 3 "2014-02-08" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::MockRandom \- Replaces random number generation with non\-random number generation
.SH "VERSION"
.IX Header "VERSION"
version 1.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&   # intercept rand in another package
\&   use Test::MockRandom \*(AqSome::Other::Package\*(Aq;
\&   use Some::Other::Package; # exports sub foo { return rand }
\&   srand(0.13);
\&   foo(); # returns 0.13
\& 
\&   # using a seed list and "oneish"
\&   srand(0.23, 0.34, oneish() );
\&   foo(); # returns 0.23
\&   foo(); # returns 0.34
\&   foo(); # returns a number just barely less than one
\&   foo(); # returns 0, as the seed array is empty
\& 
\&   # object\-oriented, for use in the current package
\&   use Test::MockRandom ();
\&   my $nrng = Test::MockRandom\->new(0.42, 0.23);
\&   $nrng\->rand(); # returns 0.42
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This perhaps ridiculous-seeming module was created to test routines that
manipulate random numbers by providing a known output from \f(CW\*(C`rand\*(C'\fR.  Given a
list of seeds with \f(CW\*(C`srand\*(C'\fR, it will return each in turn.  After seeded random
numbers are exhausted, it will always return 0.  Seed numbers must be of a form
that meets the expected output from \f(CW\*(C`rand\*(C'\fR as called with no arguments \*(-- i.e.
they must be between 0 (inclusive) and 1 (exclusive).  In order to facilitate
generating and testing a nearly-one number, this module exports the function
\&\f(CW\*(C`oneish\*(C'\fR, which returns a number just fractionally less than one.
.PP
Depending on how this module is called with \f(CW\*(C`use\*(C'\fR, it will export \f(CW\*(C`rand\*(C'\fR to a
specified package (e.g. a class being tested) effectively overriding and
intercepting calls in that package to the built-in \f(CW\*(C`rand\*(C'\fR.  It can also
override \f(CW\*(C`rand\*(C'\fR in the current package or even globally.  In all
of these cases, it also exports \f(CW\*(C`srand\*(C'\fR and \f(CW\*(C`oneish\*(C'\fR to the current package
in order to control the output of \f(CW\*(C`rand\*(C'\fR.  See \*(L"\s-1USAGE\*(R"\s0 for details.
.PP
Alternatively, this module can be used to generate objects, with each object
maintaining its own distinct seed array.
.SH "USAGE"
.IX Header "USAGE"
By default, Test::MockRandom does not export any functions.  This still allows
object-oriented use by calling \f(CW\*(C`Test::MockRandom\->new(@seeds)\*(C'\fR.  In order
for Test::MockRandom to be more useful, arguments must be provided during the
call to \f(CW\*(C`use\*(C'\fR.
.SS "use Test::MockRandom 'Target::Package'"
.IX Subsection "use Test::MockRandom 'Target::Package'"
The simplest way to intercept \f(CW\*(C`rand\*(C'\fR in another package is to provide the
name(s) of the package(s) for interception as arguments in the \f(CW\*(C`use\*(C'\fR
statement.  This will export \f(CW\*(C`rand\*(C'\fR to the listed packages and will export
\&\f(CW\*(C`srand\*(C'\fR and \f(CW\*(C`oneish\*(C'\fR to the current package to control the behavior of
\&\f(CW\*(C`rand\*(C'\fR.  You \fBmust\fR \f(CW\*(C`use\*(C'\fR Test::MockRandom before you \f(CW\*(C`use\*(C'\fR the target
package.  This is a typical case for testing a module that uses random numbers:
.PP
.Vb 3
\&  use Test::More \*(Aqno_plan\*(Aq;
\&  use Test::MockRandom \*(AqSome::Package\*(Aq;
\&  BEGIN { use_ok( Some::Package ) }
\& 
\&  # assume sub foo { return rand } was imported from Some::Package
\& 
\&  srand(0.5)
\&  is( foo(), 0.5, "is foo() 0.5?") # test gives "ok"
.Ve
.PP
If multiple package names are specified, \f(CW\*(C`rand\*(C'\fR will be exported to all
of them.
.PP
If you wish to export \f(CW\*(C`rand\*(C'\fR to the current package, simply provide
\&\f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR as the parameter for \f(CW\*(C`use\*(C'\fR, or \f(CW\*(C`main\*(C'\fR if importing
to a script without a specified package.  This can be part of a
list provided to \f(CW\*(C`use\*(C'\fR.  All of the following idioms work:
.PP
.Vb 2
\&  use Test::MockRandom qw( main Some::Package ); # Assumes a script
\&  use Test::MockRandom _\|_PACKAGE_\|_, \*(AqSome::Package\*(Aq;
\& 
\&  # The following doesn\*(Aqt interpolate _\|_PACKAGE_\|_ as above, but 
\&  # Test::MockRandom will still DWIM and handle it correctly
\& 
\&  use Test::MockRandom qw( _\|_PACKAGE_\|_ Some::Package );
.Ve
.ie n .SS "use Test::MockRandom %customized"
.el .SS "use Test::MockRandom \f(CW%customized\fP"
.IX Subsection "use Test::MockRandom %customized"
As an alternative to a package name as an argument to \f(CW\*(C`use\*(C'\fR,
Test::MockRandom will also accept a hash reference with a custom
set of instructions for how to export functions:
.PP
.Vb 5
\&  use Test::MockRandom {
\&     rand   => [ Some::Package, {Another::Package => \*(Aqrandom\*(Aq} ],
\&     srand  => { Another::Package => \*(Aqseed\*(Aq }, 
\&     oneish => _\|_PACKAGE_\|_
\&  };
.Ve
.PP
The keys of the hash may be any of \f(CW\*(C`rand\*(C'\fR, \f(CW\*(C`srand\*(C'\fR, and \f(CW\*(C`oneish\*(C'\fR.  The
values of the hash give instructions for where to export the symbol
corresponding to the key.  These are interpreted as follows, depending on their
type:
.IP "\(bu" 4
String: a package to which Test::MockRandom will export the symbol
.IP "\(bu" 4
Hash Reference: the key is the package to which Test::MockRandom will export
the symbol and the value is the name under which it will be exported
.IP "\(bu" 4
Array Reference: a list of strings or hash references which will be handled
as above
.SS "Test::MockRandom\->\fIexport_rand_to()\fP"
.IX Subsection "Test::MockRandom->export_rand_to()"
In order to intercept the built-in \f(CW\*(C`rand\*(C'\fR in another package, 
Test::MockRandom must export its own \f(CW\*(C`rand\*(C'\fR function to the 
target package \fBbefore\fR the target package is compiled, thus overriding
calls to the built-in.  The simple approach (described above) of providing the
target package name in the \f(CW\*(C`use Test::MockRandom\*(C'\fR statement accomplishes this
because \f(CW\*(C`use\*(C'\fR is equivalent to a \f(CW\*(C`require\*(C'\fR and \f(CW\*(C`import\*(C'\fR within a \f(CW\*(C`BEGIN\*(C'\fR
block.  To explicitly intercept \f(CW\*(C`rand\*(C'\fR in another package, you can also call
\&\f(CW\*(C`export_rand_to\*(C'\fR, but it must be enclosed in a \f(CW\*(C`BEGIN\*(C'\fR block of its own.  The
explicit form also support function aliasing just as with the custom approach
with \f(CW\*(C`use\*(C'\fR, described above:
.PP
.Vb 3
\&  use Test::MockRandom;
\&  BEGIN {Test::MockRandom\->export_rand_to(\*(AqAnotherPackage\*(Aq=>\*(Aqrandom\*(Aq)}
\&  use AnotherPackage;
.Ve
.PP
This \f(CW\*(C`BEGIN\*(C'\fR block must not include a \f(CW\*(C`use\*(C'\fR statement for the package to be
intercepted, or perl will compile the package to be intercepted before the
\&\f(CW\*(C`export_rand_to\*(C'\fR function has a chance to execute and intercept calls to 
the built-in \f(CW\*(C`rand\*(C'\fR.  This is very important in testing.  The \f(CW\*(C`export_rand_to\*(C'\fR
call must be in a separate \f(CW\*(C`BEGIN\*(C'\fR block from a \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`use_ok\*(C'\fR test,
which should be enclosed in a \f(CW\*(C`BEGIN\*(C'\fR block of its own:
.PP
.Vb 4
\&  use Test::More tests => 1;
\&  use Test::MockRandom;
\&  BEGIN { Test::MockRandom\->export_rand_to( \*(AqAnotherPackage\*(Aq ); }
\&  BEGIN { use_ok( \*(AqAnotherPackage\*(Aq ); }
.Ve
.PP
Given these cautions, it's probably best to use either the simple or custom
approach with \f(CW\*(C`use\*(C'\fR, which does the right thing in most circumstances.  Should
additional explicit customization be necessary, Test::MockRandom also provides
\&\f(CW\*(C`export_srand_to\*(C'\fR and \f(CW\*(C`export_oneish_to\*(C'\fR.
.ie n .SS "Overriding ""rand"" globally: use Test::MockRandom '\s-1CORE::GLOBAL\s0'"
.el .SS "Overriding \f(CWrand\fP globally: use Test::MockRandom '\s-1CORE::GLOBAL\s0'"
.IX Subsection "Overriding rand globally: use Test::MockRandom 'CORE::GLOBAL'"
This is just like intercepting \f(CW\*(C`rand\*(C'\fR in a package, except that you
do it globally by overriding the built-in function in \f(CW\*(C`CORE::GLOBAL\*(C'\fR.
.PP
.Vb 1
\&  use Test::MockRandom \*(AqCORE::GLOBAL\*(Aq;
\& 
\&  # or
\& 
\&  BEGIN { Test::MockRandom\->export_rand_to(\*(AqCORE::GLOBAL\*(Aq) }
.Ve
.PP
You can always access the real, built-in \f(CW\*(C`rand\*(C'\fR by calling it explicitly as
\&\f(CW\*(C`CORE::rand\*(C'\fR.
.ie n .SS "Intercepting ""rand"" in a package that also contains a ""rand"" function"
.el .SS "Intercepting \f(CWrand\fP in a package that also contains a \f(CWrand\fP function"
.IX Subsection "Intercepting rand in a package that also contains a rand function"
This is tricky as the order in which the symbol table is manipulated will lead
to very different results.  This can be done safely (maybe) if the module uses
the same rand syntax/prototype as the system call but offers them up as method
calls which resolve at run-time instead of compile time.  In this case, you
will need to do an explicit intercept (as above) but do it \fBafter\fR importing
the package.  I.e.:
.PP
.Vb 3
\&  use Test::MockRandom \*(AqSomeRandPackage\*(Aq;
\&  use SomeRandPackage;
\&  BEGIN { Test::MockRandom\->export_rand_to(\*(AqSomeRandPackage\*(Aq);
.Ve
.PP
The first line is necessary to get \f(CW\*(C`srand\*(C'\fR and \f(CW\*(C`oneish\*(C'\fR exported to
the current package.  The second line will define a \f(CW\*(C`sub rand\*(C'\fR in 
\&\f(CW\*(C`SomeRandPackage\*(C'\fR, overriding the results of the first line.  The third
line then re-overrides the \f(CW\*(C`rand\*(C'\fR.  You may see warnings about \f(CW\*(C`rand\*(C'\fR 
being redefined.
.PP
Depending on how your \f(CW\*(C`rand\*(C'\fR is written and used, there is a good likelihood
that this isn't going to do what you're expecting, no matter what.  If your
package that defines \f(CW\*(C`rand\*(C'\fR relies internally upon the system
\&\f(CW\*(C`CORE::GLOBAL::rand\*(C'\fR function, then you may be best off overriding that
instead.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
.Vb 1
\&  $obj = new( LIST OF SEEDS );
.Ve
.PP
Returns a new Test::MockRandom object with the specified list of seeds.
.ie n .SS """srand"""
.el .SS "\f(CWsrand\fP"
.IX Subsection "srand"
.Vb 2
\&  srand( LIST OF SEEDS );
\&  $obj\->srand( LIST OF SEEDS);
.Ve
.PP
If called as a bare function call or package method, sets the seed list
for bare/package calls to \f(CW\*(C`rand\*(C'\fR.  If called as an object method,
sets the seed list for that object only.
.ie n .SS """rand"""
.el .SS "\f(CWrand\fP"
.IX Subsection "rand"
.Vb 3
\&  $rv = rand();
\&  $rv = $obj\->rand();
\&  $rv = rand(3);
.Ve
.PP
If called as a bare or package function, returns the next value from the
package seed list.  If called as an object method, returns the next value from
the object seed list.
.PP
If \f(CW\*(C`rand\*(C'\fR is called with a numeric argument, it follows the same behavior as
the built-in function \*(-- it multiplies the argument with the next value from
the seed array (resulting in a random fractional value between 0 and the
argument, just like the built-in).  If the argument is 0, undef, or
non-numeric, it is treated as if the argument is 1.
.PP
Using this with an argument in testing may be complicated, as limits in
floating point precision mean that direct numeric comparisons are not reliable.
E.g.
.PP
.Vb 2
\&  srand(1/3);
\&  rand(3);       # does this return 1.0 or .999999999 etc.
.Ve
.ie n .SS """oneish"""
.el .SS "\f(CWoneish\fP"
.IX Subsection "oneish"
.Vb 2
\&  srand( oneish() );
\&  if ( rand() == oneish() ) { print "It\*(Aqs almost one." };
.Ve
.PP
A utility function to return a nearly-one value.  Equal to ( 2^32 \- 1 ) / 2^32.
Useful in \f(CW\*(C`srand\*(C'\fR and test functions.
.ie n .SS """export_rand_to"""
.el .SS "\f(CWexport_rand_to\fP"
.IX Subsection "export_rand_to"
.Vb 2
\&  Test::MockRandom\->export_rand_to( \*(AqSome::Class\*(Aq );
\&  Test::MockRandom\->export_rand_to( \*(AqSome::Class\*(Aq => \*(Aqrandom\*(Aq );
.Ve
.PP
This function exports \f(CW\*(C`rand\*(C'\fR into the specified package namespace.  It must be
called as a class function.  If a second argument is provided, it is taken as
the symbol name used in the other package as the alias to \f(CW\*(C`rand\*(C'\fR:
.PP
.Vb 5
\&  use Test::MockRandom;
\&  BEGIN { Test::MockRandom\->export_rand_to( \*(AqSome::Class\*(Aq => \*(Aqrandom\*(Aq ); }
\&  use Some::Class;
\&  srand (0.5);
\&  print Some::Class::random(); # prints 0.5
.Ve
.PP
It can also be used to explicitly intercept \f(CW\*(C`rand\*(C'\fR after Test::MockRandom has
been loaded.  The effect of this function is highly dependent on when it is
called in the compile cycle and should usually called from within a \s-1BEGIN\s0
block.  See \*(L"\s-1USAGE\*(R"\s0 for details.
.PP
Most users will not need this function.
.ie n .SS """export_srand_to"""
.el .SS "\f(CWexport_srand_to\fP"
.IX Subsection "export_srand_to"
.Vb 2
\&  Test::MockRandom\->export_srand_to( \*(AqSome::Class\*(Aq );
\&  Test::MockRandom\->export_srand_to( \*(AqSome::Class\*(Aq => \*(Aqseed\*(Aq );
.Ve
.PP
This function exports \f(CW\*(C`srand\*(C'\fR into the specified package namespace.  It must be 
called as a class function.  If a second argument is provided, it is taken as
the symbol name to use in the other package as the alias for \f(CW\*(C`srand\*(C'\fR.
This function may be useful if another package wraps \f(CW\*(C`srand\*(C'\fR:
.PP
.Vb 4
\&  # In Some/Class.pm
\&  package Some::Class;
\&  sub seed { srand(shift) }
\&  sub foo  { rand }
\& 
\&  # In a script
\&  use Test::MockRandom \*(AqSome::Class\*(Aq;
\&  BEGIN { Test::MockRandom\->export_srand_to( \*(AqSome::Class\*(Aq ); }
\&  use Some::Class;
\&  seed(0.5);
\&  print foo();   # prints "0.5"
.Ve
.PP
The effect of this function is highly dependent on when it is called in the
compile cycle and should usually be called from within a \s-1BEGIN\s0 block.  See
\&\*(L"\s-1USAGE\*(R"\s0 for details.
.PP
Most users will not need this function.
.ie n .SS """export_oneish_to"""
.el .SS "\f(CWexport_oneish_to\fP"
.IX Subsection "export_oneish_to"
.Vb 2
\&  Test::MockRandom\->export_oneish_to( \*(AqSome::Class\*(Aq );
\&  Test::MockRandom\->export_oneish_to( \*(AqSome::Class\*(Aq => \*(Aqnearly_one\*(Aq );
.Ve
.PP
This function exports \f(CW\*(C`oneish\*(C'\fR into the specified package namespace.  It must
be called as a class function.  If a second argument is provided, it is taken
as the symbol name to use in the other package as the alias for \f(CW\*(C`oneish\*(C'\fR.  
Since \f(CW\*(C`oneish\*(C'\fR is usually only used in a test script, this function is likely
only necessary to alias \f(CW\*(C`oneish\*(C'\fR to some other name in the current package:
.PP
.Vb 5
\&  use Test::MockRandom \*(AqSome::Class\*(Aq;
\&  BEGIN { Test::MockRandom\->export_oneish_to( _\|_PACKAGE_\|_, "one" ); }
\&  use Some::Class;
\&  seed( one() );
\&  print foo();   # prints a value very close to one
.Ve
.PP
The effect of this function is highly dependent on when it is called in the
compile cycle and should usually be called from within a \s-1BEGIN\s0 block.  See
\&\*(L"\s-1USAGE\*(R"\s0 for details.
.PP
Most users will not need this function.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Test::MockObject
.IP "\(bu" 4
Test::MockModule
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/dagolden/Test\-MockRandom/issues>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/Test\-MockRandom>
.PP
.Vb 1
\&  git clone https://github.com/dagolden/Test\-MockRandom.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David Golden <dagolden@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2014 by David Golden.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
