.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Thread::Conveyor::Monitored 3"
.TH Thread::Conveyor::Monitored 3 "2010-09-19" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Thread::Conveyor::Monitored \- monitor a belt for specific content
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 0.14.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    use Thread::Conveyor::Monitored;
\&    my $mbelt = Thread::Conveyor::Monitored\->new(
\&     {
\&      monitor => sub { print "monitoring value $_[0]\en" }, # is a must
\&      pre => sub { print "prepare monitoring\en" },         # optional
\&      post => sub { print "stop monitoring\en" },           # optional
\&      belt => $belt,   # use existing belt, create new if not specified
\&      exit => \*(Aqexit\*(Aq,  # defaults to undef
\&
\&      checkpoint => sub { print "checkpointing\en" },
\&      frequency => 1000,
\&
\&      optimize => \*(Aqmemory\*(Aq, # optimization
\&      maxboxes => 50,       # specify throttling
\&      minboxes => 25,       # parameters
\&     }
\&    );
\&
\&    $mbelt\->put( "foo",[\*(Aqlistref\*(Aq],{\*(Aqhashref\*(Aq} );
\&    $mbelt\->put( undef ); # exit value by default
\&    $mbelt\->shutdown;
\&
\&    $mthread = $mbelt\->thread;
\&    $mtid = $mbelt\->tid;
\&
\&    $belt = $mbelt\->belt;
\&
\&    @post = $mthread\->join; # optional, wait for monitor thread to end
\&
\&    $belt = Thread::Conveyor::Monitored\->belt; # "pre", "do", "post"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 1
\&                 *** A note of CAUTION ***
\&
\& This module only functions on Perl versions 5.8.0 and later.
\& And then only when threads are enabled with \-Dusethreads.
\& It is of no use with any version of Perl before 5.8.0 or
\& without threads enabled.
\&
\&                 *************************
.Ve
.PP
The \f(CW\*(C`Thread::Conveyor::Monitored\*(C'\fR module implements a single worker thread
that takes of boxes of values from a belt created with Thread::Conveyor
and which checks the boxes for specific content.
.PP
It can be used for simply logging actions that are placed on the belt. Or
only output warnings if a certain value is encountered in a box.  Or create
a safe sandbox for Perl modules that are not thread-safe yet.
.PP
The action performed in the thread, is determined by a name or reference
to a subroutine.  This subroutine is called for every box of values obtained
from the belt.
.PP
Any number of threads can safely put boxes with values and reference on the
belt.
.PP
Optional checkpointing allows you to check and save intermediate status.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "new"
.IX Subsection "new"
.Vb 7
\& $mbelt = Thread::Conveyor::Monitored\->new(
\&  {
\&   pre => \e&pre,
\&   monitor => \*(Aqmonitor\*(Aq,
\&   post => \e&module::post,
\&   belt => $belt,   # use existing belt, create new if not specified
\&   exit => \*(Aqexit\*(Aq,  # defaults to undef
\&
\&   checkpoint => \e&checkpoint,
\&   frequency => 1000,
\&
\&   optimize => \*(Aqmemory\*(Aq,
\&   maxboxes => 50,
\&   minboxes => 25,
\&  },
\&  @parameters
\& );
.Ve
.PP
The \f(CW\*(C`new\*(C'\fR function creates a monitoring function on an existing or on a new
(empty) belt.  It returns the instantiated Thread::Conveyor::Monitored object.
.PP
The first input parameter is a reference to a hash that should at least
contain the \*(L"monitor\*(R" key with a subroutine reference.
.PP
The other input parameters are optional.  If specified, they are passed to the
the \*(L"pre\*(R" routine which is executed once when the monitoring is started.
.PP
The following field \fBmust\fR be specified in the hash reference:
.IP "do" 2
.IX Item "do"
.Vb 1
\& monitor => \*(Aqmonitor_the_belt\*(Aq, # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& monitor => \*(AqPackage::monitor_the_belt\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& monitor => \e&SomeOther::monitor_the_belt,
.Ve
.Sp
or:
.Sp
.Vb 1
\& monitor => sub {print "anonymous sub monitoring the belt\en"},
.Ve
.Sp
The \*(L"monitor\*(R" field specifies the subroutine to be executed for each set of
values that is removed from the belt.  It must be specified as either the
name of a subroutine or as a reference to a (anonymous) subroutine.
.Sp
The specified subroutine should expect the following parameters to be passed:
.Sp
.Vb 1
\& 1..N  set of values obtained from the box on the belt
.Ve
.Sp
What the subroutine does with the values, is entirely up to the developer.
.PP
The following fields are \fBoptional\fR in the hash reference:
.IP "pre" 2
.IX Item "pre"
.Vb 1
\& pre => \*(Aqprepare_monitoring\*(Aq,           # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& pre => \*(AqPackage::prepare_monitoring\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& pre => \e&SomeOther::prepare_monitoring,
.Ve
.Sp
or:
.Sp
.Vb 1
\& pre => sub {print "anonymous sub preparing the monitoring\en"},
.Ve
.Sp
The \*(L"pre\*(R" field specifies the subroutine to be executed once when the
monitoring of the belt is started.  It must be specified as either the
name of a subroutine or as a reference to a (anonymous) subroutine.
.Sp
The specified subroutine should expect the following parameters to be passed:
.Sp
.Vb 1
\& 1..N  any extra parameters that were passed with the call to L<new>.
.Ve
.IP "post" 2
.IX Item "post"
.Vb 1
\& post => \*(Aqstop_monitoring\*(Aq,             # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& post => \*(AqPackage::stop_monitoring\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& post => \e&SomeOther::stop_monitoring,
.Ve
.Sp
or:
.Sp
.Vb 1
\& post => sub {print "anonymous sub when stopping the monitoring\en"},
.Ve
.Sp
The \*(L"post\*(R" field specifies the subroutine to be executed once when the
monitoring of the belt is stopped.  It must be specified as either the
name of a subroutine or as a reference to a (anonymous) subroutine.
.Sp
The specified subroutine should expect the following parameters to be passed:
.Sp
.Vb 1
\& 1..N  any parameters that were passed with the call to L<new>.
.Ve
.Sp
Any values returned by the \*(L"post\*(R" routine, can be obtained with the \f(CW\*(C`join\*(C'\fR
method on the thread object.
.IP "belt" 2
.IX Item "belt"
.Vb 1
\& belt => $belt,  # create new one if not specified
.Ve
.Sp
The \*(L"belt\*(R" field specifies the Thread::Conveyor object that should be
monitored.  A new Thread::Conveyor object will be created if it is not
specified.
.IP "exit" 2
.IX Item "exit"
.Vb 1
\& exit => \*(Aqexit\*(Aq,   # defaults to undef
.Ve
.Sp
The \*(L"exit\*(R" field specifies the value that will cause the monitoring thread
to seize monitoring.  The \*(L"undef\*(R" value will be assumed if it is not specified.
This value should be put in a box on the belt to have the monitoring thread
stop.
.IP "checkpoint" 2
.IX Item "checkpoint"
.Vb 1
\& checkpoint => \*(Aqcheckpointing\*(Aq,                 # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& checkpoint => \*(AqPackage::checkpointing\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& checkpoint => \e&SomeOther::checkpointing,
.Ve
.Sp
or:
.Sp
.Vb 1
\& checkpoint => sub {print "anonymous sub to do checkpointing\en"},
.Ve
.Sp
The \*(L"checkpoint\*(R" field specifies the subroutine to be executed everytime a
checkpoint should be made (e.g. for saving or updating status).  It must be
specified as either the name of a subroutine or as a reference to a
(anonymous) subroutine.
.Sp
No checkpointing will occur by default.  The frequency of checkpointing can
be specified with the \*(L"frequency\*(R" field.
.Sp
The specified subroutine should not expect any parameters to be passed.  Any
values returned by the checkpointing routine, will be lost.
.IP "frequency" 2
.IX Item "frequency"
.Vb 1
\& frequency => 100,                             # default = 1000
.Ve
.Sp
The \*(L"frequency\*(R" field specifies the number of boxes that should have been
monitored before the \*(L"checkpoint\*(R" routine is called.  If a checkpoint routine
is specified but no frequency field is specified, then a frequency of \fB1000\fR
will be assumed.
.Sp
This field has no meaning if no checkpoint routine is specified with the
\&\*(L"checkpoint\*(R" field.  The default frequency can be changed with the frequency
method.
.IP "optimize" 2
.IX Item "optimize"
.Vb 1
\& optimize => \*(Aqcpu\*(Aq, # default: \*(Aqmemory\*(Aq
.Ve
.Sp
The \*(L"optimize\*(R" field specifies which implementation of the belt will be
selected if there is no existing belt specified with the 'belt' field.
Currently there are two choices: 'cpu' and 'memory'.  By default, the
\&\*(L"memory\*(R" optimization will be selected if no specific optmization is specified.
.Sp
You can call the class method optimize to change the default optimization.
.IP "maxboxes" 2
.IX Item "maxboxes"
.Vb 1
\& maxboxes => 50,
\&
\& maxboxes => undef,  # disable throttling
.Ve
.Sp
The \*(L"maxboxes\*(R" field specifies the \fBmaximum\fR number of boxes that can be
sitting on the belt to be handled (throttling).  If a new put would
exceed this amount, putting of boxes will be halted until the number of
boxes waiting to be handled has become at least as low as the amount
specified with the \*(L"minboxes\*(R" field.
.Sp
Fifty boxes will be assumed for the \*(L"maxboxes\*(R" field if it is not specified.
If you do not want to have any throttling, you can specify the value \*(L"undef\*(R"
for the field.  But beware!  If you do not have throttling active, you may
wind up using excessive amounts of memory used for storing all of the boxes
that have not been handled yet.
.Sp
The maxboxes method can be called to change the throttling settings
during the lifetime of the object.
.IP "minboxes" 2
.IX Item "minboxes"
.Vb 1
\& minboxes => 25, # default: maxboxes / 2
.Ve
.Sp
The \*(L"minboxes\*(R" field specified the \fBminimum\fR number of boxes that can be
waiting on the belt to be handled before the putting of boxes is allowed
again (throttling).
.Sp
If throttling is active and the \*(L"minboxes\*(R" field is not specified, then
half of the \*(L"maxboxes\*(R" value will be assumed.
.Sp
The minboxes method can be called to change the throttling settings
during the lifetime of the object.
.SS "belt"
.IX Subsection "belt"
.Vb 1
\& $belt = Thread::Conveyor::Monitored\->belt; # only within "pre" and "do"
.Ve
.PP
The class method \*(L"belt\*(R" returns the Thread::Conveyor::xxx object that this
thread is monitoring.  It is available within the \*(L"pre\*(R" and \*(L"do\*(R" subroutine
only.
.SS "frequency"
.IX Subsection "frequency"
.Vb 1
\& Thread::Conveyor::Monitored\->frequency( 100 );
\&
\& $frequency = Thread::Conveyor::Monitored\->frequency;
.Ve
.PP
The \*(L"frequency\*(R" class method allows you to specify the default frequency that
will be used when a checkpoint routine is specified with the \*(L"checkpoint\*(R"
field.  The default frequency is set to \fB1000\fR if no other value has been
previously specified.
.SS "optimize"
.IX Subsection "optimize"
.Vb 1
\& Thread::Conveyor::Monitored\->optimize( \*(Aqcpu\*(Aq );
\&
\& $optimize = Thread::Conveyor::Monitored\->optimize;
.Ve
.PP
The \*(L"optimize\*(R" class method allows you to specify the default optimization
type that will be used if no \*(L"optimize\*(R" field has been explicitely specified
with a call to new.  It returns the current default type of optimization.
.PP
Currently two types of optimization can be selected:
.IP "memory" 2
.IX Item "memory"
Attempt to use as little memory as possible.  Currently, this is achieved by
starting a seperate thread which hosts an unshared array.  This uses the
\&\*(L"Thread::Conveyor::Thread\*(R" sub-class.
.IP "cpu" 2
.IX Item "cpu"
Attempt to use as little \s-1CPU\s0 as possible.  Currently, this is achieved by
using a shared array (using the \*(L"Thread::Conveyor::Array\*(R" sub-class),
encapsulated in a hash reference if throttling is activated (then also using
the \*(L"Thread::Conveyor::Throttled\*(R" sub-class).
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.SS "put"
.IX Subsection "put"
.Vb 2
\& $mbelt\->put( $scalar,[],{} );
\& $mbelt\->put( \*(Aqexit\*(Aq ); # stop monitoring
.Ve
.PP
The \*(L"put\*(R" method freezes all specified parameters in a box and puts it on
the belt.  The monitoring thread will stop monitoring if the \*(L"exit\*(R" value
is put in the box.
.PP
Please note that if you need to be very efficient, it may be wortwhile to
extract the actual belt object first and use that to put boxes on the
belt.  The monitored \*(L"put\*(R" method is in fact only a gateway to the actual
belt that is inside this object.
.SS "maxboxes"
.IX Subsection "maxboxes"
.Vb 2
\& $mbelt\->maxboxes( 100 );
\& $maxboxes = $mbelt\->maxboxes;
.Ve
.PP
The \*(L"maxboxes\*(R" method returns the maximum number of boxes that can be on the
belt before throttling sets in.  The input value, if specified, specifies the
new maximum number of boxes that may be on the belt.  Throttling will be
switched off if the value \fBundef\fR is specified.
.PP
Specifying the \*(L"maxboxes\*(R" field when creating the object with new is
equivalent to calling this method.
.PP
The minboxes method can be called to specify the minimum number of boxes
that must be on the belt before the putting of boxes is allowed again after
reaching the maximum number of boxes.  By default, half of the \*(L"maxboxes\*(R"
value is assumed.
.SS "minboxes"
.IX Subsection "minboxes"
.Vb 2
\& $mbelt\->minboxes( 50 );
\& $minboxes = $mbelt\->minboxes;
.Ve
.PP
The \*(L"minboxes\*(R" method returns the minimum number of boxes that must be on the
belt before the putting of boxes is allowed again after reaching the maximum
number of boxes.  The input value, if specified, specifies the new minimum
number of boxes that must be on the belt.
.PP
Specifying the \*(L"minboxes\*(R" field when creating the object with new is
equivalent to calling this method.
.PP
The maxboxes method can be called to set the maximum number of boxes that
may be on the belt before the putting of boxes will be halted.
.SS "belt"
.IX Subsection "belt"
.Vb 1
\& $belt = $mbelt\->belt;
.Ve
.PP
The \*(L"belt\*(R" instance method returns the Thread::Conveyor::xxx object that
is being monitored.
.SS "frequency"
.IX Subsection "frequency"
.Vb 1
\& $frequency = $mbelt\->frequency;
.Ve
.PP
The \*(L"frequency\*(R" instance method returns the frequency with which the checkpoint
routine is being called.  Returns undef if no checkpointing is being done.
.SS "shutdown"
.IX Subsection "shutdown"
.Vb 1
\& $mbelt\->shutdown;
\&
\& @from_monitor_thread = $mbelt\->shutdown;
.Ve
.PP
The \*(L"shutdown\*(R" method performs an orderly shutdown of the belt.  It waits
until all of the boxes on the belt have been removed before it returns.
.PP
Whatever was returned by the \*(L"post\*(R" routine of the monitoring thread, will
also be returned by the \*(L"shutdown\*(R" method.
.SS "thread"
.IX Subsection "thread"
.Vb 1
\& $mthread = $mbelt\->thread;
.Ve
.PP
The \*(L"thread\*(R" method returns the thread object that is monitoring the contents
of the belt.
.SS "tid"
.IX Subsection "tid"
.Vb 1
\& $tid = $mbelt\->tid;
.Ve
.PP
The \*(L"tid\*(R" method returns the thread id of the thread object that is monitoring
the contents of the belt.
.SH "REQUIRED MODULES"
.IX Header "REQUIRED MODULES"
.Vb 2
\& load (any)
\& Thread::Conveyor (0.15)
.Ve
.SH "OPTIMIZATIONS"
.IX Header "OPTIMIZATIONS"
This module uses load to reduce memory and \s-1CPU\s0 usage. This causes
subroutines only to be compiled in a thread when they are actually needed at
the expense of more \s-1CPU\s0 when they need to be compiled.  Simple benchmarks
however revealed that the overhead of the compiling single routines is not
much more (and sometimes a lot less) than the overhead of cloning a Perl
interpreter with a lot of subroutines pre-loaded.
.SH "CAVEATS"
.IX Header "CAVEATS"
You cannot remove any boxes from the belt, as that is done by the monitoring
thread.  Therefore, the methods \*(L"take\*(R", \*(L"take_dontwait\*(R", \*(L"peek\*(R" and
\&\*(L"peek_dontwait\*(R" are disabled on this object.
.PP
Passing unshared values between threads is accomplished by serializing the
specified values using Thread::Serialize.  Please see the \s-1CAVEATS\s0 section
there for an up-to-date status of what can be passed around between threads.
.SH "AUTHOR"
.IX Header "AUTHOR"
Elizabeth Mattijsen, <liz@dijkmat.nl>.
.PP
Please report bugs to <perlbugs@dijkmat.nl>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2003, 2007, 2010 Elizabeth Mattijsen <liz@dijkmat.nl>.
All rights reserved.  This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
threads, threads::shared, Thread::Conveyor, Thread::Serialize,
load.
