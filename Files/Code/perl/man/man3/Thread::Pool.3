.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Thread::Pool 3"
.TH Thread::Pool 3 "2010-09-20" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Thread::Pool \- group of threads for performing similar jobs
.SH "VERSION"
.IX Header "VERSION"
This documentation describes version 0.33.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Thread::Pool;
\& $pool = Thread::Pool\->new(
\&  {
\&   optimize => \*(Aqcpu\*(Aq, # default: \*(Aqmemory\*(Aq
\&
\&   pre => sub {shift; print "starting worker with @_\en",
\&   do => sub {shift; print "doing job for @_\en"; reverse @_},
\&   post => sub {shift; print "stopping worker with @_\en",
\&
\&   stream => sub {shift; print "streamline with @_\en",
\&
\&   monitor => sub { print "monitor with @_\en",
\&   pre_post_monitor_only => 0, # default: 0 = also for "do"
\&
\&   checkpoint => sub { print "checkpointing\en" },
\&   frequency => 1000,
\&
\&   autoshutdown => 1, # default: 1 = yes
\&
\&   workers => 10,     # default: 1
\&   maxjobs => 50,     # default: 5 * workers
\&   minjobs => 5,      # default: maxjobs / 2
\&  },
\&  qw(a b c)           # parameters to "pre" and "post" routine
\& );
\&
\& $pool\->job( qw(d e f) );              # not interested in result
\&
\& $jobid = $pool\->job( qw(g h i) );
\& @result = $pool\->result( $jobid );    # wait for result to be ready
\&
\& $jobid = $pool\->job( qw(j k l) );
\& @result = $pool\->result_dontwait( $jobid ); # do _not_ wait for result
\&
\& @result = $pool\->waitfor( qw(m n o) ); # submit and wait for result
\&
\& $pool\->add;           # add worker(s)
\& $pool\->remove;        # remove worker(s)
\& $pool\->workers( 10 ); # adapt number of workers
\& $pool\->join;          # wait for all removed worker threads to finish
\&
\& $workers = $pool\->workers; 
\& $todo    = $pool\->todo;
\& $removed = $pool\->removed;
\&
\& $pool\->maxjobs( 100 );  # adapt or (de\-)activate job throttling
\& $pool\->minjobs( 10 );
\&
\& $pool\->autoshutdown( 1 ); # shutdown when object is destroyed
\& $pool\->shutdown;          # wait until all jobs done
\& $pool\->abort;             # finish current job and remove all workers
\&
\& $done    = $pool\->done;   # simple thread\-use statistics
\& $notused = $pool\->notused;
\&
\& Thread::Pool\->remove_me;  # inside "do" only
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 1
\&                  *** A note of CAUTION ***
\&
\& This module only functions on Perl versions 5.8.0 and later.
\& And then only when threads are enabled with \-Dusethreads.
\& It is of no use with any version of Perl before 5.8.0 or
\& without threads enabled.
\&
\&                  *************************
.Ve
.PP
The Thread::Pool allows you to set up a group of (worker) threads to execute
a (large) number of similar jobs that need to be executed asynchronously.  The
routine that actually performs the job (the \*(L"do\*(R" routine), must be specified
as a name or a reference to a (anonymous) subroutine.
.PP
Once a pool is created, jobs can be executed at will and will be assigned
to the next available worker.  If the result of the job is important, a
job \s-1ID\s0 is issued.  The job \s-1ID\s0 can then later be used to obtain the result.
.PP
Initialization parameters can be passed during the creation of the
Thread::Pool object.  The initialization (\*(L"pre\*(R") routine can be specified
as a name or as a reference to a (anonymous) subroutine.  The \*(L"pre\*(R" routine
can e.g. be used to create a connection to an external source using a
non-threadsafe library.
.PP
When a worker is told to finish, the \*(L"post\*(R" routine is executed if available.
.PP
Results of jobs must be obtained seperately, unless a \*(L"stream\*(R" or a \*(L"monitor\*(R"
routine is specified.  Then the result of each job will be streamed to the
\&\*(L"stream\*(R" or \*(L"monitor\*(R" routine in the order in which the jobs were submitted.
.PP
Unless told otherwise, all jobs that are assigned, will be executed before
the pool is allowed to be destroyed.  If a \*(L"stream\*(R" or \*(L"monitor\*(R" routine
is specified, then all results will be handled by that routine before the
pool is allowed to be destroyed.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
The following class methods are available.
.SS "new"
.IX Subsection "new"
.Vb 3
\& $pool = Thread::Pool\->new(
\&  {
\&   optimize => \*(Aqcpu\*(Aq,                            # default: memory
\&
\&   do => sub { print "doing with @_\en" },        # must have
\&   pre => sub { print "starting with @_\en",      # default: none
\&   post => sub { print "stopping with @_\en",     # default: none
\&
\&   stream => sub { print "streamline with @_\en", # default: none
\&
\&   monitor => sub { print "monitor with @_\en",   # default: none
\&   pre_post_monitor_only => 0, # default: 0 = also for "do"
\&   checkpoint => \e&checkpoint,
\&   frequency => 1000,
\&
\&   autoshutdown => 1, # default: 1 = yes
\&
\&   workers => 10,     # default: 1
\&   maxjobs => 50,     # default: 5 * workers
\&   minjobs => 5,      # default: maxjobs / 2
\&  },
\&
\&  qw(a b c)           # parameters to "pre" and "post" routines
\&
\& );
.Ve
.PP
The \*(L"new\*(R" method returns the Thread::Pool object.
.PP
The first input parameter is a reference to a hash that should at least
contain the \*(L"do\*(R" key with a subroutine reference.
.PP
The other input parameters are optional.  If specified, they are passed to the
the \*(L"pre\*(R" subroutine whenever a new worker is added.
.PP
Each time a worker thread is added, the \*(L"pre\*(R" subroutine (if available) will
be called inside the thread.  Each time a worker thread is removed, the
\&\*(L"post\*(R" routine is called.  Its return value(s) are saved only if a job \s-1ID\s0 was
requested when removing the thread.  Then the result method can be called
to obtain the results of the \*(L"post\*(R" subroutine.
.PP
The following field \fBmust\fR be specified in the hash reference:
.IP "optimize" 2
.IX Item "optimize"
.Vb 1
\& optimize => \*(Aqcpu\*(Aq, # default: \*(Aqmemory\*(Aq
.Ve
.Sp
The \*(L"optimize\*(R" field specifies which implementation of the belt will be
selected.  Currently there are two choices: 'cpu' and 'memory'.  By default,
the \*(L"memory\*(R" optimization will be selected if no specific optmization is
specified.
.Sp
You can call the class method optimize to change the default optimization.
.IP "do" 2
.IX Item "do"
.Vb 1
\& do => \*(Aqdo_the_job\*(Aq,            # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& do => \*(AqPackage::do_the_job\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& do => \e&SomeOther::do_the_job,
.Ve
.Sp
or:
.Sp
.Vb 1
\& do => sub {print "anonymous sub doing the job\en"},
.Ve
.Sp
The \*(L"do\*(R" field specifies the subroutine to be executed for each job.  It
must be specified as either the name of a subroutine or as a reference to a
(anonymous) subroutine.
.Sp
The specified subroutine should expect the following parameters to be passed:
.Sp
.Vb 1
\& 1..N  any parameters that were passed with the call to L<job>.
.Ve
.Sp
Any values that are returned by this subroutine after finishing each job, are
accessible with result if a job \s-1ID\s0 was requested when assigning the job.
.PP
The following fields are \fBoptional\fR in the hash reference:
.IP "pre" 2
.IX Item "pre"
.Vb 1
\& pre => \*(Aqprepare_jobs\*(Aq,         # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& pre => \*(AqPackage::prepare_jobs\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& pre => \e&SomeOther::prepare_jobs,
.Ve
.Sp
or:
.Sp
.Vb 1
\& pre => sub {print "anonymous sub preparing the jobs\en"},
.Ve
.Sp
The \*(L"pre\*(R" field specifies the subroutine to be executed \fBeach\fR time a new
worker thread is \fBstarted\fR (either when starting the pool, or when new worker
threads are added with a call to either add or workers) and once when a
\&\*(L"monitor\*(R" routine is specified.  It must be specified as either the name of a
subroutine or as a reference to a (anonymous) subroutine.
.Sp
The specified subroutine should expect the following parameters to be passed:
.Sp
.Vb 1
\& 1..N  any additional parameters that were passed with the call to L<new>.
.Ve
.Sp
You can determine whether the \*(L"pre\*(R" routine is called for a new worker thread
or for a monitoring thread by checking the self or monitor class method
inside the \*(L"pre\*(R" routine.
.IP "post" 2
.IX Item "post"
.Vb 1
\& post => \*(Aqcleanup_after_worker\*(Aq,        # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& post => \*(AqPackage::cleanup_after_worker\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& post => \e&SomeOther::cleanup_after_worker,
.Ve
.Sp
or:
.Sp
.Vb 1
\& post => sub {print "anonymous sub cleaning up after the worker removed\en"},
.Ve
.Sp
The \*(L"post\*(R" field specifies the subroutine to be executed \fBeach\fR time a worker
thread is \fBremoved\fR (either when being specifically removed, or when the
pool is shutdown specifically or implicitely when the Thread::Pool object
is destroyed.  It must be specified as either the name of a subroutine or as
a reference to a (anonymous) subroutine.
.Sp
The specified subroutine should expect the following parameters to be passed:
.Sp
.Vb 1
\& 1..N  any additional parameters that were passed with the call to L<new>.
.Ve
.Sp
Any values that are returned by this subroutine after closing down the thread,
are accessible with the result method, but only if the thread was
removed and a job \s-1ID\s0 was requested.
.Sp
You can determine whether the \*(L"post\*(R" routine is called for a new worker thread
or for a monitoring thread by checking the self or monitor class method
inside the \*(L"post\*(R" routine.
.IP "stream" 2
.IX Item "stream"
.Vb 1
\& stream => \*(Aqin_order_of_submit\*(Aq,        # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& stream => \*(AqPackage::in_order_of_submit\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& stream => \e&SomeOther::in_order_of_submit,
.Ve
.Sp
or:
.Sp
.Vb 1
\& stream => sub {print "anonymous sub called in order of submit\en"},
.Ve
.Sp
The \*(L"stream\*(R" field specifies the subroutine to be executed for streaming the
results of the \*(L"do\*(R" routine.  If specified, the \*(L"stream\*(R" routine is called
once for the result of each \*(L"do\*(R" subroutine, but in the order in which the
jobs were submitted rather than in the order in which the result were
obtained (which is by the very nature of threads, indeterminate).
.Sp
The specified subroutine should expect the following parameters to be passed:
.Sp
.Vb 2
\& 1     the Thread::Pool object to which the worker thread belongs.
\& 2..N  the values that were returned by the "do" subroutine
.Ve
.Sp
The \*(L"stream\*(R" routine is executed in \fBany\fR of the threads that are created
for the Thread::Pool object.  The system attempts to call the \*(L"stream\*(R"
routine in the same thread from which the values are obtained, but when
things get out of sync, other threads may stream the result of a job.  If
you want \fBonly one\fR thread to stream all results, use the \*(L"monitor\*(R" routine.
.IP "monitor" 2
.IX Item "monitor"
.Vb 1
\& monitor => \*(Aqin_order_of_submit\*(Aq,       # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& monitor => \*(AqPackage::in_order_of_submit\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& monitor => \e&SomeOther::in_order_of_submit,
.Ve
.Sp
or:
.Sp
.Vb 1
\& monitor => sub {print "anonymous sub called in order of submit\en"},
.Ve
.Sp
The \*(L"monitor\*(R" field specifies the subroutine to be executed for monitoring the
results of the \*(L"do\*(R" routine.  If specified, the \*(L"monitor\*(R" routine is called
once for the result of each \*(L"do\*(R" subroutine, but in the order in which the
jobs were submitted rather than in the order in which the result were
obtained (which is by the very nature of threads, indeterminate).
.Sp
The specified subroutine should expect the following parameters to be passed:
.Sp
.Vb 1
\& 1..N  the values that were returned by the "do" subroutine
.Ve
.Sp
The \*(L"monitor\*(R" routine is executed in its own thread.  This means that all
results have to be passed between threads, and therefore be frozen and thawed
with Storable.  If you can handle the streaming from different threads,
it is probably wiser to use the \*(L"stream\*(R" routine feature.
.IP "pre_post_monitor_only" 2
.IX Item "pre_post_monitor_only"
.Vb 1
\& pre_post_monitor_only => 1, # default 0
.Ve
.Sp
The \*(L"pre_post_monitor_only\*(R" field only makes sense if a \*(L"monitor\*(R" routine
is specified.  If specified with a true value, indicates that the \*(L"pre\*(R" and
\&\*(L"post\*(R" routines (if specified) should only be called for the \*(L"monitor\*(R"
routine only and \fBnot\fR for the \*(L"do\*(R" routine.  Otherwise, the same \*(L"pre\*(R" and
\&\*(L"post\*(R" routine will be called for both the \*(L"do\*(R" as well as the \*(L"monitor\*(R"
routine.
.Sp
When the \*(L"pre\*(R" and \*(L"post\*(R" routine are called for the \*(L"do\*(R" subroutine, the
self class method returns the Thread::Pool object (which it doesn't do
when called in the \*(L"monitor\*(R" routine).
.IP "checkpoint" 2
.IX Item "checkpoint"
.Vb 1
\& checkpoint => \*(Aqcheckpointing\*(Aq,                 # assume caller\*(Aqs namespace
.Ve
.Sp
or:
.Sp
.Vb 1
\& checkpoint => \*(AqPackage::checkpointing\*(Aq,
.Ve
.Sp
or:
.Sp
.Vb 1
\& checkpoint => \e&SomeOther::checkpointing,
.Ve
.Sp
or:
.Sp
.Vb 1
\& checkpoint => sub {print "anonymous sub to do checkpointing\en"},
.Ve
.Sp
The \*(L"checkpoint\*(R" field specifies the subroutine to be executed everytime a
checkpoint should be made by a monitoring routine (e.g. for saving or updating
status).  It must be specified as either the name of a subroutine or as a
reference to a (anonymous) subroutine.
.Sp
It only makes sense to specify a checkpoint routine if there is also a
monitoring routine specified.  No checkpointing will occur by default if a
monitoring routine \fBis\fR specified.  The frequency of checkpointing can
be specified with the \*(L"frequency\*(R" field.
.Sp
The specified subroutine should not expect any parameters to be passed.  Any
values returned by the checkpointing routine, will be lost.
.IP "frequency" 2
.IX Item "frequency"
.Vb 1
\& frequency => 100,                             # default = 1000
.Ve
.Sp
The \*(L"frequency\*(R" field specifies the number of jobs that should have been
monitored before the \*(L"checkpoint\*(R" routine is called.  If a checkpoint routine
is specified but no frequency field is specified, then a frequency of \fB1000\fR
will be assumed.
.Sp
This field has no meaning if no checkpoint routine is specified with the
\&\*(L"checkpoint\*(R" field.  The default frequency can be changed with the frequency
method.
.IP "autoshutdown" 2
.IX Item "autoshutdown"
.Vb 1
\& autoshutdown => 0, # default: 1
.Ve
.Sp
The \*(L"autoshutdown\*(R" field specified whether the shutdown method should be
called when the object is destroyed.  By default, this flag is set to 1
indicating that the shutdown method should be called when the object is
being destroyed.  Setting the flag to a false value, will cause the shutdown
method \fBnot\fR to be called, causing potential loss of data and error messages
when threads are not finished when the program exits.
.Sp
The setting of the flag can be later changed by calling the autoshutdown
method.
.IP "workers" 2
.IX Item "workers"
.Vb 1
\& workers => 5, # default: 1
.Ve
.Sp
The \*(L"workers\*(R" field specifies the number of worker threads that should be
created when the pool is created.  If no \*(L"workers\*(R" field is specified, then
only one worker thread will be created.  The workers method can be used
to change the number of workers later.
.IP "maxjobs" 2
.IX Item "maxjobs"
.Vb 1
\& maxjobs => 25, # default: 5 * workers
.Ve
.Sp
The \*(L"maxjobs\*(R" field specifies the \fBmaximum\fR number of jobs that can be sitting
on the belt to be handled (job throttling).  If a new job submission
would exceed this amount, job submission will be halted until the number of
jobs waiting to be handled has become at least as low as the amount specified
with the \*(L"minjobs\*(R" field.
.Sp
If the \*(L"maxjobs\*(R" field is not specified, an amount of 5 * the number of
worker threads will be assumed.  If you do not want to have any job throttling,
you can specify the value \*(L"undef\*(R" for the field.  But beware!  If you do not
have job throttling active, you may wind up using excessive amounts of memory
used for storing all of the job submission information.
.Sp
The maxjobs method can be called to change the job throttling settings
during the lifetime of the object.
.IP "minjobs" 2
.IX Item "minjobs"
.Vb 1
\& minjobs => 10, # default: maxjobs / 2
.Ve
.Sp
The \*(L"minjobs\*(R" field specified the \fBminimum\fR number of jobs that can be
waiting on the belt to be handled before job submission is allowed again
(job throttling).
.Sp
If job throttling is active and the \*(L"minjobs\*(R" field is not specified, then
half of the \*(L"maxjobs\*(R" value will be assumed.
.Sp
The minjobs method can be called to change the job throttling settings
during the lifetime of the object.
.SS "frequency"
.IX Subsection "frequency"
.Vb 1
\& Thread::Pool\->frequency( 100 );
\&
\& $frequency = Thread::Pool\->frequency;
.Ve
.PP
The \*(L"frequency\*(R" class method allows you to specify the default frequency that
will be used when a checkpoint routine is specified with the \*(L"checkpoint\*(R"
field.  The default frequency is set to \fB1000\fR if no other value has been
previously specified.
.SS "optimize"
.IX Subsection "optimize"
.Vb 1
\& Thread::Pool\->optimize( \*(Aqcpu\*(Aq );
\&
\& $optimize = Thread::Pool\->optimize;
.Ve
.PP
The \*(L"optimize\*(R" class method allows you to specify the default optimization
type that will be used if no \*(L"optimize\*(R" field has been explicitely specified
with a call to new.  It returns the current default type of optimization.
.PP
Currently two types of optimization can be selected:
.IP "memory" 2
.IX Item "memory"
Attempt to use as little memory as possible.  Currently, this is achieved by
starting a seperate thread which hosts an unshared array.  This uses the
\&\*(L"Thread::Conveyor::Thread\*(R" sub-class.
.IP "cpu" 2
.IX Item "cpu"
Attempt to use as little \s-1CPU\s0 as possible.  Currently, this is achieved by
using a shared array (using the \*(L"Thread::Conveyor::Array\*(R" sub-class),
encapsulated in a hash reference if throttling is activated (then also using
the \*(L"Thread::Conveyor::Throttled\*(R" sub-class).
.SH "POOL METHODS"
.IX Header "POOL METHODS"
The following methods can be executed on the Thread::Pool object.
.SS "job"
.IX Subsection "job"
.Vb 2
\& $jobid = $pool\->job( @parameter );     # saves result
\& $pool\->job( @parameter );              # does not save result
.Ve
.PP
The \*(L"job\*(R" method specifies a job to be executed by any of the available
workers.  Which worker will execute the job, is indeterminate.  When it
will happen, depends on the number of jobs that still have to be done when
this job was submitted.
.PP
The input parameters are passed to the \*(L"do\*(R" subroutine as is.
.PP
If a return value is requested, then the return value(s) of the \*(L"do\*(R"
subroutine will be saved.  The returned value is a job \s-1ID\s0 that should be
used as the input parameter to result or result_dontwait.
.SS "waitfor"
.IX Subsection "waitfor"
.Vb 1
\& @result = $pool\->waitfor( @parameter ); # submit job and wait for result
.Ve
.PP
The \*(L"waitfor\*(R" method specifies a job to be executed, wait for the result to
become ready and return the result.  It is in fact a shortcut for using
job and result.
.PP
The input parameters are passed to the \*(L"do\*(R" subroutine as is.
.PP
The return value(s) are what was returned by the \*(L"do\*(R" routine.  The meaning
of the return value(s) is entirely up to you as the developer.
.SS "result"
.IX Subsection "result"
.Vb 1
\& @result = $pool\->result( $jobid );
.Ve
.PP
The \*(L"result\*(R" method waits for the specified job to be finished and returns
the result of that job.
.PP
The input parameter is the job id as returned from the job assignment.
.PP
The return value(s) are what was returned by the \*(L"do\*(R" routine.  The meaning
of the return value(s) is entirely up to you as the developer.
.PP
If you want to wait for \fBany\fR job to be finished, use the result_any
method.
.PP
If you don't want to wait for the job to be finished, but just want to see
if there is a result already, use the result_dontwait method.
.SS "result_any"
.IX Subsection "result_any"
.Vb 1
\& @result = $pool\->result_any;
\&
\& @result = $pool\->result_any( \e$jobid );
.Ve
.PP
The \*(L"result_any\*(R" method waits for \fBany\fR job to be finished and returns
the result of that job.
.PP
The optional input parameter is the reference to a scalar variable in which
the job id will be stored.
.PP
The return value(s) are what was returned by the \*(L"do\*(R" routine.  The meaning
of the return value(s) is entirely up to you as the developer.
.PP
If you don't want to wait for a job to be finished, but just want to see
if there is a result already, use the result_dontwait method.
.SS "result_dontwait"
.IX Subsection "result_dontwait"
.Vb 1
\& @result = $pool\->result_dontwait( $jobid );
.Ve
.PP
The \*(L"result_dontwait\*(R" method returns the result of the job if it is available.
If the job is not finished yet, it will return undef in scalar context or the
empty list in list context.
.PP
The input parameter is the job id as returned from the job assignment.
.PP
If the result of the job is available, then the return value(s) are what was
returned by the \*(L"do\*(R" routine.  The meaning of the return value(s) is entirely
up to you as the developer.
.PP
If you want to wait for the job to be finished, use the result method.
.SS "todo"
.IX Subsection "todo"
.Vb 1
\& $todo = $pool\->todo;
.Ve
.PP
The \*(L"todo\*(R" method returns the number of jobs that are still left to be
done.
.SS "results"
.IX Subsection "results"
.Vb 2
\& $results = $pool\->results;
\& @result = $pool\->results;
.Ve
.PP
The \*(L"results\*(R" method returns the jobids of which there are results available
and which have not yet been fetched with result.  Returns the number of
results available in scalar context.
.SS "add"
.IX Subsection "add"
.Vb 2
\& $tid = $pool\->add;             # add 1 worker thread
\& @tid = $pool\->add( 5 );
.Ve
.PP
The \*(L"add\*(R" method adds the specified number of worker threads to the pool
and returns the thread \s-1ID\s0's (tid) of the threads that were created.
.PP
The input parameter specifies the number of workers to be added.  If no
number of workers is specified, then 1 worker thread will be added.
.PP
In scalar context, returns the thread \s-1ID\s0 (tid) of the first worker thread
that was added.  This usually only makes sense if you're adding only one
worker thread.
.PP
In list context, returns the thread \s-1ID\s0's (tid) of the worker threads that
were created.
.PP
Each time a worker thread is added, the \*(L"pre\*(R" routine (if available) will
be called inside the thread.
.SS "remove"
.IX Subsection "remove"
.Vb 2
\& $pool\->remove;                 # remove 1 worker thread
\& $pool\->remove( 5 );            # remove 5 worker threads
\&
\& $jobid = $pool\->remove;        # remove 1 worker thread, save result
\& @jobid = $pool\->remove( 5 );   # remove 5 worker threads, save results
.Ve
.PP
The \*(L"remove\*(R" method adds the specified number of special \*(L"remove\*(R" job to the
lists of jobs to be done.  It will return the job \s-1ID\s0's if called in a non-void
context.
.PP
The input parameter specifies the number of workers to be removed.  If no
number of workers is specified, then 1 worker thread will be removed.
.PP
In void context, the results of the execution of the \*(L"post\*(R" subroutine(s)
is discarded.
.PP
In scalar context, returns the job \s-1ID\s0 of the result of the first worker
thread that was removed.  This usually only makes sense if you're removing
only one worker thread.
.PP
In list context, returns the job \s-1ID\s0's of the result of all the worker
threads that were removed.
.PP
Each time a worker thread is removed, the \*(L"post\*(R" routine is called.  Its
return value(s) are saved only if a job \s-1ID\s0 was requested when removing the
thread.  Then the result method can be called to obtain the results of
the \*(L"post\*(R" subroutine.
.SS "workers"
.IX Subsection "workers"
.Vb 2
\& $workers = $pool\->workers;     # find out number of worker threads
\& $pool\->workers( 10 );          # set number of worker threads
.Ve
.PP
The \*(L"workers\*(R" method can be used to find out how many worker threads there
are currently available, or it can be used to set the number of worker
threads.
.PP
The input value, if specified, specifies the number of worker threads that
should be available.  If there are more worker threads available than the
number specified, then superfluous worker threads will be removed.  If
there are not enough worker threads available, new worker threads will be
added.
.PP
The return value is the current number of worker threads.
.SS "frequency"
.IX Subsection "frequency"
.Vb 1
\& $frequency = $pool\->frequency;
.Ve
.PP
The \*(L"frequency\*(R" instance method returns the frequency with which the checkpoint
routine is being called.  Returns undef if no checkpointing is being done.
.SS "maxjobs"
.IX Subsection "maxjobs"
.Vb 2
\& $pool\->maxjobs( 100 );
\& $maxjobs = $pool\->maxjobs;
.Ve
.PP
The \*(L"maxjobs\*(R" method returns the maximum number of jobs that can be on the
belt before job throttling sets in.  The input value, if specified,
specifies the new maximum number of jobs that may be on the belt.  Job
throttling will be switched off if the value \fB0\fR is specified.
.PP
Specifying the \*(L"maxjobs\*(R" field when creating the pool object with new is
equivalent to calling this method.
.PP
The minjobs method can be called to specify the minimum number of jobs
that must be on the belt before job submission is allowed again after reaching
the maximum number of jobs.  By default, half of the \*(L"maxjobs\*(R" value is
assumed.
.SS "minjobs"
.IX Subsection "minjobs"
.Vb 2
\& $pool\->minjobs( 50 );
\& $minjobs = $pool\->minjobs;
.Ve
.PP
The \*(L"minjobs\*(R" method returns the minimum number of jobs that must be on the
belt before job submission is allowed again after reaching the maximum number
of jobs.  The input value, if specified, specifies the new minimum number of
jobs that must be on the belt.
.PP
Specifying the \*(L"minjobs\*(R" field when creating the pool object with new is
equivalent to calling this method.
.PP
The maxjobs method can be called to set the maximum number of jobs that
may be on the belt before job submission will be halted.
.SS "join"
.IX Subsection "join"
.Vb 1
\& $pool\->join;
.Ve
.PP
The \*(L"join\*(R" method waits until all of the worker threads that have been
removed have finished their jobs.  It basically cleans up the threads
that are not needed anymore.
.PP
The \*(L"shutdown\*(R" method call the \*(L"join\*(R" method after removing all the active
worker threads.  You therefore seldom need to call the \*(L"join\*(R" method
seperately.
.SS "removed"
.IX Subsection "removed"
.Vb 1
\& $removed = $pool\->removed;
.Ve
.PP
The \*(L"removed\*(R" method returns the number of worker threads that were
removed over the lifetime of the object.
.SS "autoshutdown"
.IX Subsection "autoshutdown"
.Vb 2
\& $pool\->autoshutdown( 1 );
\& $autoshutdown = $pool\->autoshutdown;
.Ve
.PP
The \*(L"autoshutdown\*(R" method sets and/or returns the flag indicating whether an
automatic shutdown should be performed when the object is destroyed.
.SS "shutdown"
.IX Subsection "shutdown"
.Vb 1
\& $pool\->shutdown;
.Ve
.PP
The \*(L"shutdown\*(R" method waits for all jobs to be executed, removes
all worker threads, handles any results that still need to be streamed, before
it returns.  Call the abort method if you do not want to wait until all
jobs have been executed.
.PP
It is called automatically when the object is destroyed, unless specifically
disabled by providing a false value with the \*(L"autoshutdown\*(R" field when
creating the pool with new, or by calling the autoshutdown method.
.SS "abort"
.IX Subsection "abort"
The \*(L"abort\*(R" method waits for all worker threads to finish their \fBcurrent\fR
job, removes all worker threads, before it returns.  Call the shutdown
method if you want to wait until all jobs have been done.
.PP
You can restart the job handling process after calling \*(L"abort\*(R" by adding
workers again.
.SS "done"
.IX Subsection "done"
.Vb 1
\& $done = $pool\->done;
.Ve
.PP
The \*(L"done\*(R" method returns the number of jobs that has been performed by
the removed worker threads of the pool.
.PP
The \*(L"done\*(R" method is typically called after the shutdown method
has been called.
.SS "notused"
.IX Subsection "notused"
.Vb 1
\& $notused = $pool\->notused;
.Ve
.PP
The \*(L"notused\*(R" method returns the number of removed threads that have not
performed any jobs.  It provides a heuristic to determine how many
workers you actually need for a specific application: a value > 0
indicates that you have specified too many worker threads for this
application.
.PP
The \*(L"notused\*(R" method is typically called after the shutdown method
has been called.
.SH "INSIDE JOB METHODS"
.IX Header "INSIDE JOB METHODS"
The following methods only make sense inside the \*(L"pre\*(R", \*(L"do\*(R", \*(L"post\*(R",
\&\*(L"stream\*(R" and \*(L"monitor\*(R" routines.
.SS "self"
.IX Subsection "self"
.Vb 1
\& $self = Thread::Pool\->self;
.Ve
.PP
The class method \*(L"self\*(R" returns the object to which this thread belongs.
It is available within the \*(L"pre\*(R", \*(L"do\*(R", \*(L"post\*(R", \*(L"stream\*(R" and \*(L"monitor\*(R"
subroutines only.
.SS "monitor"
.IX Subsection "monitor"
.Vb 1
\& $monitor = Thread::Pool\->monitor;
.Ve
.PP
The class method \*(L"monitor\*(R" returns the Thread::Conveyor::Monitored object
that is associated with the pool.  It is available only if the \*(L"monitor\*(R"
field was specified in new.  And then only within the \*(L"pre\*(R", \*(L"do\*(R", \*(L"post\*(R",
\&\*(L"stream\*(R" and \*(L"monitor\*(R" subroutines only.
.SS "remove_me"
.IX Subsection "remove_me"
.Vb 1
\& Thread::Pool\->remove_me;
.Ve
.PP
The \*(L"remove_me\*(R" class method only makes sense within the \*(L"do\*(R" subroutine.
It indicates to the job dispatcher that this worker thread should be removed
from the pool.  After the \*(L"do\*(R" subroutine returns, the worker thread will
be removed.
.SS "jobid"
.IX Subsection "jobid"
.Vb 1
\& $jobid = Thread::Pool\->jobid;
.Ve
.PP
The \*(L"jobid\*(R" class method only makes sense within the \*(L"do\*(R" subroutine in
streaming mode.  It returns the job \s-1ID\s0 value of the current job.  This can
be used connection with the dont_set_result and the set_result methods
to have another thread set the result of the current job.
.SS "dont_set_result"
.IX Subsection "dont_set_result"
.Vb 1
\& Thread::Pool\->dont_set_result;
.Ve
.PP
The \*(L"dont_set_result\*(R" class method only makes sense within the \*(L"do\*(R" subroutine.
It indicates to the job dispatcher that the result of this job should \fBnot\fR
be saved.  This is for cases where the result of this job will be placed in
the result hash at some time in the future by another thread using the
set_result method.
.SS "set_result"
.IX Subsection "set_result"
.Vb 1
\& Thread::Pool\->self\->set_result( $jobid,@param );
.Ve
.PP
The \*(L"set_result\*(R" object method only makes sense within the \*(L"do\*(R" subroutine.
It allows you to set the result of \fBother\fR jobs than the one currently being
performed.
.PP
This method is only needed in \fBvery\fR special situations.  Normally, just
returning values from the \*(L"do\*(R" subroutine is enough to have the result saved.
This method is exposed to the outside world in those cases where a specific
thread becomes responsible for setting the result of other threads (which
used the dont_set_result method to defer saving their result.
.PP
The first input parameter specifies the job \s-1ID\s0 of the job for which to set
the result.  The rest of the input parameters is considered to be the result
to be saved.  Whatever is specified in the rest of the input parameters, will
be returned with the result or result_dontwait methods.
.SH "REQUIRED MODULES"
.IX Header "REQUIRED MODULES"
.Vb 2
\& Thread::Conveyor (0.15)
\& Thread::Conveyor::Monitored (0.11)
.Ve
.SH "OPTIMIZATIONS"
.IX Header "OPTIMIZATIONS"
This module uses load to reduce memory and \s-1CPU\s0 usage. This causes
subroutines only to be compiled in a thread when they are actually needed at
the expense of more \s-1CPU\s0 when they need to be compiled.  Simple benchmarks
however revealed that the overhead of the compiling single routines is not
much more (and sometimes a lot less) than the overhead of cloning a Perl
interpreter with a lot of subroutines pre-loaded.
.SH "CAVEATS"
.IX Header "CAVEATS"
Passing unshared values between threads is accomplished by serializing the
specified values using Thread::Serialize.  Please see the \s-1CAVEATS\s0 section
there for an up-to-date status of what can be passed around between threads.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
There are currently two examples.
.SS "simple asynchronous log file resolving filter"
.IX Subsection "simple asynchronous log file resolving filter"
This is an example of a very simple asynchronous log file resolver filter.
.PP
Because the \s-1IP\s0 number to domain name translation is dependent on external
\&\s-1DNS\s0 servers, it can take quite some (wallclock) time before a response is
returned by the \f(CW\*(C`gethostbyaddr\*(C'\fR function.  In a single threaded environment,
a single bad \s-1DNS\s0 server can severely slow down the resolving process.  In a
threaded environment, you can have one thread waiting for a slow \s-1DNS\s0 server
while other threads are able to obtain answers in the mean time.
.PP
This example uses a shared hash to keep results from \s-1DNS\s0 server responses,
so that if an \s-1IP\s0 number was attempted to be resolved once (either successfully
or unsuccessfully), it will not be attempted again: instead the value from the
hash will be assumed.
.PP
.Vb 3
\& # You should always use strict!
\& # Using Thread::Pool by itself is enough, no "use threads;" needed
\& # Initialize the shared hash with IP numbers and their results
\&
\& use strict;
\& use Thread::Pool;
\& my %resolved : shared;
\&
\& # Create the pool of threads
\&
\& my $pool = Thread::Pool\->new(
\&  {
\&   workers => 10,
\&   do => \e&do,
\&   monitor => \e&monitor,
\&  }
\& );
\&
\& # Submit each line as a job to the pool
\&
\& $pool\->job( $_ ) while <>;
\&
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& # Handle a single job
\& #  IN: 1 log line to resolve
\& # OUT: 1 resolved log line
\&
\& sub do {
\&
\& # Substitute the IP number at the start with the name or with the original
\& # Return the adapted value
\&
\&   $_[0] =~ s#^(\ed+\e.\ed+\e.\ed+\e.\ed+)#
\&    $resolved{$1} ||= gethostbyaddr( pack( \*(AqC4\*(Aq,split(/\e./,$1)),2 ) || $1#e;
\&   $_[0];
\& } #do
\&
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& # Output the results in the order they were submitted
\& #  IN: 1 resolved log line
\&
\& sub monitor { print $_[0] } #monitor
.Ve
.PP
This is a very simple filter.  The main drawback is that many threads can
be looking up the same \s-1IP\s0 number at the same time.
.SS "another asynchronous log file resolving filter"
.IX Subsection "another asynchronous log file resolving filter"
This is an example of a not so very simple asynchronous log file resolver
filter.  This is in fact the base code for the Thread::Pool::Resolve
module.
.PP
In this example, the dont_set_result and set_result methods are used
to put up all lines with the same unresolved \s-1IP\s0 number in the same thread
until the \s-1DNS\s0 server returns, either with or without a result.  Then all
the lines with that \s-1IP\s0 number are handled by that thread: the other threads
have long before that already continued attempting to handle other lines.
.PP
Because only the \*(L"do\*(R" subroutine is different from the previous example,
we're only showing that.
.PP
.Vb 4
\& #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& # Handle a single job
\& #  IN: 1 log line to resolve
\& # OUT: 1 resolved log line (if already resolved, else ignored)
\&
\& sub do {
\&
\& # Obtain the line to work with
\& # Return it now if it is already resolved (at least not an IP number there)
\& # Save the IP number for later usage, line is now without IP number
\&
\&   my $line = shift;
\&   return $line unless $line =~ s#^(\ed+\e.\ed+\e.\ed+\e.\ed+)##;
\&   my $ip = $1;
\&
\& # Make sure we\*(Aqre the only one to access the resolved hash now
\& # If there is already information for this IP number
\& #  Return what is there with the line if it was resolved already
\&
\&   {lock( %resolved );
\&    if (exists( $resolved{$ip} )) {
\&      return ($resolved{$ip} || $ip).$line unless ref( $resolved{$ip} );
\&
\& #  Set the rest of the line in the todo hash, keyed to jobid
\& #  Set the flag that this result should not be set in the result hash
\& #  And return without anything (thread will continue with next job)
\&
\&      $resolved{$ip}\->{Thread::Pool\->jobid} = $line;
\&      Thread::Pool\->dont_set_result;
\&      return;
\&
\& # Else (first time this IP number is encountered)
\& #  Create a empty shared hash
\& #  Save a reference to the hash in the todo hash as info for this IP number
\&
\&    } else {
\&      my %hash : shared;
\&      $resolved{$ip} = \e%hash;
\&    }
\&   } #%resolved
\&
\& # Do the actual name resolving (may take quite some time) or use IP number
\& # Obtain local copy of the Thread::Pool object
\& # Obtain local copy of the todo hash
\&
\&   my $domain = gethostbyaddr( pack( \*(AqC4\*(Aq,split(/\e./,$ip)),2 ) || $ip;
\&   my $pool = Thread::Pool\->self;
\&   my $todo = $resolved{$ip};
\&
\& # Make sure we\*(Aqre the only one accessing the resolved hash (rest of this sub)
\& # For all the lines with this IP number
\& #  Set the results
\& # Remove the todo hash and replace by domain or blank string if unresolvable
\& # Return the result for this job
\&
\&   lock( %resolved );
\&   while (my $key = each %{$todo}) {
\&       $pool\->set_result( $key,$domain.$todo\->{$key} )
\&   }
\&   $resolved{$ip} = $domain eq $ip ? undef : $domain;
\&   $domain.$line;
\& } #do
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Elizabeth Mattijsen, <liz@dijkmat.nl>.
.PP
Please report bugs to <perlbugs@dijkmat.nl>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002, 2003, 2010 Elizabeth Mattijsen <liz@dijkmat.nl>. All rights
reserved.  This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
threads, Thread::Conveyor, Thread::Conveyor::Monitored,
Thread::Serialize.
